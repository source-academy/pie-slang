import * as S from "../types/source";

import { SchemeLexer } from "../../scheme_parser/transpiler/lexer/scheme-lexer";
import { SchemeParser } from "../../scheme_parser/transpiler/parser/scheme-parser";

import { Extended, Atomic, Expression } from '../../scheme_parser/transpiler/types/nodes/scheme-node-types';
import { Location, Syntax } from "../utils/locations";
import { Location as Loc } from '../../scheme_parser/transpiler/types/location';
import { isVarName, SiteBinder, TypedBinder } from "../types/utils";
import { EliminateNatTactic, EliminateListTactic, ExactTactic, IntroTactic, Tactic } from "../tactics/tactics";
import * as Maker from "./makers"

type Element = Extended.List | Atomic.Symbol | Atomic.NumericLiteral;

// ### Helper functions

export function syntaxToLocation(syntax: Syntax): Location {
  return new Location(
    syntax,
    true,
  );
}

function syntaxToSiteBinder(syntax: Syntax): SiteBinder {
  return new SiteBinder(
    syntaxToLocation(syntax),
    syntax.source
  )
}

function getValue(element: Element): string {
  if (element instanceof Atomic.Symbol) {
    return element.value;
  } else if (element instanceof Atomic.NumericLiteral) {
    return element.value;
  } else if (element instanceof Extended.List) {
    return getValue(element.elements[0] as Element);
  } else {
    throw new Error('Expected a Element, but got: ' + element);
  }
}

function locationToSyntax(source: string, location: Loc): Syntax {
  return new Syntax(
    location.start,
    location.end,
    source,
  );
}

function elementToSyntax(element: Element, location: Loc): Syntax {
  return locationToSyntax(getValue(element), location);
}

// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
export function schemeParse(stx: string): Extended.List[] {
  const lexer = new SchemeLexer(stx);
  const parser = new SchemeParser('', lexer.scanTokens());
  const ast: Extended.List[] = parser.parse() as Extended.List[];
  return ast;
}

export class Parser {
  public static parsePie(stx: string): S.Source {
    return Parser.parseElements(schemeParse(stx)[0]); 
  }

  public static parseElements(element: Element): S.Source {
    const parsee = getValue(element);
    if (parsee === 'U') {
      return Maker.makeU(locationToSyntax('U', element.location));
    } else if (parsee === 'the') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      return Maker.makeThe(
        locationToSyntax('the', loc),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'Nat') {
      return Maker.makeNat(locationToSyntax('Nat', element.location));
    } else if (parsee === 'zero') {
      return Maker.makeZero(locationToSyntax('zero', element.location));
    } else if (parsee === 'add1') {
      return Maker.makeAdd1(
        locationToSyntax('add1', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === '->' || parsee === '→') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      return Maker.makeArrow(
        locationToSyntax('->', loc),
        [
          this.parseElements(elements[1] as Element),
          this.parseElements(elements[2] as Element),
          elements.slice(3).map((x: Expression) => this.parseElements(x as Element))
        ]
      );
    } else if (parsee === 'lambda' || parsee === 'λ') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;
      return Maker.makeLambda(
        locationToSyntax('λ', loc),
        args.elements.map(
          (x: Expression) =>
            syntaxToSiteBinder(
              elementToSyntax(x as Element, element.location)
            )
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Pi' || parsee === 'Π') {
      let elements = (element as Extended.List).elements;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;

      // Get first binding pair
      let firstPair = args.elements[0] as Extended.List;
      let x0 = firstPair.elements[0] as Element;
      let A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      let remainingPairs = args.elements.slice(1) as Extended.List[];
      let processedPairs = remainingPairs.map(pair => {
        let x = pair.elements[0] as Element;
        let A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makePi(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Sigma' || parsee === 'Σ') {
      let elements = (element as Extended.List).elements;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;

      // Get first binding pair
      let firstPair = args.elements[0] as Extended.List;
      let x0 = firstPair.elements[0] as Element;
      let A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      let remainingPairs = args.elements.slice(1) as Extended.List[];
      let processedPairs = remainingPairs.map(pair => {
        let x = pair.elements[0] as Element;
        let A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makeSigma(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body));
    } else if (parsee === 'Pair') {
      let elements = (element as Extended.List).elements;
      return Maker.makePair(
        locationToSyntax('Pair', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'cons') {
      let elements = (element as Extended.List).elements;
      return Maker.makeCons(
        locationToSyntax('Cons', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'car') {
      return Maker.makeCar(
        locationToSyntax('car', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'cdr') {
      return Maker.makeCdr(
        locationToSyntax('cdr', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'which-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeWhichNat(
        locationToSyntax('which-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'iter-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIterNat(
        locationToSyntax('iter-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'rec-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeRecNat(
        locationToSyntax('rec-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndNat(
        locationToSyntax('ind-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Atom') {
      return Maker.makeAtom(locationToSyntax('Atom', element.location));
    } else if (parsee === 'quote') {
      return Maker.makeQuote(
        locationToSyntax('Quote', element.location),
        getValue((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'Trivial') {
      return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
    } else if (parsee === 'sole') {
      return Maker.makeSole(locationToSyntax('sole', element.location));
    } else if (parsee === 'List') {
      return Maker.makeList(
        locationToSyntax('List', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'nil') {
      return Maker.makeNil(locationToSyntax('nil', element.location));
    } else if (parsee === '::') {
      let elements = (element as Extended.List).elements;
      return Maker.makeListCons(
        locationToSyntax('::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'rec-List') {
      let elements = (element as Extended.List).elements;
      return Maker.makeRecList(
        locationToSyntax('rec-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-List') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndList(
        locationToSyntax('ind-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === '=') {
      let elements = (element as Extended.List).elements;
      return Maker.makeEqual(
        locationToSyntax('=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'same') {
      return Maker.makeSame(
        locationToSyntax('same', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'replace') {
      let elements = (element as Extended.List).elements;
      return Maker.makeReplace(
        locationToSyntax('replace', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'trans') {
      let elements = (element as Extended.List).elements;
      return Maker.makeTrans(
        locationToSyntax('trans', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'cong') {
      let elements = (element as Extended.List).elements;
      return Maker.makeCong(
        locationToSyntax('cong', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'ind-=') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndEqual(
        locationToSyntax('ind-=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'symm') {
      return Maker.makeSymm(
        locationToSyntax('symm', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'Vec') {
      let elements = (element as Extended.List).elements;
      return Maker.makeVec(
        locationToSyntax('Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'vecnil') {
      return Maker.makeVecNil(
        locationToSyntax('vecnil', element.location),
      );
    } else if (parsee === 'vec::') {
      let elements = (element as Extended.List).elements;
      return Maker.makeVecCons(
        locationToSyntax('vec::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'head') {
      return Maker.makeHead(
        locationToSyntax('head', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'tail') {
      return Maker.makeTail(
        locationToSyntax('tail', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Vec') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndVec(
        locationToSyntax('ind-Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
        this.parseElements(elements[5] as Element),
      );
    } else if (parsee === 'Either') {
      let elements = (element as Extended.List).elements;
      return Maker.makeEither(
        locationToSyntax('Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'left') {
      return Maker.makeLeft(
        locationToSyntax('left', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    }
    else if (parsee === 'right') {
      return Maker.makeRight(
        locationToSyntax('right', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Either') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndEither(
        locationToSyntax('ind-Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Absurd') {
      return Maker.makeAbsurd(
        locationToSyntax('Absurd', element.location),
      );
    } else if (parsee === 'ind-Absurd') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndAbsurd(
        locationToSyntax('ind-Absurd', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'TODO') {
      return Maker.makeTODO(locationToSyntax('TODO', element.location));
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length > 1) {
      let elements = (element as Extended.List).elements;
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (isVarName(parsee)) {
      return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
    } else if (!isNaN(Number(parsee))) { // numeric literal
      return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
    }
    throw new Error('Unexpected element: ' + element);
  }

  public static parseToTactics(element: Element): Tactic {
    const parsee = getValue(element);
    if (parsee === 'exact') {
      return Maker.makeExact(
        locationToSyntax('exact', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'intro') {
      return Maker.makeIntro(
        locationToSyntax('intro', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'exists') {
      return Maker.makeExists(
        locationToSyntax('exists', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
        ((element as Extended.List).elements[2] as Atomic.Symbol).value
      );
    } else if (parsee === 'elimNat') {
      return Maker.makeElimNat(
        locationToSyntax('elimNat', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element)
      );
    } else if (parsee === 'elimList') {
      return Maker.makeElimList(
        locationToSyntax('elimList', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element)
      );
    } else if (parsee === 'elimVec') {
      return Maker.makeElimVec(
        locationToSyntax('elimVec', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element),
        this.parseElements((element as Extended.List).elements[3] as Element))
    } else if (parsee === 'elimEqual') {
      return Maker.makeElimEqual(
        locationToSyntax('elimEqual', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element));
    } else if (parsee === 'left') {
      return Maker.makeLeftTactic(
        locationToSyntax('left', element.location)
      );
    } else if (parsee === 'right') {
      return Maker.makeRightTactic(
        locationToSyntax('right', element.location)
      );
    } else if (parsee === 'elimEither') {
      return Maker.makeElimEither(
        locationToSyntax('elimEither', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element)
      );
    } else if (parsee === 'split') {
      return Maker.makeSplit(
        locationToSyntax('split', element.location)
      );
    } else if (parsee === 'elimAbsurd') {
      return Maker.makeElimAbsurd(
        locationToSyntax('elimAbsurd', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element)
      );
    } 
    throw new Error('Unexpected tactic: ' + element);
}
}



// ### Helper functions for parsing the AST

export class Claim {
  constructor (
    public location: Location,
    public name: string,
    public type: S.Source
  ) {}
}

export class Definition {
  constructor (
    public location: Location,
    public name: string,
    public expr: S.Source
  ) {}
}

export class SamenessCheck {
  constructor (
    public location: Location,
    public type: S.Source,
    public left: S.Source,
    public right: S.Source
  ) {}
}

export class DefineTactically {
  constructor (
    public location: Location,
    public name: string,
    public tactics: Tactic[]
  ) {}
}



export type Declaration = Claim | Definition | SamenessCheck | DefineTactically|S.Source;


export class pieDeclarationParser {
  public static parseDeclaration(ast: Extended.List): Declaration {
    const parsee = getValue(ast);
    if (parsee === 'claim') {
      let elements = (ast as Extended.List).elements;
      return new Claim(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'define') {
      let elements = (ast as Extended.List).elements;
      return new Definition(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'check-same') {
      let elements = (ast as Extended.List).elements;
      return new SamenessCheck(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        Parser.parseElements(elements[1] as Element),
        Parser.parseElements(elements[2] as Element),
        Parser.parseElements(elements[3] as Element)
      );
    } else if (parsee === 'define-tactically') {
      let elements = (ast as Extended.List).elements;
      return new DefineTactically(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        (elements[2] as Extended.List).elements.map((x: Expression) => Parser.parseToTactics(x as Element))
      );
    } else {
      return Parser.parseElements(ast);
    }
  }
}