{"version":3,"file":"index.js","sources":["../node_modules/tslib/tslib.es6.js","../node_modules/conductor/src/common/errors/ConductorError.ts","../node_modules/conductor/src/common/errors/ConductorInternalError.ts","../node_modules/conductor/src/common/errors/EvaluatorTypeError.ts","../node_modules/conductor/src/common/errors/EvaluatorError.ts","../node_modules/conductor/src/conductor/runner/BasicEvaluator.ts","../node_modules/conductor/src/common/util/importExternalPlugin.ts","../node_modules/conductor/src/common/util/importExternalModule.ts","../node_modules/conductor/src/common/util/InvalidModuleError.ts","../node_modules/conductor/src/conduit/Channel.ts","../node_modules/conductor/src/conductor/types/moduleInterface/DataType.ts","../node_modules/conductor/src/common/ds/Queue.ts","../node_modules/conductor/src/common/ds/MessageQueue.ts","../node_modules/conductor/src/conduit/ChannelQueue.ts","../node_modules/conductor/src/conduit/Conduit.ts","../node_modules/conductor/src/conduit/rpc/types/RpcCallMessage.ts","../node_modules/conductor/src/conduit/rpc/types/RpcErrorMessage.ts","../node_modules/conductor/src/conduit/rpc/types/RpcReturnMessage.ts","../node_modules/conductor/src/conduit/util/checkIsPluginClass.ts","../node_modules/conductor/src/conductor/types/serviceMessages/AbortServiceMessage.ts","../src/scheme_parser/core-math.ts","../node_modules/conductor/src/conductor/types/serviceMessages/HelloServiceMessage.ts","../node_modules/conductor/src/conductor/types/serviceMessages/PluginServiceMessage.ts","../node_modules/conductor/src/conductor/runner/RunnerPlugin.ts","../node_modules/conductor/src/conduit/rpc/makeRpc.ts","../src/scheme_parser/transpiler/types/location.ts","../src/scheme_parser/transpiler/types/tokens/token-type.ts","../src/scheme_parser/transpiler/parser/parser-error.ts","../src/scheme_parser/transpiler/types/tokens/group.ts","../src/scheme_parser/transpiler/types/tokens/index.ts","../src/scheme_parser/transpiler/types/tokens/token.ts","../src/scheme_parser/transpiler/types/nodes/scheme-node-types.ts","../src/scheme_parser/transpiler/lexer/lexer-error.ts","../src/scheme_parser/transpiler/lexer/scheme-lexer.ts","../src/scheme_parser/transpiler/types/constants.ts","../src/scheme_parser/transpiler/parser/scheme-parser.ts","../src/pie_interpreter/utils/locations.ts","../src/pie_interpreter/utils/fresh.ts","../src/pie_interpreter/types/utils.ts","../src/pie_interpreter/utils/environment.ts","../src/pie_interpreter/types/neutral.ts","../src/pie_interpreter/evaluator/evaluator.ts","../src/pie_interpreter/evaluator/utils.ts","../src/pie_interpreter/utils/context.ts","../src/pie_interpreter/types/value.ts","../src/pie_interpreter/types/core.ts","../src/pie_interpreter/utils/alphaeqv.ts","../src/pie_interpreter/typechecker/utils.ts","../src/pie_interpreter/typechecker/synthesizer.ts","../src/pie_interpreter/types/source.ts","../src/pie_interpreter/parser/parser.ts","../src/pie_interpreter/typechecker/represent.ts","../node_modules/conductor/src/conductor/runner/util/initialise.ts","../src/pie_interpreter/index.ts","../src/pie_interpreter/PieEvaluator.ts","../src/pie_interpreter/main.ts","../src/pie_interpreter/unparser/pretty.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","import { ErrorType } from \"./ErrorType\";\n\n/**\n * Generic Conductor Error.\n */\nexport class ConductorError extends Error {\n    override name = \"ConductorError\";\n    readonly errorType: ErrorType | string = ErrorType.UNKNOWN;\n    \n    constructor(message: string) {\n        super(message);\n    }\n}\n","import { ConductorError } from \"./ConductorError\";\nimport { ErrorType } from \"./ErrorType\";\n\n/**\n * Conductor internal error, probably caused by developer oversight.\n */\nexport class ConductorInternalError extends ConductorError {\n    override name = \"ConductorInternalError\";\n    override readonly errorType: ErrorType | string = ErrorType.INTERNAL;\n    \n    constructor(message: string) {\n        super(message);\n    }\n}\n","import { ConductorError } from \"./ConductorError\";\nimport { ErrorType } from \"./ErrorType\";\nimport { EvaluatorError } from \"./EvaluatorError\";\n\n/**\n * Evaluator type error - the user code is not well typed or provides values of incorrect type to external functions.\n */\nexport class EvaluatorTypeError extends EvaluatorError {\n    override name = \"EvaluatorTypeError\";\n    override readonly errorType: ErrorType | string = ErrorType.EVALUATOR_TYPE;\n\n    override readonly rawMessage: string;\n    readonly expected: string;\n    readonly actual: string;\n\n    constructor(message: string, expected: string, actual: string, line?: number, column?: number, fileName?: string) {\n        super(`${message} (expected ${expected}, got ${actual})`, line, column, fileName);\n        this.rawMessage = message;\n        this.expected = expected;\n        this.actual = actual;\n    }\n}\n","import { ConductorError } from \"./ConductorError\";\nimport { ErrorType } from \"./ErrorType\";\n\n/**\n * Generic evaluation error, caused by a problem in user code.\n */\nexport class EvaluatorError extends ConductorError {\n    override name = \"EvaluatorError\";\n    override readonly errorType: ErrorType | string = ErrorType.EVALUATOR;\n\n    readonly rawMessage: string;\n    readonly line?: number;\n    readonly column?: number;\n    readonly fileName?: string\n\n    constructor(message: string, line?: number, column?: number, fileName?: string) {\n        const location = line !== undefined\n            ? `${fileName ? fileName + \":\" : \"\"}${line}${column !== undefined ? \":\" + column : \"\"}: `\n            : \"\";\n        super(`${location}${message}`);\n        this.rawMessage = message;\n        this.line = line;\n        this.column = column;\n        this.fileName = fileName\n    }\n}\n","import { ConductorInternalError } from \"../../common/errors\";\nimport { IEvaluator, IRunnerPlugin } from \"./types\";\n\nexport abstract class BasicEvaluator implements IEvaluator {\n    readonly conductor: IRunnerPlugin;\n\n    async startEvaluator(entryPoint: string): Promise<void> {\n        const initialChunk = await this.conductor.requestFile(entryPoint);\n        if (!initialChunk) throw new ConductorInternalError(\"Cannot load entrypoint file\");\n        await this.evaluateFile(entryPoint, initialChunk);\n        while (true) {\n            const chunk = await this.conductor.requestChunk();\n            await this.evaluateChunk(chunk);\n        }\n    }\n\n    /**\n     * Evaluates a file.\n     * @param fileName The name of the file to be evaluated.\n     * @param fileContent The content of the file to be evaluated.\n     * @returns A promise that resolves when the evaluation is complete.\n     */\n    async evaluateFile(fileName: string, fileContent: string): Promise<void> {\n        return this.evaluateChunk(fileContent);\n    }\n\n    /**\n     * Evaluates a chunk.\n     * @param chunk The chunk to be evaluated.\n     * @returns A promise that resolves when the evaluation is complete.\n     */\n    abstract evaluateChunk(chunk: string): Promise<void>;\n\n    constructor(conductor: IRunnerPlugin) {\n        this.conductor = conductor;\n    }\n}\n","import { PluginClass } from \"../../conduit/types\";\n\n/**\n * Imports an external plugin from a given location.\n * @param location Where to find the external plugin.\n * @returns A promise resolving to the imported plugin.\n */\nexport async function importExternalPlugin(location: string): Promise<PluginClass> {\n    const plugin = (await import(/* webpackIgnore: true */ location)).plugin as PluginClass;\n    // TODO: verify it is actually a plugin\n    return plugin;\n}\n","import type { IModulePlugin } from \"../../conductor/module\";\nimport { PluginClass } from \"../../conduit/types\";\nimport { importExternalPlugin } from \"./importExternalPlugin\";\n\n/**\n * Imports an external module from a given location.\n * @param location Where to find the external module.\n * @returns A promise resolving to the imported module.\n */\nexport async function importExternalModule(location: string): Promise<PluginClass<any, IModulePlugin>> {\n    const plugin = await importExternalPlugin(location) as PluginClass<any, IModulePlugin>;\n    // TODO: additional verification it is a module\n    return plugin;\n}\n","import { ConductorError } from \"../errors\";\n\nexport class InvalidModuleError extends ConductorError {\n    override name = \"InvalidModuleError\";\n    override readonly errorType = \"__invalidmodule\";\n\n    constructor() {\n        super(\"Not a module\");\n    }\n}\n","import { ConductorInternalError } from \"../common/errors/ConductorInternalError\";\nimport { IChannel, Subscriber } from \"./types\";\n\nexport class Channel<T> implements IChannel<T> {\n    readonly name: string;\n\n    /** The underlying MessagePort of this Channel. */\n    private __port!: MessagePort; // replacePort assigns this in the constructor\n\n    /** The callbacks subscribed to this Channel. */\n    private readonly __subscribers: Set<Subscriber<T>> = new Set(); // TODO: use WeakRef? but callbacks tend to be thrown away and leaking is better than incorrect behaviour\n\n    /** Is the Channel allowed to be used? */\n    private __isAlive: boolean = true;\n\n    private __waitingMessages?: T[] = [];\n\n    send(message: T, transfer?: Transferable[]): void {\n        this.__verifyAlive();\n        this.__port.postMessage(message, transfer ?? []);\n    }\n    subscribe(subscriber: Subscriber<T>): void {\n        this.__verifyAlive();\n        this.__subscribers.add(subscriber);\n        if (this.__waitingMessages) {\n            for (const data of this.__waitingMessages) {\n                subscriber(data);\n            }\n            delete this.__waitingMessages;\n        }\n    }\n    unsubscribe(subscriber: Subscriber<T>): void {\n        this.__verifyAlive();\n        this.__subscribers.delete(subscriber);\n    }\n    close(): void {\n        this.__verifyAlive();\n        this.__isAlive = false;\n        this.__port?.close();\n    }\n\n    /**\n     * Check if this Channel is allowed to be used.\n     * @throws Throws an error if the Channel has been closed.\n     */\n    private __verifyAlive() {\n        if (!this.__isAlive) throw new ConductorInternalError(`Channel ${this.name} has been closed`);\n    }\n\n    /**\n     * Dispatch some data to subscribers.\n     * @param data The data to be dispatched to subscribers.\n     */\n    private __dispatch(data: T): void {\n        this.__verifyAlive();\n        if (this.__waitingMessages) {\n            this.__waitingMessages.push(data);\n        } else {\n            for (const subscriber of this.__subscribers) {\n                subscriber(data);\n            }\n        }\n    }\n\n    /**\n     * Listens to the port's message event, and starts the port.\n     * Messages will be buffered until the first subscriber listens to the Channel.\n     * @param port The MessagePort to listen to.\n     */\n    listenToPort(port: MessagePort): void {\n        port.addEventListener(\"message\", e => this.__dispatch(e.data));\n        port.start();\n    }\n\n    /**\n     * Replaces the underlying MessagePort of this Channel and closes it, and starts the new port.\n     * @param port The new port to use.\n     */\n    replacePort(port: MessagePort): void {\n        this.__verifyAlive();\n        this.__port?.close();\n        this.__port = port;\n        this.listenToPort(port);\n    }\n\n    constructor(name: string, port: MessagePort) {\n        this.name = name;\n        this.replacePort(port);\n    }\n}\n","export enum DataType {\n    /** The return type of functions with no returned value. As a convention, the associated JS value is undefined. */\n    VOID = 0,\n\n    /** A Boolean value. */\n    BOOLEAN = 1,\n\n    /** A numerical value. */\n    NUMBER = 2,\n\n    /** An immutable string of characters. */\n    CONST_STRING = 3,\n\n    /** The empty list. As a convention, the associated JS value is null. */\n    EMPTY_LIST = 4,\n\n    /** A pair of values. Reference type. */\n    PAIR = 5,\n\n    /** An array of values of a single type. Reference type. */\n    ARRAY = 6,\n\n    /** A value that can be called with fixed arity. Reference type. */\n    CLOSURE = 7,\n\n    /** An opaque value that cannot be manipulated from user code. */\n    OPAQUE = 8,\n\n    /** A list (either a pair or the empty list). */\n    LIST = 9,\n};\n","/**\n * A stack-based queue implementation.\n * `push` and `pop` run in amortized constant time.\n */\nexport class Queue<T> {\n    /** The output stack. */\n    private __s1: T[] = [];\n    /** The input stack. */\n    private __s2: T[] = [];\n\n    /**\n     * Adds an item to the queue.\n     * @param item The item to be added to the queue.\n     */\n    push(item: T) {\n        this.__s2.push(item);\n    }\n\n    /**\n     * Removes an item from the queue.\n     * @returns The item removed from the queue.\n     * @throws If the queue is empty.\n     */\n    pop(): T {\n        if (this.__s1.length === 0) {\n            if (this.__s2.length === 0) throw new Error(\"queue is empty\");\n            let temp = this.__s1;\n            this.__s1 = this.__s2.reverse();\n            this.__s2 = temp;\n        }\n        return this.__s1.pop()!; // as the length is nonzero\n    }\n\n    /**\n     * The length of the queue.\n     */\n    get length() {\n        return this.__s1.length + this.__s2.length;\n    }\n\n    /**\n     * Makes a copy of the queue.\n     * @returns A copy of the queue.\n     */\n    clone(): Queue<T> {\n        const newQueue = new Queue<T>();\n        newQueue.__s1 = [...this.__s1];\n        newQueue.__s2 = [...this.__s2];\n        return newQueue;\n    }\n}\n","import { Queue } from \"./Queue\";\n\nexport class MessageQueue<T> {\n    private readonly __inputQueue: Queue<T> = new Queue();\n    private readonly __promiseQueue: Queue<Function> = new Queue();\n\n    push(item: T) {\n        if (this.__promiseQueue.length !== 0) this.__promiseQueue.pop()(item);\n        else this.__inputQueue.push(item);\n    }\n\n    async pop(): Promise<T> {\n        if (this.__inputQueue.length !== 0) return this.__inputQueue.pop();\n        return new Promise((resolve, _reject) => {\n            this.__promiseQueue.push(resolve);\n        });\n    }\n\n    tryPop(): T | undefined {\n        if (this.__inputQueue.length !== 0) return this.__inputQueue.pop();\n        return undefined;\n    }\n\n    constructor() {\n        this.push = this.push.bind(this);\n    }\n}\n","import { MessageQueue } from \"../common/ds\";\nimport { IChannelQueue, IChannel } from \"./types\";\n\nexport class ChannelQueue<T> implements IChannelQueue<T> {\n    readonly name: string;\n    private __channel: IChannel<T>;\n    private __messageQueue: MessageQueue<T> = new MessageQueue();\n\n    async receive(): Promise<T> {\n        return this.__messageQueue.pop();\n    }\n    tryReceive(): T | undefined {\n        return this.__messageQueue.tryPop();\n    }\n    send(message: T, transfer?: Transferable[]): void {\n        this.__channel.send(message, transfer);\n    }\n    close(): void {\n        this.__channel.unsubscribe(this.__messageQueue.push);\n    }\n    constructor(channel: IChannel<T>) {\n        this.name = channel.name;\n        this.__channel = channel;\n        this.__channel.subscribe(this.__messageQueue.push);\n    }\n}\n","import { ConductorInternalError } from \"../common/errors/ConductorInternalError\";\nimport { Channel } from \"./Channel\";\nimport { IConduit, ILink, IPlugin, IChannel, PluginClass } from \"./types\";\n\nexport class Conduit implements IConduit {\n    private __alive: boolean = true;\n    private readonly __link: ILink;\n    private readonly __parent: boolean;\n    private readonly __channels: Map<string, Channel<any>> = new Map();\n    private readonly __pluginMap: Map<string, IPlugin> = new Map();\n    private readonly __plugins: IPlugin[] = [];\n    private __negotiateChannel(channelName: string): void {\n        const { port1, port2 } = new MessageChannel();\n        const channel = new Channel(channelName, port1);\n        this.__link.postMessage([channelName, port2], [port2]); // TODO: update communication protocol?\n        this.__channels.set(channelName, channel);\n    }\n    private __verifyAlive() {\n        if (!this.__alive) throw new ConductorInternalError(\"Conduit already terminated\");\n    }\n    registerPlugin<Arg extends any[], T extends IPlugin>(pluginClass: PluginClass<Arg, T>, ...arg: Arg): NoInfer<T> {\n        this.__verifyAlive();\n        const attachedChannels: IChannel<any>[] = [];\n        for (const channelName of pluginClass.channelAttach) {\n            if (!this.__channels.has(channelName)) this.__negotiateChannel(channelName);\n            attachedChannels.push(this.__channels.get(channelName)!); // as the Channel has been negotiated\n        }\n        const plugin = new pluginClass(this, attachedChannels, ...arg);\n\n        if (plugin.name !== undefined) {\n            if (this.__pluginMap.has(plugin.name)) throw new ConductorInternalError(`Plugin ${plugin.name} already registered`);\n            this.__pluginMap.set(plugin.name, plugin);\n        }\n\n        this.__plugins.push(plugin);\n\n        return plugin;\n    }\n    unregisterPlugin(plugin: IPlugin): void {\n        this.__verifyAlive();\n        let p = 0;\n        for (let i = 0; i < this.__plugins.length; ++i) {\n            if (this.__plugins[p] === plugin) ++p;\n            this.__plugins[i] = this.__plugins[i + p];\n        }\n        for (let i = this.__plugins.length - 1, e = this.__plugins.length - p; i >= e; --i) {\n            delete this.__plugins[i];\n        }\n        if (plugin.name) {\n            this.__pluginMap.delete(plugin.name);\n        }\n        plugin.destroy?.();\n    }\n    lookupPlugin(pluginName: string): IPlugin {\n        this.__verifyAlive();\n        if (!this.__pluginMap.has(pluginName)) throw new ConductorInternalError(`Plugin ${pluginName} not registered`);\n        return this.__pluginMap.get(pluginName)!; // as the map has been checked\n    }\n    terminate(): void {\n        this.__verifyAlive();\n        for (const plugin of this.__plugins) {\n            //this.unregisterPlugin(plugin);\n            plugin.destroy?.();\n        }\n        this.__link.terminate?.();\n        this.__alive = false;\n    }\n    private __handlePort(data: [string, MessagePort]) { // TODO: update communication protocol?\n        const [channelName, port] = data;\n        if (this.__channels.has(channelName)) { // uh-oh, we already have a port for this channel\n            const channel = this.__channels.get(channelName)!; // as the map has been checked\n            if (this.__parent) { // extract the data and discard the messageport; child's Channel will close it\n                channel.listenToPort(port);\n            } else { // replace our messageport; Channel will close it\n                channel.replacePort(port);\n            }\n        } else { // register the new channel\n            const channel = new Channel(channelName, port);\n            this.__channels.set(channelName, channel);\n        }\n    }\n    constructor(link: ILink, parent: boolean = false) {\n        this.__link = link;\n        link.addEventListener(\"message\", e => this.__handlePort(e.data));\n        this.__parent = parent;\n    }\n}\n","import type { IRpcMessage } from \"./IRpcMessage\";\nimport { RpcMessageType } from \"./RpcMessageType\";\n\nexport class RpcCallMessage implements IRpcMessage {\n    type = RpcMessageType.CALL;\n    readonly data: {fn: string | symbol, args: any[], invokeId: number};\n\n    constructor(fn: string | symbol, args: any[], invokeId: number) {\n        this.data = {fn, args, invokeId};\n    }\n}\n","import type { IRpcMessage } from \"./IRpcMessage\";\nimport { RpcMessageType } from \"./RpcMessageType\";\n\nexport class RpcErrorMessage implements IRpcMessage {\n    type = RpcMessageType.RETURN_ERR;\n    readonly data: {invokeId: number, err: any};\n\n    constructor(invokeId: number, err: any) {\n        this.data = {invokeId, err};\n    }\n}\n","import type { IRpcMessage } from \"./IRpcMessage\";\nimport { RpcMessageType } from \"./RpcMessageType\";\n\nexport class RpcReturnMessage implements IRpcMessage {\n    type = RpcMessageType.RETURN;\n    readonly data: {invokeId: number, res: any};\n\n    constructor(invokeId: number, res: any) {\n        this.data = {invokeId, res};\n    }\n}\n","import { IPlugin } from \"..\";\nimport { AbstractPluginClass, PluginClass } from \"../types\";\n\n/**\n * Typechecking utility decorator.\n * It is recommended that usage of this decorator is removed\n * before or during the build process, as some tools\n * (e.g. terser) do not have good support for class decorators.\n * @param _pluginClass The Class to be typechecked.\n */\nexport function checkIsPluginClass<Arg extends any[] = [], T = IPlugin>(_pluginClass: PluginClass<Arg, T> | AbstractPluginClass<Arg, T>) {\n}\n","import type { IServiceMessage } from \"../IServiceMessage\";\nimport { ServiceMessageType } from \"../ServiceMessageType\";\n\nexport class AbortServiceMessage implements IServiceMessage {\n    readonly type = ServiceMessageType.ABORT;\n    readonly data: {minVersion: number};\n    constructor(minVersion: number) {\n        this.data = {minVersion: minVersion};\n    }\n}\n","// The core library of scm-slang,\n// different from the base library,\n// this library contains all methods required\n// for the language to function properly.\n\n// This file contains the minimum subset\n// required for arithmetic to work.\n// which includes the numeric tower,\n// as well as the regex forms used to detect numbers.\n\nexport type SchemeNumber =\n  | SchemeInteger\n  | SchemeRational\n  | SchemeReal\n  | SchemeComplex;\n\n// define here the functions used to check and split the number into its parts\n\nexport enum NumberType {\n  INTEGER = 1,\n  RATIONAL = 2,\n  REAL = 3,\n  COMPLEX = 4,\n}\n\nexport abstract class Match {\n  constructor(public result: boolean) {}\n  abstract build(): SchemeNumber;\n}\n\nclass IntegerMatch extends Match {\n  constructor(\n    public result: boolean,\n    public value?: string\n  ) {\n    super(result);\n  }\n\n  isSigned(): boolean {\n    return this.result\n      ? this.value![0] === \"+\" || this.value![0] === \"-\"\n      : false;\n  }\n\n  build(): SchemeInteger {\n    return SchemeInteger.build(this.value!);\n  }\n}\n\nclass RationalMatch extends Match {\n  constructor(\n    public result: boolean,\n    public numerator?: string,\n    public denominator?: string\n  ) {\n    super(result);\n  }\n\n  build(): SchemeInteger | SchemeRational {\n    return SchemeRational.build(this.numerator!, this.denominator!);\n  }\n}\n\nclass RealMatch extends Match {\n  constructor(\n    public result: boolean,\n    public integer?: string,\n    public decimal?: string,\n    public exponent?: Match\n  ) {\n    super(result);\n  }\n\n  build(): SchemeReal {\n    if (this.integer?.includes(\"inf\")) {\n      return this.integer!.includes(\"-\")\n        ? SchemeReal.NEG_INFINITY\n        : SchemeReal.INFINITY;\n    }\n\n    if (this.integer?.includes(\"nan\")) {\n      return SchemeReal.NAN;\n    }\n\n    // recursively build the exponent\n    let exponent = (\n      this.exponent ? this.exponent.build() : SchemeReal.INEXACT_ZERO\n    ).coerce();\n\n    // we are assured that either part exists\n    let value = Number(\n      (this.integer ? this.integer : \"0\") +\n        \".\" +\n        (this.decimal ? this.decimal : \"0\")\n    );\n\n    // apply the exponent\n    value *= Math.pow(10, exponent);\n\n    return SchemeReal.build(value);\n  }\n}\n\nclass ComplexMatch extends Match {\n  constructor(\n    public result: boolean,\n    public real?: Match,\n    public sign?: string,\n    public imaginary?: Match\n  ) {\n    super(result);\n  }\n  build(): SchemeNumber {\n    const real = this.real\n      ? (this.real.build() as SchemeInteger | SchemeRational | SchemeReal)\n      : SchemeInteger.EXACT_ZERO;\n    const imaginary = this.imaginary!.build() as\n      | SchemeInteger\n      | SchemeRational\n      | SchemeReal;\n\n    if (this.sign && this.sign === \"-\") {\n      return SchemeComplex.build(real, imaginary.negate());\n    }\n\n    return SchemeComplex.build(real, imaginary);\n  }\n}\n\n// these are used to determine the type of the number and to separate it into its parts as well\nexport function isInteger(value: string): IntegerMatch {\n  // <integer> = [+-]?<digit>+\n  // check if the value is an integer. if it is, return true and the value.\n  // if not, return false and an empty array.\n  const integerRegex = new RegExp(`^([+-]?)(\\\\d+)$`);\n  const match = integerRegex.exec(value);\n  if (match) {\n    return new IntegerMatch(true, match[0]);\n  }\n  return new IntegerMatch(false);\n}\n\nexport function isRational(value: string): RationalMatch {\n  // <rational> = <integer>/<integer>\n  // both sides of the rational should parse as integers\n  // we can split the rational into two parts and check if both are integers\n  // make sure there is a /\n  const count = (value.match(/\\//g) || []).length;\n  if (count !== 1) {\n    return new RationalMatch(false);\n  }\n  const parts = value.split(\"/\");\n  if (parts.length !== 2) {\n    return new RationalMatch(false);\n  }\n  const [numerator, denominator] = parts;\n  const numeratorMatch = isInteger(numerator);\n  const denominatorMatch = isInteger(denominator);\n\n  if (!(numeratorMatch.result && denominatorMatch.result)) {\n    return new RationalMatch(false);\n  }\n\n  return new RationalMatch(true, numerator, denominator);\n}\n\nexport function isReal(value: string): RealMatch {\n  // <real> = <basic> | <extended>\n  // <basic>: [+-]?a.b | [+-]?a | [+-]?.b | [+-]?a.\n  // <extended>: <basic>[eE]<integer | rational | real>\n  // where a = <digit>+ | inf | nan\n  //       b = <digit>+\n  //\n  // keep in mind that the value matches an integer too! but\n  // by the point of time this is called, we have already checked for an integer\n  function checkBasicReal(value: string): RealMatch {\n    // checks if the value is one of the 4 forms of special numbers\n    function isSpecialNumber(value: string): boolean {\n      return (\n        value === \"+inf.0\" ||\n        value === \"-inf.0\" ||\n        value === \"+nan.0\" ||\n        value === \"-nan.0\"\n      );\n    }\n\n    // check if the value is a special number\n    if (isSpecialNumber(value)) {\n      return new RealMatch(true, value);\n    }\n\n    // check for the presence of a dot\n    const count = (value.match(/\\./g) || []).length;\n    if (count > 1) {\n      return new RealMatch(false);\n    }\n\n    if (count === 0) {\n      const result = isInteger(value);\n      return new RealMatch(result.result, result.value);\n    }\n\n    // check for a basic real number\n    const [integerPart, decimalPart] = value.split(\".\");\n    const integerMatch = isInteger(integerPart);\n    const decimalMatch = isInteger(decimalPart);\n\n    const properInteger = integerMatch.result || integerPart === \"\";\n    const properDecimal = decimalMatch.result || decimalPart === \"\";\n\n    // if the integer part is just a sign, the decimal part should be non-empty\n    if (integerPart === \"+\" || integerPart === \"-\") {\n      if (decimalPart === \"\") {\n        return new RealMatch(false);\n      }\n      return new RealMatch(true, `${integerPart}0`, value);\n    }\n\n    // at least one of the parts should be non-empty\n    if (\n      !(\n        (integerMatch.result && properDecimal) ||\n        (properInteger && decimalMatch.result)\n      )\n    ) {\n      return new RealMatch(false);\n    }\n\n    // if there is a decimal match, there should have no sign\n    if (decimalMatch.result && decimalMatch.isSigned()) {\n      return new RealMatch(false);\n    }\n\n    return new RealMatch(true, integerMatch.value, decimalMatch.value);\n  }\n\n  function checkExtendedReal(value: string): RealMatch {\n    // split the value into two parts by e/E\n    const first_e_index = value.indexOf(\"e\");\n    const first_E_index = value.indexOf(\"E\");\n    if (first_e_index === -1 && first_E_index === -1) {\n      return new RealMatch(false);\n    }\n\n    const exponentIndex = first_e_index === -1 ? first_E_index : first_e_index;\n\n    const basicRealPart = value.substring(0, exponentIndex);\n    const exponentPart = value.substring(exponentIndex + 1);\n\n    // both should not be empty\n    if (basicRealPart === \"\" || exponentPart == \"\") {\n      return new RealMatch(false);\n    }\n\n    // parse each part\n    const basicRealMatch = checkBasicReal(basicRealPart);\n\n    if (!basicRealMatch.result) {\n      return new RealMatch(false);\n    }\n\n    // match the exponent part across types up to real\n    const exponentMatch = universalMatch(exponentPart, NumberType.REAL);\n    if (!exponentMatch.result) {\n      return new RealMatch(false);\n    }\n\n    return new RealMatch(\n      true,\n      basicRealMatch.integer,\n      basicRealMatch.decimal,\n      exponentMatch\n    );\n  }\n\n  // check for the presence of e/E\n  const count = (value.match(/[eE]/g) || []).length;\n\n  if (count === 0) {\n    // check for a basic real number\n    return checkBasicReal(value);\n  }\n\n  // check for an extended real number\n  return checkExtendedReal(value);\n}\n\nexport function isComplex(value: string): ComplexMatch {\n  // <basic-num> = <integer> | <rational> | <real>\n  // <complex> = <basic-num>[+-]<basic-num>i\n  // check if the value is a complex number. if it is, return true and the value.\n  // if not, return a failed match.\n  const count = (value.match(/i/g) || []).length;\n  if (count < 1) {\n    return new ComplexMatch(false);\n  }\n\n  if (value[value.length - 1] !== \"i\") {\n    return new ComplexMatch(false);\n  }\n\n  // find the first + or - that is not at the start of the string\n  // this is the split point\n  const splitPoint = value.search(/(?<!^)[+-]/);\n\n  // if no such point was found,\n  if (splitPoint === -1) {\n    // the value may be purely imaginary\n\n    let imaginaryPart = value.slice(0, -1);\n\n    const imaginaryMatch = universalMatch(imaginaryPart, NumberType.REAL);\n\n    if (imaginaryMatch.result) {\n      return new ComplexMatch(true, undefined, undefined, imaginaryMatch);\n    }\n\n    return new ComplexMatch(false);\n  }\n\n  const realPart = value.slice(0, splitPoint);\n  let imaginaryPart = value.slice(splitPoint + 1, -1);\n\n  // if imaginaryPart doesn't start with a sign, add one\n  // this lets us properly parse expressions such as 1+inf.0i\n  // even if the + belongs to the complex number\n  if (imaginaryPart[0] !== \"+\" && imaginaryPart[0] !== \"-\") {\n    imaginaryPart = \"+\" + imaginaryPart;\n  }\n  const realMatch = universalMatch(realPart, NumberType.REAL);\n  const imaginaryMatch = universalMatch(imaginaryPart, NumberType.REAL);\n\n  if (!(realMatch.result && imaginaryMatch.result)) {\n    return new ComplexMatch(false);\n  }\n\n  return new ComplexMatch(true, realMatch, value[splitPoint], imaginaryMatch);\n}\n\n// tests the value across all possible types\n// only limited by the finalWillingType of\nfunction universalMatch(value: string, finalWillingType: NumberType): Match {\n  const integerMatch = isInteger(value);\n  if (integerMatch.result && finalWillingType >= NumberType.INTEGER) {\n    return integerMatch;\n  }\n  const rationalMatch = isRational(value);\n  if (rationalMatch.result && finalWillingType >= NumberType.RATIONAL) {\n    return rationalMatch;\n  }\n  const realMatch = isReal(value);\n  if (realMatch.result && finalWillingType >= NumberType.REAL) {\n    return realMatch;\n  }\n  const complexMatch = isComplex(value);\n  if (complexMatch.result && finalWillingType >= NumberType.COMPLEX) {\n    return complexMatch;\n  }\n  return new IntegerMatch(false) as Match;\n}\n\n// for the lexer.\nexport function stringIsSchemeNumber(value: string): boolean {\n  const match = universalMatch(value, NumberType.COMPLEX);\n  return match.result;\n}\n\n// Each class has a numberType property that is used to determine the type of the number.\n// If another instance's numbertype is higher in an operation, it will \"promote\" itself to the higher type.\n\n// Each class also has a convert method that converts the number back into a javascript number.\n// This is used when the number is used in a context where a javascript number is expected.\n// If used in contexts where the values are too extreme for a javascript number, it will throw an error.\n// This includes attempting to convert a complex number to a javascript number.\n\n// If a simplified rational number has a denominator of 1, it will convert to an integer.\n\n// We are assured that the string passed to this function is a valid number.\nexport let make_number = (value: string): SchemeNumber => {\n  const match = universalMatch(value, NumberType.COMPLEX);\n  if (!match.result) {\n    throw new Error(\"Invalid number\");\n  }\n  return match.build();\n};\n\nexport class SchemeInteger {\n  readonly numberType = NumberType.INTEGER;\n  private readonly value: bigint;\n  static readonly EXACT_ZERO = new SchemeInteger(0n);\n\n  private constructor(value: bigint) {\n    this.value = value;\n  }\n\n  // Factory method for creating a new SchemeInteger instance.\n  // Force prevents automatic downcasting to a lower type.\n  static build(\n    value: number | string | bigint,\n    _force: boolean = false\n  ): SchemeInteger {\n    const val = BigInt(value);\n    if (val === 0n) {\n      return SchemeInteger.EXACT_ZERO;\n    }\n    return new SchemeInteger(val);\n  }\n\n  promote(nType: NumberType): SchemeNumber {\n    switch (nType) {\n      case NumberType.INTEGER:\n        return this;\n      case NumberType.RATIONAL:\n        return SchemeRational.build(this.value, 1n, true);\n      case NumberType.REAL:\n        return SchemeReal.build(this.coerce(), true);\n      case NumberType.COMPLEX:\n        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);\n    }\n  }\n\n  equals(other: any): boolean {\n    return other instanceof SchemeInteger && this.value === other.value;\n  }\n\n  greaterThan(other: SchemeInteger): boolean {\n    return this.value > other.value;\n  }\n\n  negate(): SchemeInteger {\n    if (this === SchemeInteger.EXACT_ZERO) {\n      return this;\n    }\n    return SchemeInteger.build(-this.value);\n  }\n\n  multiplicativeInverse(): SchemeInteger | SchemeRational {\n    if (this === SchemeInteger.EXACT_ZERO) {\n      throw new Error(\"Division by zero\");\n    }\n    return SchemeRational.build(1n, this.value, false);\n  }\n\n  add(other: SchemeInteger): SchemeInteger {\n    return SchemeInteger.build(this.value + other.value);\n  }\n\n  multiply(other: SchemeInteger): SchemeInteger {\n    return SchemeInteger.build(this.value * other.value);\n  }\n\n  getBigInt(): bigint {\n    return this.value;\n  }\n\n  coerce(): number {\n    if (this.value > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n\n    if (this.value < Number.MIN_SAFE_INTEGER) {\n      return -Infinity;\n    }\n\n    return Number(this.value);\n  }\n\n  toString(): string {\n    return this.value.toString();\n  }\n}\n\nexport class SchemeRational {\n  readonly numberType = NumberType.RATIONAL;\n  private readonly numerator: bigint;\n  private readonly denominator: bigint;\n\n  private constructor(numerator: bigint, denominator: bigint) {\n    this.numerator = numerator;\n    this.denominator = denominator;\n  }\n\n  // Builds a rational number.\n  // Force prevents automatic downcasting to a lower type.\n  static build(\n    numerator: number | string | bigint,\n    denominator: number | string | bigint,\n    force: boolean = false\n  ): SchemeRational | SchemeInteger {\n    return SchemeRational.simplify(\n      BigInt(numerator),\n      BigInt(denominator),\n      force\n    );\n  }\n\n  private static simplify(\n    numerator: bigint,\n    denominator: bigint,\n    force: boolean = false\n  ): SchemeRational | SchemeInteger {\n    const gcd = (a: bigint, b: bigint): bigint => {\n      if (b === 0n) {\n        return a;\n      }\n      return gcd(b, a.valueOf() % b.valueOf());\n    };\n    const divisor = gcd(numerator, denominator);\n    const numeratorSign = numerator < 0n ? -1n : 1n;\n    const denominatorSign = denominator < 0n ? -1n : 1n;\n    // determine the sign of the result\n    const sign = numeratorSign * denominatorSign;\n    // remove the sign from the numerator and denominator\n    numerator = numerator * numeratorSign;\n    denominator = denominator * denominatorSign;\n    // if the denominator is 1, we can return an integer\n    if (denominator === 1n && !force) {\n      return SchemeInteger.build(sign * numerator);\n    }\n    return new SchemeRational(\n      (sign * numerator) / divisor,\n      denominator / divisor\n    );\n  }\n\n  getNumerator(): bigint {\n    return this.numerator;\n  }\n\n  getDenominator(): bigint {\n    return this.denominator;\n  }\n\n  promote(nType: NumberType): SchemeNumber {\n    switch (nType) {\n      case NumberType.RATIONAL:\n        return this;\n      case NumberType.REAL:\n        return SchemeReal.build(this.coerce(), true);\n      case NumberType.COMPLEX:\n        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);\n      default:\n        throw new Error(\"Unable to demote rational\");\n    }\n  }\n\n  equals(other: any): boolean {\n    return (\n      other instanceof SchemeRational &&\n      this.numerator === other.numerator &&\n      this.denominator === other.denominator\n    );\n  }\n\n  greaterThan(other: SchemeRational): boolean {\n    return (\n      this.numerator * other.denominator > other.numerator * this.denominator\n    );\n  }\n\n  negate(): SchemeRational {\n    return SchemeRational.build(\n      -this.numerator,\n      this.denominator\n    ) as SchemeRational;\n  }\n\n  multiplicativeInverse(): SchemeInteger | SchemeRational {\n    if (this.numerator === 0n) {\n      throw new Error(\"Division by zero\");\n    }\n    return SchemeRational.build(this.denominator, this.numerator);\n  }\n\n  add(other: SchemeRational): SchemeInteger | SchemeRational {\n    const newNumerator =\n      this.numerator * other.denominator + other.numerator * this.denominator;\n    const newDenominator = this.denominator * other.denominator;\n    return SchemeRational.build(newNumerator, newDenominator);\n  }\n\n  multiply(other: SchemeRational): SchemeInteger | SchemeRational {\n    const newNumerator = this.numerator * other.numerator;\n    const newDenominator = this.denominator * other.denominator;\n    return SchemeRational.build(newNumerator, newDenominator);\n  }\n\n  coerce(): number {\n    const workingNumerator =\n      this.numerator < 0n ? -this.numerator : this.numerator;\n    let converterDenominator = this.denominator;\n\n    // we can take the whole part directly\n    const wholePart = Number(workingNumerator / converterDenominator);\n\n    if (wholePart > Number.MAX_VALUE) {\n      return this.numerator < 0n ? -Infinity : Infinity;\n    }\n    // remainder should be lossily converted below safe levels\n    let remainder = workingNumerator % converterDenominator;\n\n    // we lossily convert both values below safe number thresholds\n    while (\n      remainder > Number.MAX_SAFE_INTEGER ||\n      converterDenominator > Number.MAX_SAFE_INTEGER\n    ) {\n      remainder = remainder / 2n;\n      converterDenominator = converterDenominator / 2n;\n    }\n\n    // coerce the now safe parts into a remainder number\n    const remainderPart = Number(remainder) / Number(converterDenominator);\n\n    return this.numerator < 0n\n      ? -(wholePart + remainderPart)\n      : wholePart + remainderPart;\n  }\n\n  toString(): string {\n    return `${this.numerator}/${this.denominator}`;\n  }\n}\n\n// it is allowable to represent the Real number using\n// float/double representation, and so we shall do that.\n// the current schemeReal implementation is fully based\n// on JavaScript numbers.\nexport class SchemeReal {\n  readonly numberType = NumberType.REAL;\n  private readonly value: number;\n\n  public static INEXACT_ZERO = new SchemeReal(0);\n  public static INEXACT_NEG_ZERO = new SchemeReal(-0);\n  public static INFINITY = new SchemeReal(Infinity);\n  public static NEG_INFINITY = new SchemeReal(-Infinity);\n  public static NAN = new SchemeReal(NaN);\n\n  static build(value: number, _force: boolean = false): SchemeReal {\n    if (value === Infinity) {\n      return SchemeReal.INFINITY;\n    } else if (value === -Infinity) {\n      return SchemeReal.NEG_INFINITY;\n    } else if (isNaN(value)) {\n      return SchemeReal.NAN;\n    } else if (value === 0) {\n      return SchemeReal.INEXACT_ZERO;\n    } else if (value === -0) {\n      return SchemeReal.INEXACT_NEG_ZERO;\n    }\n    return new SchemeReal(value);\n  }\n\n  private constructor(value: number) {\n    this.value = value;\n  }\n\n  promote(nType: NumberType): SchemeNumber {\n    switch (nType) {\n      case NumberType.REAL:\n        return this;\n      case NumberType.COMPLEX:\n        return SchemeComplex.build(this, SchemeInteger.EXACT_ZERO, true);\n      default:\n        throw new Error(\"Unable to demote real\");\n    }\n  }\n\n  equals(other: any): boolean {\n    return other instanceof SchemeReal && this.value === other.value;\n  }\n\n  greaterThan(other: SchemeReal): boolean {\n    return this.value > other.value;\n  }\n\n  negate(): SchemeReal {\n    return SchemeReal.build(-this.value);\n  }\n\n  multiplicativeInverse(): SchemeReal {\n    if (\n      this === SchemeReal.INEXACT_ZERO ||\n      this === SchemeReal.INEXACT_NEG_ZERO\n    ) {\n      throw new Error(\"Division by zero\");\n    }\n    return SchemeReal.build(1 / this.value);\n  }\n\n  add(other: SchemeReal): SchemeReal {\n    return SchemeReal.build(this.value + other.value);\n  }\n\n  multiply(other: SchemeReal): SchemeReal {\n    return SchemeReal.build(this.value * other.value);\n  }\n\n  coerce(): number {\n    return this.value;\n  }\n\n  toString(): string {\n    if (this === SchemeReal.INFINITY) {\n      return \"+inf.0\";\n    }\n    if (this === SchemeReal.NEG_INFINITY) {\n      return \"-inf.0\";\n    }\n    if (this === SchemeReal.NAN) {\n      return \"+nan.0\";\n    }\n    return this.value.toString();\n  }\n}\n\nexport class SchemeComplex {\n  readonly numberType = NumberType.COMPLEX;\n  private readonly real: SchemeInteger | SchemeRational | SchemeReal;\n  private readonly imaginary: SchemeInteger | SchemeRational | SchemeReal;\n\n  static build(\n    real: SchemeReal | SchemeRational | SchemeInteger,\n    imaginary: SchemeReal | SchemeRational | SchemeInteger,\n    force: boolean = false\n  ): SchemeNumber {\n    return SchemeComplex.simplify(new SchemeComplex(real, imaginary), force);\n  }\n\n  private constructor(\n    real: SchemeReal | SchemeRational | SchemeInteger,\n    imaginary: SchemeReal | SchemeRational | SchemeInteger\n  ) {\n    this.real = real;\n    this.imaginary = imaginary;\n  }\n\n  private static simplify(\n    complex: SchemeComplex,\n    force: boolean\n  ): SchemeNumber {\n    if (!force && atomic_equals(complex.imaginary, SchemeInteger.EXACT_ZERO)) {\n      return complex.real;\n    }\n    return complex;\n  }\n\n  promote(nType: NumberType): SchemeNumber {\n    switch (nType) {\n      case NumberType.COMPLEX:\n        return this;\n      default:\n        throw new Error(\"Unable to demote complex\");\n    }\n  }\n\n  negate(): SchemeNumber {\n    return SchemeComplex.build(this.real.negate(), this.imaginary.negate());\n  }\n\n  equals(other: SchemeComplex): boolean {\n    return (\n      atomic_equals(this.real, other.real) &&\n      atomic_equals(this.imaginary, other.imaginary)\n    );\n  }\n\n  greaterThan(other: SchemeComplex): boolean {\n    return (\n      atomic_greater_than(this.real, other.real) &&\n      atomic_greater_than(this.imaginary, other.imaginary)\n    );\n  }\n\n  multiplicativeInverse(): SchemeNumber {\n    // inverse of a + bi = a - bi / a^2 + b^2\n    // in this case, we use a / a^2 + b^2 and -b / a^2 + b^2 as the new values required\n    const denominator = atomic_add(\n      atomic_multiply(this.real, this.real),\n      atomic_multiply(this.imaginary, this.imaginary)\n    ) as SchemeInteger | SchemeRational | SchemeReal;\n    return SchemeComplex.build(\n      atomic_multiply(denominator.multiplicativeInverse(), this.real) as\n        | SchemeInteger\n        | SchemeRational\n        | SchemeReal,\n      atomic_multiply(\n        denominator.multiplicativeInverse(),\n        this.imaginary.negate()\n      ) as SchemeInteger | SchemeRational | SchemeReal\n    );\n  }\n\n  add(other: SchemeComplex): SchemeNumber {\n    return SchemeComplex.build(\n      atomic_add(this.real, other.real) as\n        | SchemeInteger\n        | SchemeRational\n        | SchemeReal,\n      atomic_add(this.imaginary, other.imaginary) as\n        | SchemeInteger\n        | SchemeRational\n        | SchemeReal\n    );\n  }\n\n  multiply(other: SchemeComplex): SchemeNumber {\n    // (a + bi) * (c + di) = (ac - bd) + (ad + bc)i\n    const realPart = atomic_subtract(\n      atomic_multiply(this.real, other.real),\n      atomic_multiply(this.imaginary, other.imaginary)\n    ) as SchemeInteger | SchemeRational | SchemeReal;\n    const imaginaryPart = atomic_add(\n      atomic_multiply(this.real, other.imaginary),\n      atomic_multiply(this.imaginary, other.real)\n    ) as SchemeInteger | SchemeRational | SchemeReal;\n    return SchemeComplex.build(realPart, imaginaryPart);\n  }\n\n  getReal(): SchemeInteger | SchemeRational | SchemeReal {\n    return this.real;\n  }\n\n  getImaginary(): SchemeInteger | SchemeRational | SchemeReal {\n    return this.imaginary;\n  }\n\n  coerce(): number {\n    throw new Error(\"Cannot coerce a complex number to a javascript number\");\n  }\n\n  toPolar(): SchemePolar {\n    // force both the real and imaginary parts to be inexact\n    const real = this.real.promote(NumberType.REAL) as SchemeReal;\n    const imaginary = this.imaginary.promote(NumberType.REAL) as SchemeReal;\n\n    // schemeReals can be reasoned with using the same logic as javascript numbers\n    // r = sqrt(a^2 + b^2)\n    const magnitude = SchemeReal.build(\n      Math.sqrt(\n        real.coerce() * real.coerce() + imaginary.coerce() * imaginary.coerce()\n      )\n    );\n    // theta = atan(b / a)\n    const angle = SchemeReal.build(\n      Math.atan2(imaginary.coerce(), real.coerce())\n    );\n    return SchemePolar.build(magnitude, angle);\n  }\n\n  toString(): string {\n    return `${this.real}+${this.imaginary}i`;\n  }\n}\n\n// an alternative form of the complex number.\n// only used in intermediate steps, will be converted back at the end of the operation.\n// current scm-slang will force any polar complex numbers to be made\n// inexact, hence we opt to limit the use of polar form as much as possible.\nclass SchemePolar {\n  readonly magnitude: SchemeReal;\n  readonly angle: SchemeReal;\n\n  private constructor(magnitude: SchemeReal, angle: SchemeReal) {\n    this.magnitude = magnitude;\n    this.angle = angle;\n  }\n\n  static build(magnitude: SchemeReal, angle: SchemeReal): SchemePolar {\n    return new SchemePolar(magnitude, angle);\n  }\n\n  // converts the polar number back to a cartesian complex number\n  toCartesian(): SchemeNumber {\n    // a + bi = r * cos(theta) + r * sin(theta)i\n    // a = r * cos(theta)\n    // b = r * sin(theta)\n    const real = SchemeReal.build(\n      this.magnitude.coerce() * Math.cos(this.angle.coerce())\n    );\n    const imaginary = SchemeReal.build(\n      this.magnitude.coerce() * Math.sin(this.angle.coerce())\n    );\n    return SchemeComplex.build(real, imaginary);\n  }\n}\n\nexport const infinity = SchemeReal.INFINITY;\nexport const nan = SchemeReal.NAN;\n\n// this function is used to convert a number to a javascript number.\n// it should only be limited to numbers used for indexing, integers.\nexport function coerce_to_number(a: SchemeNumber): number {\n  return a.coerce();\n}\n\n// these functions deal with checking the type of a number.\nexport function is_number(a: any): boolean {\n  return (\n    a.numberType !== undefined &&\n    Object.values(NumberType).includes(a.numberType)\n  );\n}\n\nexport function is_integer(a: any): boolean {\n  return is_number(a) && a.numberType <= 1;\n}\n\nexport function is_rational(a: any): boolean {\n  return is_number(a) && a.numberType <= 2;\n}\n\nexport function is_real(a: any): boolean {\n  return is_number(a) && a.numberType <= 3;\n}\n\nexport function is_complex(a: any): boolean {\n  return is_number(a) && a.numberType <= 4;\n}\n\nexport function is_exact(a: any): boolean {\n  // if the number is a complex number, we need to check both the real and imaginary parts\n  return is_number(a)\n    ? a.numberType === 4\n      ? is_exact(a.real) && is_exact(a.imaginary)\n      : a.numberType <= 2\n    : false;\n}\n\nexport function is_inexact(a: any): boolean {\n  // defined in terms of is_exact\n  return is_number(a) && !is_exact(a);\n}\n\n// the functions below are used to perform operations on numbers\n\nfunction simplify(a: SchemeNumber): SchemeNumber {\n  switch (a.numberType) {\n    case NumberType.INTEGER:\n      return a;\n    case NumberType.RATIONAL:\n      return (a as SchemeRational).getDenominator() === 1n\n        ? SchemeInteger.build(a.getNumerator())\n        : a;\n    case NumberType.REAL:\n      return a;\n    case NumberType.COMPLEX:\n      // safe to cast as simplify never promotes a number\n      return SchemeComplex.build(\n        simplify((a as SchemeComplex).getReal()) as\n          | SchemeInteger\n          | SchemeRational\n          | SchemeReal,\n        simplify((a as SchemeComplex).getImaginary()) as\n          | SchemeInteger\n          | SchemeRational\n          | SchemeReal\n      );\n  }\n}\n\n/**\n * This function takes two numbers and brings them to the same level.\n */\nfunction equalify(\n  a: SchemeNumber,\n  b: SchemeNumber\n): [SchemeNumber, SchemeNumber] {\n  if (a.numberType > b.numberType) {\n    return [a, b.promote(a.numberType)];\n  } else if (a.numberType < b.numberType) {\n    return [a.promote(b.numberType), b];\n  }\n  return [a, b];\n}\n\nexport function atomic_negate(a: SchemeNumber): SchemeNumber {\n  return a.negate();\n}\n\nexport function atomic_inverse(a: SchemeNumber): SchemeNumber {\n  return a.multiplicativeInverse();\n}\n\nexport function atomic_equals(a: SchemeNumber, b: SchemeNumber): boolean {\n  const [newA, newB] = equalify(a, b);\n  // safe to cast as we are assured they are of the same type\n  return newA.equals(newB as any);\n}\n\nexport function atomic_less_than(a: SchemeNumber, b: SchemeNumber): boolean {\n  return !atomic_greater_than(a, b) && !atomic_equals(a, b);\n}\n\nexport function atomic_less_than_or_equals(\n  a: SchemeNumber,\n  b: SchemeNumber\n): boolean {\n  return !atomic_greater_than(a, b);\n}\n\nexport function atomic_greater_than(a: SchemeNumber, b: SchemeNumber): boolean {\n  const [newA, newB] = equalify(a, b);\n  // safe to cast as we are assured they are of the same type\n  return newA.greaterThan(newB as any);\n}\n\nexport function atomic_greater_than_or_equals(\n  a: SchemeNumber,\n  b: SchemeNumber\n): boolean {\n  return atomic_greater_than(a, b) || atomic_equals(a, b);\n}\n\nexport function atomic_add(a: SchemeNumber, b: SchemeNumber): SchemeNumber {\n  const [newA, newB] = equalify(a, b);\n  // safe to cast as we are assured they are of the same type\n  return simplify(newA.add(newB as any));\n}\n\nexport function atomic_multiply(\n  a: SchemeNumber,\n  b: SchemeNumber\n): SchemeNumber {\n  const [newA, newB] = equalify(a, b);\n  // safe to cast as we are assured they are of the same type\n  return simplify(newA.multiply(newB as any));\n}\n\nexport function atomic_subtract(\n  a: SchemeNumber,\n  b: SchemeNumber\n): SchemeNumber {\n  return atomic_add(a, atomic_negate(b));\n}\n\nexport function atomic_divide(a: SchemeNumber, b: SchemeNumber): SchemeNumber {\n  return atomic_multiply(a, atomic_inverse(b));\n}\n\n/**\n * Important constants\n */\nexport const PI = SchemeReal.build(Math.PI);\nexport const E = SchemeReal.build(Math.E);\nexport const SQRT2 = SchemeReal.build(Math.SQRT2);\nexport const LN2 = SchemeReal.build(Math.LN2);\nexport const LN10 = SchemeReal.build(Math.LN10);\nexport const LOG2E = SchemeReal.build(Math.LOG2E);\nexport const LOG10E = SchemeReal.build(Math.LOG10E);\nexport const SQRT1_2 = SchemeReal.build(Math.SQRT1_2);\n\n// other important functions\n\nexport const numerator = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"numerator: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    // always return an integer\n    return is_exact(n) ? SchemeInteger.build(1) : SchemeReal.build(1);\n  }\n  if (!is_rational(n)) {\n    // is real number\n    // get the value of the number\n    const val = n.coerce();\n    // if the value is a defined special case, return accordingly\n    if (val === Infinity) {\n      return SchemeReal.build(1);\n    }\n    if (val === -Infinity) {\n      return SchemeReal.build(1);\n    }\n    if (isNaN(val)) {\n      return SchemeReal.NAN;\n    }\n    // if the value is an integer, return it\n    if (Number.isInteger(val)) {\n      return SchemeReal.build(val);\n    }\n    // else if the value is a float,\n    // multiply it till it becomes an integer\n    let multiplier = 1;\n    while (!Number.isInteger(val * multiplier)) {\n      multiplier *= 10;\n    }\n    let numerator = val * multiplier;\n    let denominator = multiplier;\n    // simplify the fraction\n    const gcd = (a: number, b: number): number => {\n      if (b === 0) {\n        return a;\n      }\n      return gcd(b, a % b);\n    };\n    const divisor = gcd(numerator, denominator);\n    numerator = numerator / divisor;\n    return SchemeReal.build(numerator);\n  }\n  return SchemeInteger.build(\n    (n.promote(NumberType.RATIONAL) as SchemeRational).getNumerator()\n  );\n};\n\nexport const denominator = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"denominator: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    // always return an integer\n    return is_exact(n) ? SchemeInteger.build(1) : SchemeReal.build(1);\n  }\n  if (!is_rational(n)) {\n    // is real number\n    // get the value of the number\n    const val = n.coerce();\n    // if the value is a defined special case, return accordingly\n    if (val === Infinity) {\n      return SchemeReal.INEXACT_ZERO;\n    }\n    if (val === -Infinity) {\n      return SchemeReal.INEXACT_ZERO;\n    }\n    if (isNaN(val)) {\n      return SchemeReal.NAN;\n    }\n    // if the value is an integer, return 1\n    if (Number.isInteger(val)) {\n      return SchemeReal.build(1);\n    }\n    // else if the value is a float,\n    // multiply it till it becomes an integer\n    let multiplier = 1;\n    while (!Number.isInteger(val * multiplier)) {\n      multiplier *= 10;\n    }\n    let numerator = val * multiplier;\n    let denominator = multiplier;\n    // simplify the fraction\n    const gcd = (a: number, b: number): number => {\n      if (b === 0) {\n        return a;\n      }\n      return gcd(b, a % b);\n    };\n    const divisor = gcd(numerator, denominator);\n    denominator = denominator / divisor;\n    return SchemeReal.build(denominator);\n  }\n  return SchemeInteger.build(\n    (n.promote(NumberType.RATIONAL) as SchemeRational).getDenominator()\n  );\n};\n\nexport const exact = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"exact: expected number\");\n  }\n  if (is_exact(n)) {\n    return n;\n  }\n  if (is_real(n)) {\n    // if the number is a real number, we can convert it to a rational number\n    // by multiplying it by a power of 10 until it becomes an integer\n    // and then dividing by the same power of 10\n    let multiplier = 1;\n    let val = n.coerce();\n    while (!Number.isInteger(val * multiplier)) {\n      multiplier *= 10;\n    }\n    return SchemeRational.build(val * multiplier, multiplier);\n  }\n  // if the number is a complex number, we can convert both the real and imaginary parts\n  // to exact numbers\n  return SchemeComplex.build(\n    exact((n as SchemeComplex).getReal()) as SchemeInteger | SchemeRational,\n    exact((n as SchemeComplex).getImaginary()) as SchemeInteger | SchemeRational\n  );\n};\n\nexport const inexact = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"inexact: expected number\");\n  }\n  if (is_inexact(n)) {\n    return n;\n  }\n  if (is_real(n)) {\n    // if the number is a real number, we can convert it to a float\n    return SchemeReal.build(n.coerce());\n  }\n  // if the number is a complex number, we can convert both the real and imaginary parts\n  // to inexact numbers\n  return SchemeComplex.build(\n    inexact((n as SchemeComplex).getReal()) as SchemeReal,\n    inexact((n as SchemeComplex).getImaginary()) as SchemeReal\n  );\n};\n\n// for now, exponentials, square roots and the like will be treated as\n// inexact functions, and will return inexact results. this allows us to\n// leverage on the inbuilt javascript Math library.\n// additional logic is required to handle complex numbers, which we can do with\n// our polar form representation.\n\nexport const expt = (n: SchemeNumber, e: SchemeNumber): SchemeNumber => {\n  if (!is_number(n) || !is_number(e)) {\n    throw new Error(\"expt: expected numbers\");\n  }\n  if (!is_real(n) || !is_real(e)) {\n    // complex number case\n    // we can convert both parts to polar form and use the\n    // polar form exponentiation formula.\n\n    // given a * e^(bi) and c * e^(di),\n    // (a * e^(bi)) ^ (c * e^(di)) can be represented by\n    // the general formula for complex exponentiation:\n    // (a^c * e^(-bd)) * e^(i(bc * ln(a) + ad))\n\n    // convert both numbers to polar form\n    const nPolar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();\n    const ePolar = (e.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();\n\n    const a = nPolar.magnitude.coerce();\n    const b = nPolar.angle.coerce();\n    const c = ePolar.magnitude.coerce();\n    const d = ePolar.angle.coerce();\n\n    // we can construct a new polar form following the formula above\n    const mag = SchemeReal.build(a ** c * Math.E ** (-b * d));\n    const angle = SchemeReal.build(b * c * Math.log(a) + a * d);\n\n    return SchemePolar.build(mag, angle).toCartesian();\n  }\n  // coerce both numbers to javascript numbers\n  const base = n.coerce();\n  const exponent = e.coerce();\n\n  // there are probably cases here i am not considering yet.\n  // for now, we will just use the javascript Math library and hope for the best.\n  return SchemeReal.build(Math.pow(base, exponent));\n};\n\nexport const exp = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"exp: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    throw new Error(\"exp: expected real number\");\n  }\n  return SchemeReal.build(Math.exp(n.coerce()));\n};\n\nexport const log = (n: SchemeNumber, base: SchemeNumber = E): SchemeNumber => {\n  if (!is_number(n) || !is_number(base)) {\n    throw new Error(\"log: expected numbers\");\n  }\n  if (!is_real(n) || !is_real(base)) {\n    // complex number case\n    // we can convert both parts to polar form and use the\n    // polar form logarithm formula.\n    // where log(a * e^(bi)) = log(a) + bi\n    // and log(c * e^(di)) = log(c) + di\n    // and so result is log(a) + bi / log(c) + di\n    // which is just (log(a) - log(c)) + (b / d) i\n\n    // convert both numbers to polar form\n    const nPolar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();\n    const basePolar = (\n      base.promote(NumberType.COMPLEX) as SchemeComplex\n    ).toPolar();\n    const a = nPolar.magnitude.coerce();\n    const b = nPolar.angle.coerce();\n    const c = basePolar.magnitude.coerce();\n    const d = basePolar.angle.coerce();\n\n    return SchemeComplex.build(\n      SchemeReal.build(Math.log(a) - Math.log(c)),\n      SchemeReal.build(b / d)\n    );\n  }\n  return SchemeReal.build(Math.log(n.coerce()) / Math.log(base.coerce()));\n};\n\nexport const sqrt = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"sqrt: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    const polar = (n.promote(NumberType.COMPLEX) as SchemeComplex).toPolar();\n    const mag = polar.magnitude;\n    const angle = polar.angle;\n\n    // the square root of a complex number is given by\n    // the square root of the magnitude and half the angle\n    const newMag = sqrt(mag) as SchemeReal;\n    const newAngle = SchemeReal.build(angle.coerce() / 2);\n\n    return SchemePolar.build(newMag, newAngle).toCartesian();\n  }\n  let value = n.coerce();\n\n  if (value < 0) {\n    return SchemeComplex.build(\n      SchemeReal.INEXACT_ZERO,\n      SchemeReal.build(Math.sqrt(-value))\n    );\n  }\n\n  return SchemeReal.build(Math.sqrt(n.coerce()));\n};\n\nexport const sin = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"sin: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n\n    // we can use euler's formula to find sin(x) for a complex number x = a + bi\n    // e^(ix) = cos(x) + i * sin(x)\n    // that can be rearranged into\n    // sin(x) = (e^(ix) - e^(-ix)) / 2i\n    // and finally into\n    // sin(x) = (sin(a) * (e^(-b) + e^(b)) / 2) + i * (cos(a) * (e^(-b) - e^(b)) / 2)\n    const complex = n.promote(NumberType.COMPLEX) as SchemeComplex;\n    const real = complex.getReal();\n    const imaginary = complex.getImaginary();\n    const a = real.coerce();\n    const b = imaginary.coerce();\n    return SchemeComplex.build(\n      SchemeReal.build((Math.sin(a) * (Math.exp(-b) + Math.exp(b))) / 2),\n      SchemeReal.build((Math.cos(a) * (Math.exp(-b) - Math.exp(b))) / 2)\n    );\n  }\n  return SchemeReal.build(Math.sin(n.coerce()));\n};\n\nexport const cos = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"cos: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n\n    // we can use euler's formula to find cos(x) for a complex number x = a + bi\n    // e^(ix) = cos(x) + i * sin(x)\n    // that can be rearranged into\n    // cos(x) = (e^(ix) + e^(-ix)) / 2\n    // and finally into\n    // cos(x) = (cos(a) * (e^(-b) + e^(b)) / 2) - i * (sin(a) * (e^(-b) - e^(b)) / 2)\n    const complex = n.promote(NumberType.COMPLEX) as SchemeComplex;\n    const real = complex.getReal();\n    const imaginary = complex.getImaginary();\n    const a = real.coerce();\n    const b = imaginary.coerce();\n    return SchemeComplex.build(\n      SchemeReal.build((Math.cos(a) * (Math.exp(-b) + Math.exp(b))) / 2),\n      SchemeReal.build((-Math.sin(a) * (Math.exp(-b) - Math.exp(b))) / 2)\n    );\n  }\n  return SchemeReal.build(Math.cos(n.coerce()));\n};\n\nexport const tan = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"tan: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    const sinValue = sin(n);\n    const cosValue = cos(n);\n    return atomic_divide(sinValue, cosValue);\n  }\n  return SchemeReal.build(Math.tan(n.coerce()));\n};\n\nexport const asin = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"asin: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    // asin(n) = -i * ln(i * n + sqrt(1 - n^2))\n    // we already have the building blocks needed to compute this\n    const i = SchemeComplex.build(\n      SchemeInteger.EXACT_ZERO,\n      SchemeInteger.build(1)\n    );\n    return atomic_multiply(\n      atomic_negate(i),\n      log(\n        atomic_add(\n          atomic_multiply(i, n),\n          sqrt(atomic_subtract(SchemeInteger.build(1), atomic_multiply(n, n)))\n        )\n      )\n    );\n  }\n  return SchemeReal.build(Math.asin(n.coerce()));\n};\n\nexport const acos = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"acos: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    // acos(n) = -i * ln(n + sqrt(n^2 - 1))\n    // again, we have the building blocks needed to compute this\n    const i = SchemeComplex.build(\n      SchemeInteger.EXACT_ZERO,\n      SchemeInteger.build(1)\n    );\n    return atomic_multiply(\n      atomic_negate(i),\n      log(\n        atomic_add(\n          n,\n          sqrt(atomic_subtract(atomic_multiply(n, n), SchemeInteger.build(1)))\n        )\n      )\n    );\n  }\n  return SchemeReal.build(Math.acos(n.coerce()));\n};\n\nexport const atan = (n: SchemeNumber, m?: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"atan: expected number\");\n  }\n\n  if (m !== undefined) {\n    // two argument case, we construct a complex number with n + mi\n    // if neither n nor m are real, it's an error\n    if (!is_real(n) || !is_real(m)) {\n      throw new Error(\"atan: expected real numbers\");\n    }\n    return atan(\n      SchemeComplex.build(\n        n as SchemeInteger | SchemeRational | SchemeReal,\n        m as SchemeInteger | SchemeRational | SchemeReal\n      )\n    );\n  }\n\n  if (!is_real(n)) {\n    // complex number case\n    // atan(n) = 1/2 * i * ln((1 - i * n) / (1 + i * n))\n    const i = SchemeComplex.build(\n      SchemeInteger.EXACT_ZERO,\n      SchemeInteger.build(1)\n    );\n    return atomic_multiply(\n      // multiply is associative so the order here doesn't matter\n      atomic_multiply(SchemeRational.build(1, 2), i),\n      log(\n        atomic_divide(\n          atomic_subtract(SchemeInteger.build(1), atomic_multiply(i, n)),\n          atomic_add(SchemeInteger.build(1), atomic_multiply(i, n))\n        )\n      )\n    );\n  }\n  return SchemeReal.build(Math.atan(n.coerce()));\n};\n\nexport const floor = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"floor: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    throw new Error(\"floor: expected real number\");\n  }\n  if (n.numberType === NumberType.INTEGER) {\n    return n;\n  }\n  if (n.numberType === NumberType.RATIONAL) {\n    // floor is numerator // denominator\n    const rational = n as SchemeRational;\n    const numerator = rational.getNumerator();\n    const denominator = rational.getDenominator();\n    return SchemeInteger.build(numerator / denominator);\n  }\n  return SchemeReal.build(Math.floor(n.coerce()));\n};\n\nexport const ceiling = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"ceiling: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    throw new Error(\"ceiling: expected real number\");\n  }\n  if (n.numberType === NumberType.INTEGER) {\n    return n;\n  }\n  if (n.numberType === NumberType.RATIONAL) {\n    // ceiling is (numerator + denominator - 1) // denominator\n    const rational = n as SchemeRational;\n    const numerator = rational.getNumerator();\n    const denominator = rational.getDenominator();\n    return SchemeInteger.build((numerator + denominator - 1n) / denominator);\n  }\n  return SchemeReal.build(Math.ceil(n.coerce()));\n};\n\nexport const truncate = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"truncate: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    throw new Error(\"truncate: expected real number\");\n  }\n  if (n.numberType === NumberType.INTEGER) {\n    return n;\n  }\n  if (n.numberType === NumberType.RATIONAL) {\n    // truncate is also just numerator // denominator\n    // exactly like floor\n    const rational = n as SchemeRational;\n    const numerator = rational.getNumerator();\n    const denominator = rational.getDenominator();\n    return SchemeInteger.build(numerator / denominator);\n  }\n  return SchemeReal.build(Math.trunc(n.coerce()));\n};\n\nexport const round = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"round: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    throw new Error(\"round: expected real number\");\n  }\n  if (n.numberType === NumberType.INTEGER) {\n    return n;\n  }\n  if (n.numberType === NumberType.RATIONAL) {\n    // round is numerator + denominator // 2 * denominator\n    const rational = n as SchemeRational;\n    const numerator = rational.getNumerator();\n    const denominator = rational.getDenominator();\n    return SchemeInteger.build((numerator + denominator / 2n) / denominator);\n  }\n  return SchemeReal.build(Math.round(n.coerce()));\n};\n\nexport const make$45$rectangular = (\n  a: SchemeNumber,\n  b: SchemeNumber\n): SchemeNumber => {\n  if (!is_number(a) || !is_number(b)) {\n    throw new Error(\"make-rectangular: expected numbers\");\n  }\n  if (!is_real(a) || !is_real(b)) {\n    // complex number case\n    throw new Error(\"make-rectangular: expected real numbers\");\n  }\n  return SchemeComplex.build(\n    a as SchemeReal | SchemeRational | SchemeInteger,\n    b as SchemeReal | SchemeRational | SchemeInteger\n  );\n};\n\nexport const make$45$polar = (\n  a: SchemeNumber,\n  b: SchemeNumber\n): SchemeNumber => {\n  if (!is_number(a) || !is_number(b)) {\n    throw new Error(\"make-polar: expected numbers\");\n  }\n  if (!is_real(a) || !is_real(b)) {\n    // complex number case\n    throw new Error(\"make-polar: expected real numbers\");\n  }\n  return SchemePolar.build(\n    a.promote(NumberType.REAL) as SchemeReal,\n    b.promote(NumberType.REAL) as SchemeReal\n  ).toCartesian();\n};\n\nexport const real$45$part = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"real-part: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    return (n as SchemeComplex).getReal();\n  }\n  return n;\n};\n\nexport const imag$45$part = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"imag-part: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    return (n as SchemeComplex).getImaginary();\n  }\n  return SchemeInteger.EXACT_ZERO;\n};\n\nexport const magnitude = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"magnitude: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    return (n as SchemeComplex).toPolar().magnitude;\n  }\n  // abs is not defined here so we should just use direct comparison\n  if (atomic_less_than(n, SchemeInteger.EXACT_ZERO)) {\n    return atomic_negate(n);\n  }\n  return n;\n};\n\nexport const angle = (n: SchemeNumber): SchemeNumber => {\n  if (!is_number(n)) {\n    throw new Error(\"angle: expected number\");\n  }\n  if (!is_real(n)) {\n    // complex number case\n    return (n as SchemeComplex).toPolar().angle;\n  }\n  if (atomic_less_than(n, SchemeInteger.EXACT_ZERO)) {\n    return PI;\n  }\n  return SchemeInteger.EXACT_ZERO;\n};\n\nexport const odd$63$ = (n: SchemeInteger): boolean => {\n  if (!is_number(n)) {\n    throw new Error(\"odd?: expected integer\");\n  }\n\n  if (!is_integer(n)) {\n    throw new Error(\"odd?: expected integer\");\n  }\n\n  return n.getBigInt() % 2n === 1n;\n};\n\nexport const even$63$ = (n: SchemeInteger): boolean => {\n  if (!is_number(n)) {\n    throw new Error(\"even?: expected integer\");\n  }\n\n  if (!is_integer(n)) {\n    throw new Error(\"even?: expected integer\");\n  }\n\n  return n.getBigInt() % 2n === 0n;\n};\n","import { Constant } from \"../../../common/Constant\";\nimport type { IServiceMessage } from \"../IServiceMessage\";\nimport { ServiceMessageType } from \"../ServiceMessageType\";\n\nexport class HelloServiceMessage implements IServiceMessage {\n    readonly type = ServiceMessageType.HELLO;\n    readonly data = { version: Constant.PROTOCOL_VERSION };\n}\n","import type { IServiceMessage } from \"../IServiceMessage\";\nimport { ServiceMessageType } from \"../ServiceMessageType\";\n\nexport class PluginServiceMessage implements IServiceMessage {\n    readonly type = ServiceMessageType.PLUGIN;\n    readonly data: string;\n    constructor(pluginName: string) {\n        this.data = pluginName;\n    }\n}\n","import { Constant } from \"../../common/Constant\";\nimport type { ConductorError } from \"../../common/errors\";\nimport { ConductorInternalError } from \"../../common/errors/ConductorInternalError\";\nimport { importExternalModule, importExternalPlugin } from \"../../common/util\";\nimport { IConduit, IChannelQueue, IChannel, ChannelQueue, IPlugin } from \"../../conduit\";\nimport { makeRpc } from \"../../conduit/rpc\";\nimport { Remote } from \"../../conduit/rpc/types\";\nimport { PluginClass } from \"../../conduit/types\";\nimport { checkIsPluginClass } from \"../../conduit/util\";\nimport { IHostFileRpc } from \"../host/types\";\nimport { IModulePlugin } from \"../module\";\nimport { ModuleClass } from \"../module/types/ModuleClass\";\nimport { InternalChannelName, InternalPluginName } from \"../strings\";\nimport { Chunk, IChunkMessage, IServiceMessage, IIOMessage, IStatusMessage, RunnerStatus, ServiceMessageType, HelloServiceMessage, AbortServiceMessage, type EntryServiceMessage, IErrorMessage, PluginServiceMessage } from \"../types\";\nimport { IRunnerPlugin, IEvaluator, IInterfacableEvaluator, EvaluatorClass } from \"./types\";\n\n@checkIsPluginClass\nexport class RunnerPlugin implements IRunnerPlugin {\n    name = InternalPluginName.RUNNER_MAIN;\n\n    private readonly __evaluator: IEvaluator | IInterfacableEvaluator;\n    private readonly __isCompatibleWithModules: boolean;\n    private readonly __conduit: IConduit;\n    private readonly __fileRpc: Remote<IHostFileRpc>;\n    private readonly __chunkQueue: IChannelQueue<IChunkMessage>;\n    private readonly __serviceChannel: IChannel<IServiceMessage>;\n    private readonly __ioQueue: IChannelQueue<IIOMessage>;\n    private readonly __errorChannel: IChannel<IErrorMessage>;\n    private readonly __statusChannel: IChannel<IStatusMessage>;\n\n    // @ts-expect-error TODO: figure proper way to typecheck this\n    private readonly __serviceHandlers = new Map<ServiceMessageType, (message: IServiceMessage) => void>([\n        [ServiceMessageType.HELLO, function helloServiceHandler(this: RunnerPlugin, message: HelloServiceMessage) {\n            if (message.data.version < Constant.PROTOCOL_MIN_VERSION) {\n                this.__serviceChannel.send(new AbortServiceMessage(Constant.PROTOCOL_MIN_VERSION));\n                console.error(`Host's protocol version (${message.data.version}) must be at least ${Constant.PROTOCOL_MIN_VERSION}`);\n            } else {\n                console.log(`Host is using protocol version ${message.data.version}`);\n            }\n        }],\n        [ServiceMessageType.ABORT, function abortServiceHandler(this: RunnerPlugin, message: AbortServiceMessage) {\n            console.error(`Host expects at least protocol version ${message.data.minVersion}, but we are on version ${Constant.PROTOCOL_VERSION}`);\n            this.__conduit.terminate();\n        }],\n        [ServiceMessageType.ENTRY, function entryServiceHandler(this: RunnerPlugin, message: EntryServiceMessage) {\n            this.__evaluator.startEvaluator(message.data);\n        }]\n    ]);\n\n    requestFile(fileName: string): Promise<string | undefined> {\n        return this.__fileRpc.requestFile(fileName);\n    }\n\n    async requestChunk(): Promise<Chunk> {\n        return (await this.__chunkQueue.receive()).chunk;\n    }\n\n    async requestInput(): Promise<string> {\n        const { message } = await this.__ioQueue.receive();\n        return message;\n    }\n\n    tryRequestInput(): string | undefined {\n        const out = this.__ioQueue.tryReceive();\n        return out?.message;\n    }\n\n    sendOutput(message: string): void {\n        this.__ioQueue.send({ message });\n    }\n\n    sendError(error: ConductorError): void {\n        this.__errorChannel.send({ error });\n    }\n\n    updateStatus(status: RunnerStatus, isActive: boolean): void {\n        this.__statusChannel.send({ status, isActive });\n    }\n\n    hostLoadPlugin(pluginName: string): void {\n        this.__serviceChannel.send(new PluginServiceMessage(pluginName));\n    }\n\n    registerPlugin<Arg extends any[], T extends IPlugin>(pluginClass: PluginClass<Arg, T>, ...arg: Arg): NoInfer<T> {\n        return this.__conduit.registerPlugin(pluginClass, ...arg);\n    }\n\n    unregisterPlugin(plugin: IPlugin): void {\n        this.__conduit.unregisterPlugin(plugin);\n    }\n\n    registerModule<T extends IModulePlugin>(moduleClass: ModuleClass<T>): NoInfer<T> {\n        if (!this.__isCompatibleWithModules) throw new ConductorInternalError(\"Evaluator has no data interface\");\n        return this.registerPlugin(moduleClass, this.__evaluator as IInterfacableEvaluator);\n    }\n\n    unregisterModule(module: IModulePlugin): void {\n        this.unregisterPlugin(module);\n    }\n\n    async importAndRegisterExternalPlugin(location: string): Promise<IPlugin> {\n        const pluginClass = await importExternalPlugin(location);\n        return this.registerPlugin(pluginClass);\n    }\n\n    async importAndRegisterExternalModule(location: string): Promise<IModulePlugin> {\n        const moduleClass = await importExternalModule(location);\n        return this.registerModule(moduleClass);\n    }\n\n    static readonly channelAttach = [InternalChannelName.FILE, InternalChannelName.CHUNK, InternalChannelName.SERVICE, InternalChannelName.STANDARD_IO, InternalChannelName.ERROR, InternalChannelName.STATUS];\n    constructor(\n        conduit: IConduit,\n        [fileChannel, chunkChannel, serviceChannel, ioChannel, errorChannel, statusChannel]: IChannel<any>[],\n        evaluatorClass: EvaluatorClass\n    ) {\n        this.__conduit = conduit;\n        this.__fileRpc = makeRpc<{}, IHostFileRpc>(fileChannel, {});\n        this.__chunkQueue = new ChannelQueue(chunkChannel);\n        this.__serviceChannel = serviceChannel;\n        this.__ioQueue = new ChannelQueue(ioChannel);\n        this.__errorChannel = errorChannel;\n        this.__statusChannel = statusChannel;\n\n        this.__serviceChannel.send(new HelloServiceMessage());\n        this.__serviceChannel.subscribe(message => {\n            this.__serviceHandlers.get(message.type)?.call(this, message);\n        });\n\n        this.__evaluator = new evaluatorClass(this);\n        this.__isCompatibleWithModules = (this.__evaluator as IInterfacableEvaluator).hasDataInterface ?? false;\n    }\n}\n","import { IChannel } from \"../types\";\nimport { IRpcMessage, Remote, RpcCallMessage, RpcErrorMessage, RpcMessageType, RpcReturnMessage } from \"./types\";\n\nexport function makeRpc<ISelf, IOther>(channel: IChannel<IRpcMessage>, self: ISelf): Remote<IOther> {\n    const waiting: [Function, Function][] = [];\n    let invocations = 0;\n    const otherCallbacks: Partial<Record<keyof IOther, (...args: any) => Promise<any>>> = {};\n\n    channel.subscribe(async rpcMessage => {\n        switch (rpcMessage.type) {\n            case RpcMessageType.CALL:\n                {\n                    const {fn, args, invokeId} = (rpcMessage as RpcCallMessage).data;\n                    try {\n                        // @ts-expect-error\n                        const res = await self[fn as keyof ISelf](...args);\n                        if (invokeId > 0) channel.send(new RpcReturnMessage(invokeId, res));\n                    } catch (err) {\n                        if (invokeId > 0) channel.send(new RpcErrorMessage(invokeId, err));\n                    }\n                    break;\n                }\n            case RpcMessageType.RETURN:\n                {\n                    const {invokeId, res} = (rpcMessage as RpcReturnMessage).data;\n                    waiting[invokeId]?.[0]?.(res);\n                    delete waiting[invokeId];\n                    break;\n                }\n            case RpcMessageType.RETURN_ERR:\n                {\n                    const {invokeId, err} = (rpcMessage as RpcErrorMessage).data;\n                    waiting[invokeId]?.[1]?.(err);\n                    delete waiting[invokeId];\n                    break;\n                }\n        }\n    });\n\n    return new Proxy(otherCallbacks, { // TODO: transferring functions\n        get(target, p, receiver) {\n            const cb = Reflect.get(target, p, receiver);\n            if (cb) return cb;\n            const newCallback = typeof p === \"string\" && p.charAt(0) === \"$\"\n                ? (...args: any[]) => {\n                    channel.send(new RpcCallMessage(p, args, 0));\n                }\n                : (...args: any[]) => {\n                    const invokeId = ++invocations;\n                    channel.send(new RpcCallMessage(p, args, invokeId));\n                    return new Promise((resolve, reject) => {\n                        waiting[invokeId] = [resolve, reject];\n                    });\n                }\n            Reflect.set(target, p, newCallback, receiver);\n            return newCallback;\n        },\n    }) as Remote<IOther>;\n}\n","// A data structure representing the span of the scheme node.\nexport class Location {\n  constructor(\n    public start: Position,\n    public end: Position\n  ) {}\n\n  merge(other: Location): Location {\n    return new Location(this.start, other.end);\n  }\n}\n\n// A data structure representing a particular position of a token.\nexport class Position {\n  constructor(\n    public line: number,\n    public column: number\n  ) {}\n}\n","// Adapted from https://craftinginterpreters.com/scanning.html\n// Adapted for Scheme use\n\nexport enum TokenType {\n  // + - * / % ^ ! = < > & | ~ etc are recognized as IDENTIFIERS\n\n  // S-expression syntax\n  LEFT_PAREN,\n  RIGHT_PAREN,\n  LEFT_BRACKET,\n  RIGHT_BRACKET,\n  DOT,\n\n  // Datum comments\n  HASH_SEMICOLON,\n\n  // Atoms: Literals or Identifiers\n  IDENTIFIER,\n  NUMBER,\n  BOOLEAN,\n  STRING,\n\n  // SICP Chapter 1\n  IF,\n  LET,\n  COND,\n  ELSE,\n  DEFINE,\n  LAMBDA,\n\n  // SICP Chapter 2\n  APOSTROPHE, // Quote\n  BACKTICK, // Quasiquote\n  COMMA, // Unquote\n  COMMA_AT, // Unquote-splicing\n  QUOTE,\n  QUASIQUOTE,\n  UNQUOTE,\n  UNQUOTE_SPLICING,\n\n  // SICP Chapter 3\n  SET,\n  BEGIN,\n  DELAY,\n\n  // Other important keywords\n  IMPORT,\n  EXPORT,\n\n  // keywords associated with macros\n  DEFINE_SYNTAX,\n  SYNTAX_RULES,\n\n  // Not in scope at the moment\n  HASH_VECTOR, // vector\n  VECTOR, // depreciated, as i believe\n  // turning vector into a procedure call is better\n  EOF,\n}\n","import { Datum } from \"../types/tokens/datum\";\nimport { Token } from \"../types/tokens/token\";\nimport { Position } from \"estree\";\n\nfunction extractLine(source: string, pos: Position): string {\n  let lines = source.split(\"\\n\");\n  return lines[pos.line - 1];\n}\n\nfunction showPoint(pos: Position): string {\n  return \"^\".padStart(pos.column, \" \");\n}\n\nexport abstract class ParserError extends SyntaxError {\n  // This base error shouldn't be used directly.\n  loc: Position;\n  constructor(message: string, pos: Position) {\n    super(`Syntax error at (${pos.line}:${pos.column})\\n${message}`);\n    this.loc = pos;\n  }\n  toString(): string {\n    return this.message;\n  }\n}\n\nexport class GenericSyntaxError extends ParserError {\n  constructor(source: string, pos: Position) {\n    super(extractLine(source, pos) + \"\\n\" + showPoint(pos), pos);\n    this.name = \"GenericSyntaxError\";\n  }\n}\n\nexport class ParenthesisMismatchError extends ParserError {\n  constructor(source: string, pos: Position) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        \"Mismatched parenthesis\",\n      pos\n    );\n    this.name = \"ParenthesisMismatchError\";\n  }\n}\n\nexport class UnexpectedEOFError extends ParserError {\n  constructor(source: string, pos: Position) {\n    super(extractLine(source, pos) + \"\\n\" + \"Unexpected EOF\", pos);\n    this.name = \"UnexpectedEOFError\";\n  }\n}\n\nexport class UnexpectedFormError extends ParserError {\n  form: Datum;\n  constructor(source: string, pos: Position, form: Datum) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        `Unexpected \\'${form}\\'`,\n      pos\n    );\n    this.form = form;\n    this.name = \"UnexpectedTokenError\";\n  }\n}\n\nexport class ExpectedFormError extends ParserError {\n  form: Datum;\n  expected: string;\n  constructor(source: string, pos: Position, form: Datum, expected: string) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        `Expected \\'${expected}\\' but got \\'${form}\\'`,\n      pos\n    );\n    this.form = form;\n    this.expected = expected;\n    this.name = \"ExpectedTokenError\";\n  }\n}\n\nexport class MissingFormError extends ParserError {\n  expected: string;\n  constructor(source: string, pos: Position, expected: string) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        `Expected \\'${expected}\\'`,\n      pos\n    );\n    this.expected = expected;\n    this.name = \"MissingTokenError\";\n  }\n}\n\nexport class DisallowedTokenError extends ParserError {\n  token: Token;\n  constructor(source: string, pos: Position, token: Token, chapter: number) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        `Syntax \\'${token}\\' not allowed at Scheme \\xa7${chapter}`,\n      pos\n    );\n    this.token = token;\n    this.name = \"DisallowedTokenError\";\n  }\n}\n\nexport class UnsupportedTokenError extends ParserError {\n  token: Token;\n  constructor(source: string, pos: Position, token: Token) {\n    super(\n      extractLine(source, pos) +\n        \"\\n\" +\n        showPoint(pos) +\n        \"\\n\" +\n        `Syntax \\'${token}\\' not supported yet`,\n      pos\n    );\n    this.token = token;\n    this.name = \"UnsupportedTokenError\";\n  }\n}\n","/**\n * A group of elements, possibly bounded by parentheses.\n * Represents a group of related elements.\n */\nimport { Token } from \"./token\";\nimport { TokenType } from \"./token-type\";\nimport { Location, Position } from \"../location\";\nimport { Datum } from \"./datum\";\nimport { isGroup, isToken } from \".\";\nimport { ExpectedFormError } from \"../../parser/parser-error\";\n\nexport class Group {\n  // Invariants:\n  // - A group must not be empty (ie no tokens at all).\n  // - If a group is not parenthesized, it contains either one element, that is not a group,\n  //   or two elements, of which the first one is not a group.\n  // - If a group is parenthesized, it must have matching parentheses.\n  readonly elements: Datum[];\n  readonly location: Location;\n  private constructor(elements: Datum[]) {\n    this.elements = elements;\n    this.location = new Location(this.firstPos(), this.lastPos());\n  }\n\n  /**\n   * A constructor function for a group that enforces group invariants.\n   */\n  public static build(elements: Datum[]) {\n    // helper function to check if the parentheses match.\n    function matchingParentheses(lParen: Token, rParen: Token) {\n      return (\n        (lParen.type === TokenType.LEFT_PAREN &&\n          rParen.type === TokenType.RIGHT_PAREN) ||\n        (lParen.type === TokenType.LEFT_BRACKET &&\n          rParen.type === TokenType.RIGHT_BRACKET)\n      );\n    }\n\n    // helper function to check if the token is a data type.\n    function isDataType(token: Token) {\n      return (\n        token.type === TokenType.IDENTIFIER ||\n        token.type === TokenType.NUMBER ||\n        token.type === TokenType.STRING ||\n        token.type === TokenType.BOOLEAN\n      );\n    }\n\n    // helper function to determine if the token is an affector type.\n    // (and the affector type should be the short version).\n    function isShortAffector(token: Token) {\n      return (\n        token.type === TokenType.APOSTROPHE ||\n        token.type === TokenType.BACKTICK ||\n        token.type === TokenType.HASH_VECTOR ||\n        token.type === TokenType.COMMA ||\n        token.type === TokenType.COMMA_AT\n      );\n    }\n\n    // Illegal empty group.\n    if (elements.length === 0) {\n      // This should never happen.\n      // If it does its the implementor's fault.\n      throw new Error(\"Illegal empty group. This should never happen.\");\n    }\n    // If the group is not parenthesized, the first case contains only one element.\n    if (elements.length === 1) {\n      const onlyElement: Datum = elements[0];\n\n      if (isGroup(onlyElement)) {\n        // Return the inner group.\n        // Avoid nested groups that are a product of the grouping generation in the parser.\n        // Ensures the single internal element is not a group.\n        return onlyElement;\n      }\n\n      // Ensure the single element is a data type by validating its token type.\n      if (!isDataType(onlyElement)) {\n        // This should never happen.\n        // If it does its the implementor's fault.\n        throw new ExpectedFormError(\"\", onlyElement.pos, onlyElement, \"<data>\");\n      }\n\n      return new Group(elements);\n    }\n\n    // If the group is not parenthesized, the remaining case contains two elements.\n    if (elements.length === 2) {\n      const firstElement = elements[0];\n\n      // Ensure the first element is an affector type and\n      if (isToken(firstElement) && isShortAffector(firstElement)) {\n        return new Group(elements);\n      }\n\n      // If all else fails, use the most generic case below.\n    }\n\n    // If the group is parenthesized, the parentheses must match.\n    const firstElement = elements[0];\n    const lastElement = elements[elements.length - 1];\n    if (\n      isToken(firstElement) &&\n      isToken(lastElement) &&\n      matchingParentheses(firstElement, lastElement)\n    ) {\n      return new Group(elements);\n    }\n\n    // This should never happen.\n    const wrongGroup = new Group(elements);\n    throw new ExpectedFormError(\n      \"\",\n      wrongGroup.location.start,\n      wrongGroup,\n      \"matching parentheses\"\n    );\n  }\n\n  // Get the first element of the group.\n  first(): Datum {\n    return this.elements[0];\n  }\n\n  // Get the first token of the group.\n  public firstToken(): Token {\n    const firstElement = this.first();\n    if (isToken(firstElement)) {\n      return firstElement;\n    } else {\n      return firstElement.firstToken();\n    }\n  }\n\n  // Get the starting position of the first element of the group.\n  firstPos(): Position {\n    return this.firstToken().pos;\n  }\n\n  // Get the last element of the group.\n  last(): Datum {\n    return this.elements[this.elements.length - 1];\n  }\n\n  lastToken(): Token {\n    const lastElement = this.last();\n    if (isToken(lastElement)) {\n      return lastElement;\n    } else {\n      return lastElement.lastToken();\n    }\n  }\n\n  // Get the ending position of the last element of the group.\n  lastPos(): Position {\n    return this.lastToken().pos;\n  }\n\n  /**\n   * Check if the current group is parenthesized.\n   */\n  public isParenthesized(): boolean {\n    const firstElement = this.first();\n\n    // Because of the validation performed by the factory function,\n    // we can assume that as long as the first element is a paranthesis,\n    // the last element is also the corresponding paranthesis.\n    return (\n      isToken(firstElement) &&\n      (firstElement.type === TokenType.LEFT_PAREN ||\n        firstElement.type === TokenType.LEFT_BRACKET)\n    );\n  }\n\n  /**\n   * Using the invariants, we can determine if a group actually\n   * represents a singular identifier.\n   */\n  public isSingleIdentifier(): boolean {\n    return !this.isParenthesized() && this.length() === 1;\n  }\n\n  /**\n   * Get the internal elements of the group.\n   * If the group is bounded by parentheses, the parentheses are excluded.\n   * @returns All elements of the group excluding parentheses.\n   */\n  public unwrap(): Datum[] {\n    if (this.isParenthesized()) {\n      return this.elements.slice(1, this.elements.length - 1);\n    }\n    return this.elements;\n  }\n\n  /**\n   * Get the number of elements in the group.\n   * Ignores parentheses.\n   * @returns The number of elements in the group.\n   */\n  public length(): number {\n    return this.unwrap().length;\n  }\n\n  /**\n   * @returns A string representation of the group\n   */\n  toString(): string {\n    return this.elements.map(e => e.toString()).join(\" \");\n  }\n}\n","import { Datum } from \"./datum\";\nimport { Group } from \"./group\";\nimport { Token } from \"./token\";\n\nexport { Token } from \"./token\";\nexport { TokenType } from \"./token-type\";\nexport { Group } from \"./group\";\nexport { Datum } from \"./datum\";\n\nexport function isToken(datum: Datum): datum is Token {\n  return datum instanceof Token;\n}\n\nexport function isGroup(datum: Datum): datum is Group {\n  return datum instanceof Group;\n}\n","/**\n * A data structure representing a particular token.\n */\n\nimport { Position } from \"../location\";\nimport { TokenType } from \".\";\n\nexport class Token {\n  type: TokenType;\n  lexeme: string;\n  literal: any;\n  start: number;\n  end: number;\n  pos: Position;\n  endPos: Position;\n\n  constructor(\n    type: TokenType,\n    lexeme: any,\n    literal: any,\n    start: number,\n    end: number,\n    line: number,\n    col: number\n  ) {\n    this.type = type;\n    this.lexeme = lexeme;\n    this.literal = literal;\n    this.start = start;\n    this.end = end;\n    this.pos = new Position(line, col);\n    this.endPos = new Position(line, col + lexeme.length - 1);\n  }\n\n  /**\n   * Converts a token to another representation of itself.\n   * Especially useful for quotation tokens.\n   * @returns A converted token.\n   */\n  public convertToken(): Token {\n    switch (this.type) {\n      case TokenType.APOSTROPHE:\n        return new Token(\n          TokenType.QUOTE,\n          this.lexeme,\n          this.literal,\n          this.start,\n          this.end,\n          this.pos.line,\n          this.pos.column\n        );\n      case TokenType.BACKTICK:\n        return new Token(\n          TokenType.QUASIQUOTE,\n          this.lexeme,\n          this.literal,\n          this.start,\n          this.end,\n          this.pos.line,\n          this.pos.column\n        );\n      case TokenType.HASH_VECTOR:\n        return new Token(\n          TokenType.VECTOR,\n          this.lexeme,\n          this.literal,\n          this.start,\n          this.end,\n          this.pos.line,\n          this.pos.column\n        );\n      case TokenType.COMMA:\n        return new Token(\n          TokenType.UNQUOTE,\n          this.lexeme,\n          this.literal,\n          this.start,\n          this.end,\n          this.pos.line,\n          this.pos.column\n        );\n      case TokenType.COMMA_AT:\n        return new Token(\n          TokenType.UNQUOTE_SPLICING,\n          this.lexeme,\n          this.literal,\n          this.start,\n          this.end,\n          this.pos.line,\n          this.pos.column\n        );\n      default:\n        return this;\n    }\n  }\n\n  /**\n   * For debugging.\n   * @returns A string representation of the token.\n   */\n  public toString(): string {\n    return `${this.lexeme}`;\n  }\n}\n","/**\n * Node types of the abstract syntax tree of the Scheme Language.\n * We aim to be as simple as possible, and only represent the bare minimum\n * of Scheme syntax.\n *\n * Syntatic sugar such as \"cond\" or \"let\" will be left in another file,\n * and will be translated into the bare minimum of Scheme syntax, for now\n * with a transformer visitor, and perhaps later with a macro system.\n */\n\nimport { Visitor } from \"../../visitors\";\nimport { Location } from \"../location\";\n\n/**\n * A basic node that represents a Scheme expression.\n */\nexport interface Expression {\n  location: Location;\n  accept(visitor: Visitor): any;\n  equals(other: Expression): boolean;\n}\n\n/**\n * The namespace for all the atomic node types.\n */\nexport namespace Atomic {\n  // Scheme chapter 1\n\n  /**\n   * A node that represents a sequence of expressions.\n   * Also introduces a new scope.\n   * The last expression is the return value of the sequence.\n   */\n  export class Sequence implements Expression {\n    location: Location;\n    expressions: Expression[];\n    constructor(location: Location, expressions: Expression[]) {\n      this.location = location;\n      this.expressions = expressions;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitSequence(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Sequence) {\n        if (this.expressions.length !== other.expressions.length) {\n          return false;\n        }\n        for (let i = 0; i < this.expressions.length; i++) {\n          if (!this.expressions[i].equals(other.expressions[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node that represents a Scheme literal.\n   */\n  export interface Literal extends Expression {\n    value: any;\n  }\n\n  /**\n   * A node that represents a Scheme number.\n   * TODO: Support the Scheme number tower.\n   */\n  export class NumericLiteral implements Literal {\n    location: Location;\n    value: string;\n    constructor(location: Location, value: string) {\n      this.location = location;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitNumericLiteral(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof NumericLiteral) {\n        return this.value === other.value;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node that represents a Scheme boolean.\n   */\n  export class BooleanLiteral implements Literal {\n    location: Location;\n    value: boolean;\n    constructor(location: Location, value: boolean) {\n      this.location = location;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitBooleanLiteral(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof BooleanLiteral) {\n        return this.value === other.value;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node that represents a Scheme string.\n   */\n  export class StringLiteral implements Literal {\n    location: Location;\n    value: string;\n    constructor(location: Location, value: string) {\n      this.location = location;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitStringLiteral(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof StringLiteral) {\n        return this.value === other.value;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme lambda expression.\n   * TODO: Support rest arguments.\n   */\n  export class Lambda implements Expression {\n    location: Location;\n    params: Identifier[];\n    rest?: Identifier;\n    body: Expression;\n    constructor(\n      location: Location,\n      body: Expression,\n      params: Identifier[],\n      rest: Identifier | undefined = undefined\n    ) {\n      this.location = location;\n      this.params = params;\n      this.rest = rest;\n      this.body = body;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitLambda(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Lambda) {\n        if (this.params.length !== other.params.length) {\n          return false;\n        }\n        for (let i = 0; i < this.params.length; i++) {\n          if (!this.params[i].equals(other.params[i])) {\n            return false;\n          }\n        }\n        if (this.rest && other.rest) {\n          if (!this.rest.equals(other.rest)) {\n            return false;\n          }\n        } else if (this.rest || other.rest) {\n          return false;\n        }\n        return this.body.equals(other.body);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme identifier.\n   */\n  export class Identifier implements Expression {\n    location: Location;\n    name: string;\n    constructor(location: Location, name: string) {\n      this.location = location;\n      this.name = name;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitIdentifier(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Identifier) {\n        return this.name === other.name;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme variable definition.\n   * Returns nil.\n   */\n  export class Definition implements Expression {\n    location: Location;\n    name: Identifier;\n    value: Expression;\n    constructor(location: Location, name: Identifier, value: Expression) {\n      this.location = location;\n      this.name = name;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitDefinition(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Definition) {\n        return this.name.equals(other.name) && this.value.equals(other.value);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme function application.\n   */\n  export class Application implements Expression {\n    location: Location;\n    operator: Expression;\n    operands: Expression[];\n    constructor(\n      location: Location,\n      operator: Expression,\n      operands: Expression[]\n    ) {\n      this.location = location;\n      this.operator = operator;\n      this.operands = operands;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitApplication(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Application) {\n        if (!this.operator.equals(other.operator)) {\n          return false;\n        }\n        if (this.operands.length !== other.operands.length) {\n          return false;\n        }\n        for (let i = 0; i < this.operands.length; i++) {\n          if (!this.operands[i].equals(other.operands[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme conditional expression.\n   */\n  export class Conditional implements Expression {\n    location: Location;\n    test: Expression;\n    consequent: Expression;\n    alternate: Expression;\n    constructor(\n      location: Location,\n      test: Expression,\n      consequent: Expression,\n      alternate: Expression\n    ) {\n      this.location = location;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitConditional(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Conditional) {\n        return (\n          this.test.equals(other.test) &&\n          this.consequent.equals(other.consequent) &&\n          this.alternate.equals(other.alternate)\n        );\n      }\n      return false;\n    }\n  }\n\n  // Scheme chapter 2\n\n  /**\n   * A node representing a Scheme pair.\n   */\n  export class Pair implements Expression {\n    location: Location;\n    car: Expression;\n    cdr: Expression;\n    constructor(location: Location, car: Expression, cdr: Expression) {\n      this.location = location;\n      this.car = car;\n      this.cdr = cdr;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitPair(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Pair) {\n        return this.car.equals(other.car) && this.cdr.equals(other.cdr);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing nil, an empty scheme list.\n   */\n  export class Nil implements Expression {\n    location: Location;\n    constructor(location: Location) {\n      this.location = location;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitNil(this);\n    }\n    equals(other: Expression): boolean {\n      return other instanceof Nil;\n    }\n  }\n\n  /**\n   * A node representing a Scheme symbol.\n   */\n  export class Symbol implements Literal {\n    location: Location;\n    value: string;\n    constructor(location: Location, value: string) {\n      this.location = location;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitSymbol(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Symbol) {\n        return this.value === other.value;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme marker for unquote_splicing.\n   * This will be evaluated at runtime.\n   */\n  export class SpliceMarker implements Expression {\n    location: Location;\n    value: Expression;\n    constructor(location: Location, value: Expression) {\n      this.location = location;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitSpliceMarker(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof SpliceMarker) {\n        return this.value.equals(other.value);\n      }\n      return false;\n    }\n  }\n\n  // Scheme chapter 3\n\n  /**\n   * A node representing a Scheme variable reassignment.\n   * Only supposed to be used on a variable that has been defined.\n   * Returns nil.\n   */\n  export class Reassignment implements Expression {\n    location: Location;\n    name: Identifier;\n    value: Expression;\n    constructor(location: Location, name: Identifier, value: Expression) {\n      this.location = location;\n      this.name = name;\n      this.value = value;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitReassignment(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Reassignment) {\n        return this.name.equals(other.name) && this.value.equals(other.value);\n      }\n      return false;\n    }\n  }\n\n  // scm-slang specific\n\n  /**\n   * A node representing an import statement.\n   * syntax: (import <source> ( <identifier>* ))\n   * Returns nil.\n   */\n  export class Import implements Expression {\n    location: Location;\n    source: StringLiteral;\n    identifiers: Identifier[];\n    constructor(\n      location: Location,\n      source: StringLiteral,\n      identifiers: Identifier[]\n    ) {\n      this.location = location;\n      this.source = source;\n      this.identifiers = identifiers;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitImport(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Import) {\n        if (!this.source.equals(other.source)) {\n          return false;\n        }\n        if (this.identifiers.length !== other.identifiers.length) {\n          return false;\n        }\n        for (let i = 0; i < this.identifiers.length; i++) {\n          if (!this.identifiers[i].equals(other.identifiers[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing an export statement.\n   * syntax: (export ( <definition> ))\n   * Returns nil.\n   */\n  export class Export implements Expression {\n    location: Location;\n    definition: Definition | Extended.FunctionDefinition;\n    constructor(\n      location: Location,\n      definition: Definition | Extended.FunctionDefinition\n    ) {\n      this.location = location;\n      this.definition = definition;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitExport(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Export) {\n        return this.definition.equals(other.definition);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme Vector.\n   */\n  export class Vector implements Expression {\n    location: Location;\n    elements: Expression[];\n    constructor(location: Location, elements: Expression[]) {\n      this.location = location;\n      this.elements = elements;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitVector(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Vector) {\n        if (this.elements.length !== other.elements.length) {\n          return false;\n        }\n        for (let i = 0; i < this.elements.length; i++) {\n          if (!this.elements[i].equals(other.elements[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme define-syntax expression.\n   */\n  export class DefineSyntax implements Expression {\n    location: Location;\n    name: Identifier;\n    transformer: SyntaxRules;\n    constructor(\n      location: Location,\n      name: Identifier,\n      transformer: SyntaxRules\n    ) {\n      this.location = location;\n      this.name = name;\n      this.transformer = transformer;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitDefineSyntax(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof DefineSyntax) {\n        return (\n          this.name.equals(other.name) &&\n          this.transformer.equals(other.transformer)\n        );\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme syntax-rules expression.\n   */\n  export class SyntaxRules implements Expression {\n    location: Location;\n    literals: Symbol[];\n    rules: [Expression, Expression][];\n    constructor(\n      location: Location,\n      literals: Symbol[],\n      rules: [Expression, Expression][]\n    ) {\n      this.location = location;\n      this.literals = literals;\n      this.rules = rules;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitSyntaxRules(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof SyntaxRules) {\n        if (this.literals.length !== other.literals.length) {\n          return false;\n        }\n        for (let i = 0; i < this.literals.length; i++) {\n          if (!this.literals[i].equals(other.literals[i])) {\n            return false;\n          }\n        }\n        if (this.rules.length !== other.rules.length) {\n          return false;\n        }\n        for (let i = 0; i < this.rules.length; i++) {\n          if (\n            !this.rules[i][0].equals(other.rules[i][0]) ||\n            !this.rules[i][1].equals(other.rules[i][1])\n          ) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n}\n\n/**\n * The namespace for all the syntactic sugar node types.\n * Will be transformed into the bare minimum of Scheme syntax.\n * Eventually, we won't need this namespace, as all the syntactic sugar\n * will be converted by a macro system.\n */\nexport namespace Extended {\n  // Scheme chapter 1\n\n  /**\n   * A node representing a function definition.\n   */\n  export class FunctionDefinition implements Expression {\n    location: Location;\n    name: Atomic.Identifier;\n    params: Atomic.Identifier[];\n    rest?: Atomic.Identifier;\n    body: Expression;\n    constructor(\n      location: Location,\n      name: Atomic.Identifier,\n      body: Expression,\n      params: Atomic.Identifier[],\n      rest: Atomic.Identifier | undefined = undefined\n    ) {\n      this.location = location;\n      this.name = name;\n\n      this.body = body;\n      this.params = params;\n      this.rest = rest;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitFunctionDefinition(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof FunctionDefinition) {\n        if (this.params.length !== other.params.length) {\n          return false;\n        }\n        for (let i = 0; i < this.params.length; i++) {\n          if (!this.params[i].equals(other.params[i])) {\n            return false;\n          }\n        }\n        if (this.rest && other.rest) {\n          if (!this.rest.equals(other.rest)) {\n            return false;\n          }\n        } else if (this.rest || other.rest) {\n          return false;\n        }\n        return this.body.equals(other.body);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme let expression.\n   */\n  export class Let implements Expression {\n    location: Location;\n    identifiers: Atomic.Identifier[];\n    values: Expression[];\n    body: Expression;\n    constructor(\n      location: Location,\n      identifiers: Atomic.Identifier[],\n      values: Expression[],\n      body: Expression\n    ) {\n      this.location = location;\n      this.identifiers = identifiers;\n      this.values = values;\n      this.body = body;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitLet(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Let) {\n        if (this.identifiers.length !== other.identifiers.length) {\n          return false;\n        }\n        for (let i = 0; i < this.identifiers.length; i++) {\n          if (!this.identifiers[i].equals(other.identifiers[i])) {\n            return false;\n          }\n        }\n        if (this.values.length !== other.values.length) {\n          return false;\n        }\n        for (let i = 0; i < this.values.length; i++) {\n          if (!this.values[i].equals(other.values[i])) {\n            return false;\n          }\n        }\n        return this.body.equals(other.body);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme cond expression.\n   * MAY return nil.\n   */\n  export class Cond implements Expression {\n    location: Location;\n    predicates: Expression[];\n    consequents: Expression[];\n    catchall: Expression | undefined;\n    constructor(\n      location: Location,\n      predicates: Expression[],\n      consequents: Expression[],\n      catchall?: Expression\n    ) {\n      this.location = location;\n      this.predicates = predicates;\n      this.consequents = consequents;\n      this.catchall = catchall;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitCond(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Cond) {\n        if (this.predicates.length !== other.predicates.length) {\n          return false;\n        }\n        for (let i = 0; i < this.predicates.length; i++) {\n          if (!this.predicates[i].equals(other.predicates[i])) {\n            return false;\n          }\n        }\n        if (this.consequents.length !== other.consequents.length) {\n          return false;\n        }\n        for (let i = 0; i < this.consequents.length; i++) {\n          if (!this.consequents[i].equals(other.consequents[i])) {\n            return false;\n          }\n        }\n        if (this.catchall && other.catchall) {\n          return this.catchall.equals(other.catchall);\n        } else if (this.catchall || other.catchall) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  // Scheme chapter 2\n\n  /**\n   * A node representing a Scheme list or dotted list.\n   */\n  export class List implements Expression {\n    location: Location;\n    elements: Expression[];\n    terminator: Expression | undefined;\n    constructor(\n      location: Location,\n      elements: Expression[],\n      terminator: Expression | undefined = undefined\n    ) {\n      this.location = location;\n      this.elements = elements;\n      this.terminator = terminator;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitList(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof List) {\n        if (this.elements.length !== other.elements.length) {\n          return false;\n        }\n        for (let i = 0; i < this.elements.length; i++) {\n          if (!this.elements[i].equals(other.elements[i])) {\n            return false;\n          }\n        }\n        if (this.terminator && other.terminator) {\n          return this.terminator.equals(other.terminator);\n        } else if (this.terminator || other.terminator) {\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  // Scheme chapter 3\n\n  /**\n   * A node representing a Scheme begin expression.\n   * Returns the last expression.\n   * syntax: (begin <expression>*)\n   */\n  export class Begin implements Expression {\n    location: Location;\n    expressions: Expression[];\n    constructor(location: Location, expressions: Expression[]) {\n      this.location = location;\n      this.expressions = expressions;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitBegin(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Begin) {\n        if (this.expressions.length !== other.expressions.length) {\n          return false;\n        }\n        for (let i = 0; i < this.expressions.length; i++) {\n          if (!this.expressions[i].equals(other.expressions[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * A node representing a Scheme delay expression.\n   * Returns a promise.\n   * syntax: (delay <expression>)\n   */\n  export class Delay implements Expression {\n    location: Location;\n    expression: Expression;\n    constructor(location: Location, expression: Expression) {\n      this.location = location;\n      this.expression = expression;\n    }\n    accept(visitor: Visitor): any {\n      return visitor.visitDelay(this);\n    }\n    equals(other: Expression): boolean {\n      if (other instanceof Delay) {\n        return this.expression.equals(other.expression);\n      }\n      return false;\n    }\n  }\n}\n\n","import { Position } from \"../types/location\";\n\nexport abstract class LexerError extends SyntaxError {\n  // This base error shouldn't be used directly.\n  loc: Position;\n  constructor(message: string, line: number, col: number) {\n    super(message);\n    this.loc = {\n      line: line,\n      column: col,\n    };\n  }\n  toString(): string {\n    return this.message;\n  }\n}\n\nexport class UnexpectedCharacterError extends LexerError {\n  char: string;\n  constructor(line: number, col: number, char: string) {\n    super(`Unexpected character \\'${char}\\' (${line}:${col})`, line, col);\n    this.char = char;\n    this.name = \"UnexpectedCharacterError\";\n  }\n}\n\nexport class UnexpectedEOFError extends LexerError {\n  constructor(line: number, col: number) {\n    super(`Unexpected EOF (${line}:${col})`, line, col);\n    this.name = \"UnexpectedEOFError\";\n  }\n}\n","// Thanks to Ken Jin (py-slang) for the great resource\n// https://craftinginterpreters.com/scanning.html\n// This tokenizer/lexer is a modified version, inspired by both the\n// tokenizer/lexer above as well as Ken Jin's py-slang tokenizer/lexer.\n// It has been adapted to be written in typescript for scheme.\n// Crafting Interpreters: https://craftinginterpreters.com/\n// py-slang: https://github.com/source-academy/py-slang\n\nimport { stringIsSchemeNumber } from \"../../core-math\";\nimport { Token } from \"../types/tokens/token\";\nimport { TokenType } from \"../types/tokens/token-type\";\nimport { Lexer } from \"./lexer\";\nimport * as LexerError from \"./lexer-error\";\n\n// syntactic keywords in the scheme language\nlet keywords = new Map<string, TokenType>([\n  [\".\", TokenType.DOT],\n  [\"if\", TokenType.IF],\n  [\"let\", TokenType.LET],\n  [\"cond\", TokenType.COND],\n  [\"else\", TokenType.ELSE],\n  [\"set!\", TokenType.SET],\n  [\"begin\", TokenType.BEGIN],\n  [\"delay\", TokenType.DELAY],\n  [\"quote\", TokenType.QUOTE],\n  [\"export\", TokenType.EXPORT],\n  [\"import\", TokenType.IMPORT],\n  [\"define\", TokenType.DEFINE],\n  [\"lambda\", TokenType.LAMBDA],\n  [\"define-syntax\", TokenType.DEFINE_SYNTAX],\n  [\"syntax-rules\", TokenType.SYNTAX_RULES],\n]);\n\nexport class SchemeLexer implements Lexer {\n  private readonly source: string;\n  private readonly tokens: Token[];\n  private start: number = 0;\n  private current: number = 0;\n  private line: number = 1;\n  private col: number = 0;\n\n  constructor(source: string) {\n    this.source = source;\n    this.tokens = [];\n  }\n\n  private isAtEnd(): boolean {\n    return this.current >= this.source.length;\n  }\n\n  private advance(): string {\n    // get the next character\n    this.col++;\n    return this.source.charAt(this.current++);\n  }\n\n  private jump(): void {\n    // when you want to ignore a character\n    this.start = this.current;\n    this.col++;\n    this.current++;\n  }\n\n  private addToken(type: TokenType): void;\n  private addToken(type: TokenType, literal: any): void;\n  private addToken(type: TokenType, literal: any = null): void {\n    const text = this.source.substring(this.start, this.current);\n    this.tokens.push(\n      new Token(\n        type,\n        text,\n        literal,\n        this.start,\n        this.current,\n        this.line,\n        this.col\n      )\n    );\n  }\n\n  public scanTokens(): Token[] {\n    while (!this.isAtEnd()) {\n      this.start = this.current;\n      this.scanToken();\n    }\n\n    this.tokens.push(\n      new Token(\n        TokenType.EOF,\n        \"\",\n        null,\n        this.start,\n        this.current,\n        this.line,\n        this.col\n      )\n    );\n    return this.tokens;\n  }\n\n  private scanToken(): void {\n    const c = this.advance();\n    switch (c) {\n      case \"(\":\n        this.addToken(TokenType.LEFT_PAREN);\n        break;\n      case \")\":\n        this.addToken(TokenType.RIGHT_PAREN);\n        break;\n      case \"[\":\n        this.addToken(TokenType.LEFT_BRACKET);\n        break;\n      case \"]\":\n        this.addToken(TokenType.RIGHT_BRACKET);\n        break;\n      case \"'\":\n        this.addToken(TokenType.APOSTROPHE);\n        break;\n      case \"`\":\n        this.addToken(TokenType.BACKTICK);\n        break;\n      case \",\":\n        if (this.match(\"@\")) {\n          this.addToken(TokenType.COMMA_AT);\n          break;\n        }\n        this.addToken(TokenType.COMMA);\n        break;\n      case \"#\":\n        // by itself, it is an error\n        if (this.match(\"t\") || this.match(\"f\")) {\n          this.booleanToken();\n        } else if (this.match(\"|\")) {\n          // a multiline comment\n          this.comment();\n        } else if (this.match(\";\")) {\n          // a datum comment\n          this.addToken(TokenType.HASH_SEMICOLON);\n        } else if (this.peek() === \"(\" || this.peek() === \"[\") {\n          // We keep the hash character and the parenthesis/bracket\n          // separate as our parentheses matching systems\n          // will suffer with 4 possible left grouping tokens!\n\n          // ensure that the next character is a vector\n          this.addToken(TokenType.HASH_VECTOR);\n        } else {\n          // chars are not currently supported\n          throw new LexerError.UnexpectedCharacterError(this.line, this.col, c);\n        }\n        break;\n      case \";\":\n        // a comment\n        while (this.peek() != \"\\n\" && !this.isAtEnd()) this.advance();\n        break;\n      // double character tokens not currently needed\n      case \" \":\n      case \"\\r\":\n      case \"\\t\":\n        // ignore whitespace\n        break;\n      case \"\\n\":\n        this.line++;\n        this.col = 0;\n        break;\n      case '\"':\n        this.stringToken();\n        break;\n      case \"|\":\n        this.identifierTokenLoose();\n        break;\n      default:\n        // Deviates slightly from the original lexer.\n        // Scheme allows for identifiers to start with a digit\n        // or include a specific set of symbols.\n        if (\n          this.isDigit(c) ||\n          c === \"-\" ||\n          c === \"+\" ||\n          c === \".\" ||\n          c === \"i\" || // inf\n          c === \"n\" // nan\n        ) {\n          // may or may not be a number\n          this.identifierNumberToken();\n        } else if (this.isValidIdentifier(c)) {\n          // filtered out the potential numbers\n          // these are definitely identifiers\n          this.identifierToken();\n        } else {\n          throw new LexerError.UnexpectedCharacterError(this.line, this.col, c);\n        }\n        break;\n    }\n  }\n\n  private comment(): void {\n    while (!(this.peek() == \"|\" && this.peekNext() == \"#\") && !this.isAtEnd()) {\n      if (this.peek() === \"\\n\") {\n        this.line++;\n        this.col = 0;\n      }\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      throw new LexerError.UnexpectedEOFError(this.line, this.col);\n    }\n\n    this.jump();\n    this.jump();\n  }\n\n  private identifierToken(): void {\n    while (this.isValidIdentifier(this.peek())) this.advance();\n    this.addToken(this.checkKeyword());\n  }\n\n  private identifierTokenLoose(): void {\n    // this is a special case for identifiers\n    // add the first |\n    this.advance();\n    while (this.peek() != \"|\" && !this.isAtEnd()) {\n      if (this.peek() === \"\\n\") {\n        this.line++;\n        this.col = 0;\n      }\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      throw new LexerError.UnexpectedEOFError(this.line, this.col);\n    }\n\n    // add the last |\n    this.advance();\n\n    this.addToken(this.checkKeyword());\n  }\n\n  private identifierNumberToken(): void {\n    // we first obtain the entire identifier\n    while (this.isValidIdentifier(this.peek())) {\n      this.advance();\n    }\n    const lexeme = this.source.substring(this.start, this.current);\n    if (stringIsSchemeNumber(lexeme)) {\n      this.addToken(TokenType.NUMBER, lexeme);\n      return;\n    }\n    this.addToken(this.checkKeyword());\n  }\n\n  private checkKeyword(): TokenType {\n    var text = this.source.substring(this.start, this.current);\n    if (keywords.has(text)) {\n      return keywords.get(text) as TokenType;\n    }\n    return TokenType.IDENTIFIER;\n  }\n\n  private stringToken(): void {\n    while (this.peek() != '\"' && !this.isAtEnd()) {\n      if (this.peek() === \"\\n\") {\n        this.line++;\n        this.col = 0;\n      }\n      this.advance();\n    }\n\n    if (this.isAtEnd()) {\n      throw new LexerError.UnexpectedEOFError(this.line, this.col);\n    }\n\n    // closing \"\n    this.advance();\n\n    // trim the surrounding quotes\n    const value = this.source.substring(this.start + 1, this.current - 1);\n    this.addToken(TokenType.STRING, value);\n  }\n\n  private booleanToken(): void {\n    this.addToken(TokenType.BOOLEAN, this.peekPrev() === \"t\" ? true : false);\n  }\n\n  private match(expected: string): boolean {\n    if (this.isAtEnd()) return false;\n    if (this.source.charAt(this.current) != expected) return false;\n    this.current++;\n    return true;\n  }\n\n  private peek(): string {\n    if (this.isAtEnd()) return \"\\0\";\n    return this.source.charAt(this.current);\n  }\n\n  private peekNext(): string {\n    if (this.current + 1 >= this.source.length) return \"\\0\";\n    return this.source.charAt(this.current + 1);\n  }\n\n  private peekPrev(): string {\n    if (this.current - 1 < 0) return \"\\0\";\n    return this.source.charAt(this.current - 1);\n  }\n\n  private isDigit(c: string): boolean {\n    return c >= \"0\" && c <= \"9\";\n  }\n\n  private isSpecialSyntax(c: string): boolean {\n    return (\n      c === \"(\" || c === \")\" || c === \"[\" || c === \"]\" || c === \";\" || c === \"|\"\n    );\n  }\n\n  private isValidIdentifier(c: string): boolean {\n    return !this.isWhitespace(c) && !this.isSpecialSyntax(c);\n  }\n\n  private isWhitespace(c: string): boolean {\n    return c === \" \" || c === \"\\0\" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n}\n","// The chapters of the parser.\n\nexport const BASIC_CHAPTER = 1;\nexport const QUOTING_CHAPTER = 2;\nexport const VECTOR_CHAPTER = 3;\nexport const MUTABLE_CHAPTER = 3;\nexport const MACRO_CHAPTER = 5;\n","import { Token } from \"../types/tokens/token\";\nimport { TokenType } from \"../types/tokens/token-type\";\nimport { Location } from \"../types/location\";\nimport { Atomic, Expression, Extended } from \"../types/nodes/scheme-node-types\";\nimport * as ParserError from \"./parser-error\";\nimport { Datum } from \"../types/tokens/datum\";\nimport { Group } from \"../types/tokens/group\";\nimport { Parser } from \"./parser\";\nimport { isGroup, isToken } from \"../types/tokens\";\nimport {\n  BASIC_CHAPTER,\n  MACRO_CHAPTER,\n  MUTABLE_CHAPTER,\n  QUOTING_CHAPTER,\n  VECTOR_CHAPTER,\n} from \"../types/constants\";\n\n/**\n * An enum representing the current quoting mode of the parser.\n */\nenum QuoteMode {\n  NONE,\n  QUOTE,\n  QUASIQUOTE,\n}\n\nexport class SchemeParser implements Parser {\n  private readonly source: string;\n  private readonly tokens: Token[];\n  private readonly chapter: number;\n  private current: number = 0;\n  private quoteMode: QuoteMode = QuoteMode.NONE;\n\n  constructor(source: string, tokens: Token[], chapter: number = Infinity) {\n    this.source = source;\n    this.tokens = tokens;\n    this.chapter = chapter;\n  }\n\n  private advance(): Token {\n    if (!this.isAtEnd()) this.current++;\n    return this.previous();\n  }\n\n  private isAtEnd(): boolean {\n    return this.current >= this.tokens.length;\n  }\n\n  private previous(): Token {\n    return this.tokens[this.current - 1];\n  }\n\n  private peek(): Token {\n    return this.tokens[this.current];\n  }\n\n  private validateChapter(c: Token, chapter: number): void {\n    if (this.chapter < chapter) {\n      throw new ParserError.DisallowedTokenError(\n        this.source,\n        c.pos,\n        c,\n        this.chapter\n      );\n    }\n  }\n\n  /**\n   * Returns the location of a token.\n   * @param token A token.\n   * @returns The location of the token.\n   */\n  private toLocation(token: Token): Location {\n    return new Location(token.pos, token.endPos);\n  }\n\n  /**\n   * Helper function used to destructure a list into its elements and terminator.\n   * An optional verifier is used if there are restrictions on the elements of the list.\n   */\n  private destructureList(\n    list: Datum[],\n    verifier = (_x: any) => {}\n  ): [Expression[], Expression | undefined] {\n    // check if the list is an empty list\n    if (list.length === 0) {\n      return [[], undefined];\n    }\n\n    // check if the list is a list of length 1\n    if (list.length === 1) {\n      verifier(list[0]);\n      return [[this.parseExpression(list[0])], undefined];\n    }\n\n    // we now know that the list is at least of length 2\n\n    // check for a dotted list\n    // it is if the second last element is a dot\n    const potentialDot = list.at(-2) as Datum;\n\n    if (isToken(potentialDot) && potentialDot.type === TokenType.DOT) {\n      const cdrElement = list.at(-1)!;\n      const listElements = list.slice(0, -2);\n      verifier(cdrElement);\n      listElements.forEach(verifier);\n      return [\n        listElements.map(this.parseExpression.bind(this)),\n        this.parseExpression(cdrElement),\n      ];\n    }\n\n    // we now know that it is a proper list\n    const listElements = list;\n    listElements.forEach(verifier);\n    return [listElements.map(this.parseExpression.bind(this)), undefined];\n  }\n\n  /**\n   * Returns a group of associated tokens.\n   * Tokens are grouped by level of parentheses.\n   *\n   * @param openparen The opening parenthesis, if one exists.\n   * @returns A group of tokens or groups of tokens.\n   */\n  private grouping(openparen?: Token): Group | undefined {\n    const elements: Datum[] = [];\n    let inList = false;\n    if (openparen) {\n      inList = true;\n      elements.push(openparen);\n    }\n    do {\n      let c = this.advance();\n      switch (c.type) {\n        case TokenType.LEFT_PAREN:\n        case TokenType.LEFT_BRACKET:\n          // the next group is not empty, especially because it\n          // has an open parenthesis\n          const innerGroup = this.grouping(c) as Group;\n          elements.push(innerGroup);\n          break;\n        case TokenType.RIGHT_PAREN:\n        case TokenType.RIGHT_BRACKET:\n          if (!inList) {\n            throw new ParserError.UnexpectedFormError(this.source, c.pos, c);\n          }\n          // add the parenthesis to the current group\n          elements.push(c);\n          inList = false;\n          break;\n        case TokenType.APOSTROPHE: // Quoting syntax (short form)\n        case TokenType.BACKTICK:\n        case TokenType.COMMA:\n        case TokenType.COMMA_AT:\n        case TokenType.HASH_VECTOR: // Vector syntax\n          // these cases modify only the next element\n          // so we group up the next element and use this\n          // token on it\n          let nextGrouping;\n          do {\n            nextGrouping = this.grouping();\n          } while (!nextGrouping);\n          elements.push(this.affect(c, nextGrouping));\n          break;\n        case TokenType.QUOTE: // Quoting syntax\n        case TokenType.QUASIQUOTE:\n        case TokenType.UNQUOTE:\n        case TokenType.UNQUOTE_SPLICING:\n        case TokenType.IDENTIFIER: // Atomics\n        case TokenType.NUMBER:\n        case TokenType.BOOLEAN:\n        case TokenType.STRING:\n        case TokenType.DOT:\n\n        case TokenType.DEFINE: // Chapter 1\n        case TokenType.IF:\n        case TokenType.ELSE:\n        case TokenType.COND:\n        case TokenType.LAMBDA:\n        case TokenType.LET:\n        case TokenType.SET: // Chapter 3\n        case TokenType.BEGIN:\n        case TokenType.DELAY:\n        case TokenType.IMPORT:\n        case TokenType.EXPORT:\n        case TokenType.DEFINE_SYNTAX:\n        case TokenType.SYNTAX_RULES: // Chapter 4\n          elements.push(c);\n          break;\n        case TokenType.HASH_SEMICOLON:\n          // a datum comment\n          // get the next NON-EMPTY grouping\n          // and ignore it\n          while (!this.grouping()) {}\n          break;\n        case TokenType.EOF:\n          // We should be unable to reach this point at top level as parse()\n          // should prevent the grouping of the singular EOF token.\n          // However, with any element that ranges beyond the end of the\n          // file without its corresponding delemiter, we can reach this point.\n          throw new ParserError.UnexpectedEOFError(this.source, c.pos);\n        default:\n          throw new ParserError.UnexpectedFormError(this.source, c.pos, c);\n      }\n    } while (inList);\n    if (elements.length === 0) {\n      return;\n    }\n\n    try {\n      return Group.build(elements);\n    } catch (e) {\n      if (e instanceof ParserError.ExpectedFormError) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          e.loc,\n          e.form,\n          e.expected\n        );\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Groups an affector token with its target.\n   */\n  private affect(affector: Token, target: Datum): Group {\n    return Group.build([affector, target]);\n  }\n\n  /**\n   * Parse an expression.\n   * @param expr A token or a group of tokens.\n   * @returns\n   */\n  private parseExpression(expr: Datum): Expression {\n    // Discern the type of expression\n    if (isToken(expr)) {\n      return this.parseToken(expr);\n    }\n\n    // We now know it is a group\n\n    // Due to group invariants we can determine if it represents a\n    // single token instead\n    if (expr.isSingleIdentifier()) {\n      return this.parseToken(expr.unwrap()[0] as Token);\n    }\n\n    return this.parseGroup(expr);\n  }\n\n  private parseToken(token: Token): Expression {\n    switch (token.type) {\n      case TokenType.IDENTIFIER:\n        return this.quoteMode === QuoteMode.NONE\n          ? new Atomic.Identifier(this.toLocation(token), token.lexeme)\n          : new Atomic.Symbol(this.toLocation(token), token.lexeme);\n      // all of these are self evaluating, and so can be left alone regardless of quote mode\n      case TokenType.NUMBER:\n        return new Atomic.NumericLiteral(\n          this.toLocation(token),\n          token.literal as string\n        );\n      case TokenType.BOOLEAN:\n        return new Atomic.BooleanLiteral(\n          this.toLocation(token),\n          token.literal as boolean\n        );\n      case TokenType.STRING:\n        return new Atomic.StringLiteral(\n          this.toLocation(token),\n          token.literal as string\n        );\n      default:\n        // if in a quoting context, or when dealing with the macro chapter,\n        // any keyword is instead treated as a symbol\n        if (\n          this.quoteMode !== QuoteMode.NONE ||\n          this.chapter >= MACRO_CHAPTER\n        ) {\n          return new Atomic.Symbol(this.toLocation(token), token.lexeme);\n        }\n        throw new ParserError.UnexpectedFormError(\n          this.source,\n          token.pos,\n          token\n        );\n    }\n  }\n\n  private parseGroup(group: Group): Expression {\n    // No need to check if group represents a single token as well\n    if (!group.isParenthesized()) {\n      // The only case left is the unparenthesized case\n      // of a single affector token and a target group\n      // Form: <affector token> <group>\n      return this.parseAffectorGroup(group);\n    }\n    // Now we have fallen through to the generic group\n    // case - a parenthesized group of tokens.\n    switch (this.quoteMode) {\n      case QuoteMode.NONE:\n        return this.parseNormalGroup(group);\n      case QuoteMode.QUOTE:\n      case QuoteMode.QUASIQUOTE:\n        return this.parseQuotedGroup(group);\n    }\n  }\n\n  /**\n   * Parse a group of tokens affected by an affector.\n   * Important case as affector changes quotation mode.\n   *\n   * @param group A group of tokens, verified to be an affector and a target.\n   * @returns An expression.\n   */\n  parseAffectorGroup(group: Group): Expression {\n    const [affector, target] = group.unwrap();\n    // Safe to cast affector due to group invariants\n    switch ((<Token>affector).type) {\n      case TokenType.APOSTROPHE:\n      case TokenType.QUOTE:\n        this.validateChapter(<Token>affector, QUOTING_CHAPTER);\n        if (this.quoteMode !== QuoteMode.NONE) {\n          const innerGroup = this.parseExpression(target);\n          const newSymbol = new Atomic.Symbol(\n            this.toLocation(<Token>affector),\n            \"quote\"\n          );\n\n          const newLocation = newSymbol.location.merge(innerGroup.location);\n          // wrap the entire expression in a list\n          return new Extended.List(newLocation, [newSymbol, innerGroup]);\n        }\n        this.quoteMode = QuoteMode.QUOTE;\n        const quotedExpression = this.parseExpression(target);\n        this.quoteMode = QuoteMode.NONE;\n        return quotedExpression;\n      case TokenType.BACKTICK:\n      case TokenType.QUASIQUOTE:\n        this.validateChapter(<Token>affector, QUOTING_CHAPTER);\n        if (this.quoteMode !== QuoteMode.NONE) {\n          const innerGroup = this.parseExpression(target);\n          const newSymbol = new Atomic.Symbol(\n            this.toLocation(<Token>affector),\n            \"quasiquote\"\n          );\n\n          const newLocation = newSymbol.location.merge(innerGroup.location);\n          // wrap the entire expression in a list\n          return new Extended.List(newLocation, [newSymbol, innerGroup]);\n        }\n        this.quoteMode = QuoteMode.QUASIQUOTE;\n        const quasiquotedExpression = this.parseExpression(target);\n        this.quoteMode = QuoteMode.NONE;\n        return quasiquotedExpression;\n      case TokenType.COMMA:\n      case TokenType.UNQUOTE:\n        this.validateChapter(<Token>affector, QUOTING_CHAPTER);\n        let preUnquoteMode = this.quoteMode;\n        if (preUnquoteMode === QuoteMode.NONE) {\n          throw new ParserError.UnsupportedTokenError(\n            this.source,\n            (<Token>affector).pos,\n            <Token>affector\n          );\n        }\n        if (preUnquoteMode === QuoteMode.QUOTE) {\n          const innerGroup = this.parseExpression(target);\n          const newSymbol = new Atomic.Symbol(\n            this.toLocation(<Token>affector),\n            \"unquote\"\n          );\n\n          const newLocation = newSymbol.location.merge(innerGroup.location);\n          // wrap the entire expression in a list\n          return new Extended.List(newLocation, [newSymbol, innerGroup]);\n        }\n        this.quoteMode = QuoteMode.NONE;\n        const unquotedExpression = this.parseExpression(target);\n        this.quoteMode = preUnquoteMode;\n        return unquotedExpression;\n      case TokenType.COMMA_AT:\n      case TokenType.UNQUOTE_SPLICING:\n        this.validateChapter(<Token>affector, QUOTING_CHAPTER);\n        let preUnquoteSplicingMode = this.quoteMode;\n        if (preUnquoteSplicingMode === QuoteMode.NONE) {\n          throw new ParserError.UnexpectedFormError(\n            this.source,\n            (<Token>affector).pos,\n            <Token>affector\n          );\n        }\n        if (preUnquoteSplicingMode === QuoteMode.QUOTE) {\n          const innerGroup = this.parseExpression(target);\n          const newSymbol = new Atomic.Symbol(\n            this.toLocation(<Token>affector),\n            \"unquote-splicing\"\n          );\n\n          const newLocation = newSymbol.location.merge(innerGroup.location);\n          // wrap the entire expression in a list\n          return new Extended.List(newLocation, [newSymbol, innerGroup]);\n        }\n        this.quoteMode = QuoteMode.NONE;\n        const unquoteSplicedExpression = this.parseExpression(target);\n        this.quoteMode = preUnquoteSplicingMode;\n        const newLocation = this.toLocation(<Token>affector).merge(\n          unquoteSplicedExpression.location\n        );\n        return new Atomic.SpliceMarker(newLocation, unquoteSplicedExpression);\n      case TokenType.HASH_VECTOR:\n        // vectors quote over all elements inside.\n        this.validateChapter(<Token>affector, VECTOR_CHAPTER);\n        let preVectorQuoteMode = this.quoteMode;\n        this.quoteMode = QuoteMode.QUOTE;\n        const vector = this.parseVector(group);\n        this.quoteMode = preVectorQuoteMode;\n        return vector;\n      default:\n        throw new ParserError.UnexpectedFormError(\n          this.source,\n          (<Token>affector).pos,\n          <Token>affector\n        );\n    }\n  }\n\n  private parseNormalGroup(group: Group): Expression {\n    // it is an error if the group is empty in a normal context\n    if (group.length() === 0) {\n      if (this.chapter >= MACRO_CHAPTER) {\n        // disable any verification for the empty group\n        // the CSET machine will verify its validity\n        return new Atomic.Nil(group.location);\n      }\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"non-empty group\"\n      );\n    }\n\n    // get the first element\n    const firstElement = group.unwrap()[0];\n\n    // If the first element is a token, it may be a keyword or a procedure call\n    if (isToken(firstElement)) {\n      switch (firstElement.type) {\n        // Scheme chapter 1\n        case TokenType.LAMBDA:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseLambda(group);\n        case TokenType.DEFINE:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseDefinition(group);\n        case TokenType.IF:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseConditional(group);\n        case TokenType.LET:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseLet(group);\n        case TokenType.COND:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseExtendedCond(group);\n\n        // Scheme chapter 2\n        case TokenType.QUOTE:\n        case TokenType.APOSTROPHE:\n        case TokenType.QUASIQUOTE:\n        case TokenType.BACKTICK:\n        case TokenType.UNQUOTE:\n        case TokenType.COMMA:\n        case TokenType.UNQUOTE_SPLICING:\n        case TokenType.COMMA_AT:\n          this.validateChapter(firstElement, QUOTING_CHAPTER);\n          // we can reuse the affector group method to control the quote mode\n          return this.parseAffectorGroup(group);\n\n        // Scheme chapter 3\n        case TokenType.BEGIN:\n          this.validateChapter(firstElement, MUTABLE_CHAPTER);\n          return this.parseBegin(group);\n        case TokenType.DELAY:\n          this.validateChapter(firstElement, MUTABLE_CHAPTER);\n          return this.parseDelay(group);\n        case TokenType.SET:\n          this.validateChapter(firstElement, MUTABLE_CHAPTER);\n          return this.parseSet(group);\n\n        // Scheme full (macros)\n        case TokenType.DEFINE_SYNTAX:\n          this.validateChapter(firstElement, MACRO_CHAPTER);\n          return this.parseDefineSyntax(group);\n        case TokenType.SYNTAX_RULES:\n          // should not be called outside of define-syntax!\n          throw new ParserError.UnexpectedFormError(\n            this.source,\n            firstElement.pos,\n            firstElement\n          );\n\n        // Scm-slang misc\n        case TokenType.IMPORT:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseImport(group);\n        case TokenType.EXPORT:\n          this.validateChapter(firstElement, BASIC_CHAPTER);\n          return this.parseExport(group);\n        case TokenType.VECTOR:\n          this.validateChapter(firstElement, VECTOR_CHAPTER);\n          // same as above, this is an affector group\n          return this.parseAffectorGroup(group);\n\n        default:\n          // It's a procedure call\n          return this.parseApplication(group);\n      }\n    }\n    // Form: (<group> <expr>*)\n    // It's a procedure call\n    return this.parseApplication(group);\n  }\n\n  /**\n   * We are parsing a list/dotted list.\n   */\n  private parseQuotedGroup(group: Group): Expression {\n    // check if the group is an empty list\n    if (group.length() === 0) {\n      return new Atomic.Nil(group.location);\n    }\n\n    // check if the group is a list of length 1\n    if (group.length() === 1) {\n      const elem = [this.parseExpression(group.unwrap()[0])];\n      return new Extended.List(group.location, elem);\n    }\n\n    // we now know that the group is at least of length 2\n\n    const groupElements = group.unwrap();\n\n    const [listElements, cdrElement] = this.destructureList(groupElements);\n\n    return new Extended.List(group.location, listElements, cdrElement);\n  }\n\n  // _____________________CHAPTER 1_____________________\n\n  /**\n   * Parse a lambda expression.\n   * @param group\n   * @returns\n   */\n  private parseLambda(group: Group): Atomic.Lambda {\n    // Form: (lambda (<identifier>*) <body>+)\n    //     | (lambda (<identifier>* . <rest-identifier>) <body>+)\n    // ensure that the group has at least 3 elements\n    if (group.length() < 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(lambda (<identifier>* . <rest-identifier>?) <body>+) | (lambda <rest-identifer> <body>+)\"\n      );\n    }\n    const elements = group.unwrap();\n    const formals = elements[1];\n    const body = elements.slice(2);\n\n    // Formals should be a group of identifiers or a single identifier\n    let convertedFormals: Atomic.Identifier[] = [];\n    // if a rest element is detected,\n    let convertedRest: Atomic.Identifier | undefined = undefined;\n    if (isToken(formals)) {\n      if (formals.type !== TokenType.IDENTIFIER) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          formals.pos,\n          formals,\n          \"<rest-identifier>\"\n        );\n      }\n      convertedRest = new Atomic.Identifier(\n        this.toLocation(formals),\n        formals.lexeme\n      );\n    } else {\n      // it is a group\n      const formalsElements = formals.unwrap();\n      [convertedFormals, convertedRest] = this.destructureList(\n        formalsElements,\n        // pass in a verifier that checks if the elements are identifiers\n        formal => {\n          if (!isToken(formal)) {\n            throw new ParserError.ExpectedFormError(\n              this.source,\n              formal.pos,\n              formal,\n              \"<identifier>\"\n            );\n          }\n          if (formal.type !== TokenType.IDENTIFIER) {\n            throw new ParserError.ExpectedFormError(\n              this.source,\n              formal.pos,\n              formal,\n              \"<identifier>\"\n            );\n          }\n        }\n      ) as [Atomic.Identifier[], Atomic.Identifier | undefined];\n    }\n\n    // Body is treated as a group of expressions\n    const convertedBody = body.map(\n      this.parseExpression.bind(this)\n    ) as Expression[];\n\n    // assert that body is not empty\n    if (convertedBody.length < 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(lambda ... <body>+)\"\n      );\n    }\n\n    if (convertedBody.length === 1) {\n      return new Atomic.Lambda(\n        group.location,\n        convertedBody[0],\n        convertedFormals,\n        convertedRest\n      );\n    }\n\n    const newLocation = convertedBody\n      .at(0)!\n      .location.merge(convertedBody.at(-1)!.location);\n    const bodySequence = new Atomic.Sequence(newLocation, convertedBody);\n    return new Atomic.Lambda(\n      group.location,\n      bodySequence,\n      convertedFormals,\n      convertedRest\n    );\n  }\n\n  /**\n   * Parse a define expression.\n   * @param group\n   * @returns\n   */\n  private parseDefinition(\n    group: Group\n  ): Atomic.Definition | Extended.FunctionDefinition {\n    // Form: (define <identifier> <expr>)\n    //     | (define (<identifier> <formals>) <body>)\n    //     | (define (<identifier> <formals>) <body> <body>*)\n    // ensure that the group has at least 3 elements\n    if (group.length() < 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(define <identifier> <expr>) | (define (<identifier> <formals>) <body>+)\"\n      );\n    }\n    const elements = group.unwrap();\n    const identifier = elements[1];\n    const expr = elements.slice(2);\n\n    let convertedIdentifier: Atomic.Identifier;\n    let convertedFormals: Atomic.Identifier[] = [];\n    let convertedRest: Atomic.Identifier | undefined = undefined;\n    let isFunctionDefinition = false;\n\n    // Identifier may be a token or a group of identifiers\n    if (isGroup(identifier)) {\n      // its a function definition\n      isFunctionDefinition = true;\n      const identifierElements = identifier.unwrap();\n      const functionName = identifierElements[0];\n      const formals = identifierElements.splice(1);\n\n      // verify that the first element is an identifier\n      if (!isToken(functionName)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          functionName.location.start,\n          functionName,\n          \"<identifier>\"\n        );\n      }\n      if (functionName.type !== TokenType.IDENTIFIER) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          functionName.pos,\n          functionName,\n          \"<identifier>\"\n        );\n      }\n\n      // convert the first element to an identifier\n      convertedIdentifier = new Atomic.Identifier(\n        this.toLocation(functionName),\n        functionName.lexeme\n      );\n\n      // Formals should be a group of identifiers\n      [convertedFormals, convertedRest] = this.destructureList(\n        formals,\n        formal => {\n          if (!isToken(formal)) {\n            throw new ParserError.ExpectedFormError(\n              this.source,\n              formal.pos,\n              formal,\n              \"<identifier>\"\n            );\n          }\n          if (formal.type !== TokenType.IDENTIFIER) {\n            throw new ParserError.ExpectedFormError(\n              this.source,\n              formal.pos,\n              formal,\n              \"<identifier>\"\n            );\n          }\n        }\n      ) as [Atomic.Identifier[], Atomic.Identifier | undefined];\n    } else if (identifier.type !== TokenType.IDENTIFIER) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        identifier.pos,\n        identifier,\n        \"<identifier>\"\n      );\n    } else {\n      // its a normal definition\n      convertedIdentifier = new Atomic.Identifier(\n        this.toLocation(identifier),\n        identifier.lexeme\n      );\n      isFunctionDefinition = false;\n    }\n\n    // expr cannot be empty\n    if (expr.length < 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(define ... <body>+)\"\n      );\n    }\n\n    if (isFunctionDefinition) {\n      // Body is treated as a group of expressions\n      const convertedBody = expr.map(\n        this.parseExpression.bind(this)\n      ) as Expression[];\n\n      if (convertedBody.length === 1) {\n        return new Extended.FunctionDefinition(\n          group.location,\n          convertedIdentifier,\n          convertedBody[0],\n          convertedFormals,\n          convertedRest\n        );\n      }\n\n      const newLocation = convertedBody\n        .at(0)!\n        .location.merge(convertedBody.at(-1)!.location);\n      const bodySequence = new Atomic.Sequence(newLocation, convertedBody);\n\n      return new Extended.FunctionDefinition(\n        group.location,\n        convertedIdentifier,\n        bodySequence,\n        convertedFormals,\n        convertedRest\n      );\n    }\n\n    // its a normal definition\n\n    if (expr.length > 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(define <identifier> <expr>)\"\n      );\n    }\n\n    // Expr is treated as a single expression\n    const convertedExpr = this.parseExpression(expr[0]);\n\n    return new Atomic.Definition(\n      group.location,\n      convertedIdentifier,\n      convertedExpr\n    );\n  }\n\n  /**\n   * Parse a conditional expression.\n   * @param group\n   * @returns\n   */\n  private parseConditional(group: Group): Atomic.Conditional {\n    // Form: (if <pred> <cons> <alt>)\n    //     | (if <pred> <cons>)\n\n    // ensure that the group has 3 or 4 elements\n    if (group.length() < 3 || group.length() > 4) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(if <pred> <cons> <alt>?)\"\n      );\n    }\n    const elements = group.unwrap();\n    const test = elements[1];\n    const consequent = elements[2];\n    const alternate = group.length() > 3 ? elements[3] : undefined;\n\n    // Test is treated as a single expression\n    const convertedTest = this.parseExpression(test);\n\n    // Consequent is treated as a single expression\n    const convertedConsequent = this.parseExpression(consequent);\n\n    // Alternate is treated as a single expression\n\n    const convertedAlternate = alternate\n      ? this.parseExpression(alternate)\n      : new Atomic.Identifier(group.location, \"undefined\");\n\n    return new Atomic.Conditional(\n      group.location,\n      convertedTest,\n      convertedConsequent,\n      convertedAlternate\n    );\n  }\n\n  /**\n   * Parse an application expression.\n   */\n  private parseApplication(group: Group): Atomic.Application {\n    // Form: (<func> <args>*)\n    // ensure that the group has at least 1 element\n    if (group.length() < 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(<func> <args>*)\"\n      );\n    }\n    const elements = group.unwrap();\n    const operator = elements[0];\n    const operands = elements.splice(1);\n\n    // Operator is treated as a single expression\n    const convertedOperator = this.parseExpression(operator);\n\n    // Operands are treated as a group of expressions\n    const convertedOperands: Expression[] = [];\n    for (const operand of operands) {\n      convertedOperands.push(this.parseExpression(operand));\n    }\n\n    return new Atomic.Application(\n      group.location,\n      convertedOperator,\n      convertedOperands\n    );\n  }\n\n  /**\n   * Parse a let expression.\n   * @param group\n   * @returns\n   */\n  private parseLet(group: Group): Extended.Let {\n    if (this.chapter >= MACRO_CHAPTER) {\n      // disable any verification for the let expression\n      const groupItems = group.unwrap().slice(1);\n      groupItems.forEach(item => {\n        this.parseExpression(item);\n      });\n      return new Extended.Let(\n        group.location,\n        [],\n        [],\n        new Atomic.Identifier(group.location, \"undefined\")\n      );\n    }\n    // Form: (let ((<identifier> <value>)*) <body>+)\n    // ensure that the group has at least 3 elements\n    if (group.length() < 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(let ((<identifier> <value>)*) <body>+)\"\n      );\n    }\n    const elements = group.unwrap();\n    const bindings = elements[1];\n    const body = elements.slice(2);\n\n    // Verify bindings is a group\n    if (!isGroup(bindings)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        bindings.pos,\n        bindings,\n        \"((<identifier> <value>)*)\"\n      );\n    }\n\n    // Bindings are treated as a group of grouped identifiers and values\n    const convertedIdentifiers: Atomic.Identifier[] = [];\n    const convertedValues: Expression[] = [];\n\n    const bindingElements = bindings.unwrap();\n    for (const bindingElement of bindingElements) {\n      // Verify bindingElement is a group of size 2\n      if (!isGroup(bindingElement)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          bindingElement.pos,\n          bindingElement,\n          \"(<identifier> <value>)\"\n        );\n      }\n      if (bindingElement.length() !== 2) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          bindingElement.location.start,\n          bindingElement,\n          \"(<identifier> <value>)\"\n        );\n      }\n\n      const [identifier, value] = bindingElement.unwrap();\n\n      // Verify identifier is a token and an identifier\n      if (!isToken(identifier)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          identifier.location.start,\n          identifier,\n          \"<identifier>\"\n        );\n      }\n      if (identifier.type !== TokenType.IDENTIFIER) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          identifier.pos,\n          identifier,\n          \"<identifier>\"\n        );\n      }\n      convertedIdentifiers.push(\n        new Atomic.Identifier(this.toLocation(identifier), identifier.lexeme)\n      );\n      convertedValues.push(this.parseExpression(value));\n    }\n\n    // Body is treated as a group of expressions\n    const convertedBody = body.map(\n      this.parseExpression.bind(this)\n    ) as Expression[];\n\n    // assert that body is not empty\n    if (convertedBody.length < 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(let ... <body>+)\"\n      );\n    }\n\n    if (convertedBody.length === 1) {\n      return new Extended.Let(\n        group.location,\n        convertedIdentifiers,\n        convertedValues,\n        convertedBody[0]\n      );\n    }\n\n    const newLocation = convertedBody\n      .at(0)!\n      .location.merge(convertedBody.at(-1)!.location);\n    const bodySequence = new Atomic.Sequence(newLocation, convertedBody);\n\n    return new Extended.Let(\n      group.location,\n      convertedIdentifiers,\n      convertedValues,\n      bodySequence\n    );\n  }\n\n  /**\n   * Parse an extended cond expression.\n   * @param group\n   * @returns\n   */\n  private parseExtendedCond(group: Group): Extended.Cond {\n    if (this.chapter >= MACRO_CHAPTER) {\n      // disable any verification for the cond expression\n      const groupItems = group.unwrap().slice(1);\n      groupItems.forEach(item => {\n        this.parseExpression(item);\n      });\n      return new Extended.Cond(\n        group.location,\n        [],\n        [],\n        new Atomic.Identifier(group.location, \"undefined\")\n      );\n    }\n    // Form: (cond (<pred> <body>)*)\n    //     | (cond (<pred> <body>)* (else <val>))\n    // ensure that the group has at least 2 elements\n    if (group.length() < 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(cond (<pred> <body>*)* (else <val>)?)\"\n      );\n    }\n    const elements = group.unwrap();\n    const clauses = elements.splice(1);\n    // safe to cast because of the check above\n    const lastClause = <Datum>clauses.pop();\n\n    // Clauses are treated as a group of groups of expressions\n    // Form: (<pred> <body>*)\n    const convertedClauses: Expression[] = [];\n    const convertedConsequents: Expression[] = [];\n\n    for (const clause of clauses) {\n      // Verify clause is a group with size no less than 1\n      if (!isGroup(clause)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          clause.pos,\n          clause,\n          \"(<pred> <body>*)\"\n        );\n      }\n      if (clause.length() < 1) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          clause.firstToken().pos,\n          clause.firstToken(),\n          \"(<pred> <body>*)\"\n        );\n      }\n\n      const [test, ...consequent] = clause.unwrap();\n\n      // verify that test is NOT an else token\n      if (isToken(test) && test.type === TokenType.ELSE) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          test.pos,\n          test,\n          \"<predicate>\"\n        );\n      }\n\n      // Test is treated as a single expression\n      const convertedTest = this.parseExpression(test);\n\n      // Consequent is treated as a group of expressions\n      const consequentExpressions = consequent.map(\n        this.parseExpression.bind(this)\n      ) as Expression[];\n      const consequentLocation =\n        consequent.length < 1\n          ? convertedTest.location\n          : consequentExpressions\n              .at(0)!\n              .location.merge(consequentExpressions.at(-1)!.location);\n\n      // if consequent is empty, the test itself is treated\n      // as the value returned.\n      // if consequent is more than length one, there is a sequence.\n      const convertedConsequent =\n        consequent.length < 1\n          ? convertedTest\n          : consequent.length < 2\n            ? consequentExpressions[0]\n            : new Atomic.Sequence(consequentLocation, consequentExpressions);\n\n      convertedClauses.push(convertedTest);\n      convertedConsequents.push(convertedConsequent);\n    }\n\n    // Check last clause\n    // Verify lastClause is a group with size at least 2\n    if (!isGroup(lastClause)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        lastClause.pos,\n        lastClause,\n        \"(<pred> <body>+) | (else <val>)\"\n      );\n    }\n\n    if (lastClause.length() < 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        lastClause.firstToken().pos,\n        lastClause.firstToken(),\n        \"(<pred> <body>+) | (else <val>)\"\n      );\n    }\n\n    const [test, ...consequent] = lastClause.unwrap();\n\n    let isElse = false;\n\n    // verify that test is an else token\n    if (isToken(test) && test.type === TokenType.ELSE) {\n      isElse = true;\n      // verify that consequent is of length 1\n      if (consequent.length !== 1) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          lastClause.location.start,\n          lastClause,\n          \"(else <val>)\"\n        );\n      }\n    }\n\n    // verify that consequent is at least 1 expression\n    if (consequent.length < 1) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        lastClause.location.start,\n        lastClause,\n        \"(<pred> <body>+)\"\n      );\n    }\n\n    // Consequent is treated as a group of expressions\n    const consequentExpressions = consequent.map(\n      this.parseExpression.bind(this)\n    ) as Expression[];\n    const consequentLocation = consequentExpressions\n      .at(0)!\n      .location.merge(consequentExpressions.at(-1)!.location);\n    const lastConsequent =\n      consequent.length === 1\n        ? consequentExpressions[0]\n        : new Atomic.Sequence(consequentLocation, consequentExpressions);\n\n    if (isElse) {\n      return new Extended.Cond(\n        group.location,\n        convertedClauses,\n        convertedConsequents,\n        lastConsequent\n      );\n    }\n\n    // If the last clause is not an else clause, we treat it as a normal cond clause instead\n    const lastTest = this.parseExpression(test);\n\n    // Test\n    convertedClauses.push(lastTest);\n    convertedConsequents.push(lastConsequent);\n\n    return new Extended.Cond(\n      group.location,\n      convertedClauses,\n      convertedConsequents\n    );\n  }\n\n  // _____________________CHAPTER 3_____________________\n\n  /**\n   * Parse a reassignment expression.\n   * @param group\n   * @returns\n   */\n  private parseSet(group: Group): Atomic.Reassignment {\n    // Form: (set! <identifier> <expr>)\n    // ensure that the group has 3 elements\n    if (group.length() !== 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(set! <identifier> <expr>)\"\n      );\n    }\n    const elements = group.unwrap();\n    const identifier = elements[1];\n    const expr = elements[2];\n\n    // Identifier is treated as a single identifier\n    if (isGroup(identifier)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        identifier.location.start,\n        identifier,\n        \"<identifier>\"\n      );\n    }\n    if (identifier.type !== TokenType.IDENTIFIER) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        identifier.pos,\n        identifier,\n        \"<identifier>\"\n      );\n    }\n    const convertedIdentifier = new Atomic.Identifier(\n      this.toLocation(identifier),\n      identifier.lexeme\n    );\n    const convertedExpr = this.parseExpression(expr);\n    return new Atomic.Reassignment(\n      group.location,\n      convertedIdentifier,\n      convertedExpr\n    );\n  }\n\n  /**\n   * Parse a begin expression.\n   * @param group\n   * @returns\n   */\n  private parseBegin(group: Group): Extended.Begin {\n    // Form: (begin <body>+)\n    // ensure that the group has 2 or more elements\n    if (group.length() < 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(begin <body>+)\"\n      );\n    }\n    const sequence = group.unwrap();\n    const sequenceElements = sequence.slice(1);\n    const convertedExpressions: Expression[] = [];\n    for (const sequenceElement of sequenceElements) {\n      convertedExpressions.push(this.parseExpression(sequenceElement));\n    }\n    return new Extended.Begin(group.location, convertedExpressions);\n  }\n\n  /**\n   * Parse a delay expression.\n   * @param group\n   * @returns\n   */\n  private parseDelay(group: Group): Extended.Delay {\n    if (this.chapter >= MACRO_CHAPTER) {\n      // disable any verification for the delay expression\n      const groupItems = group.unwrap().slice(1);\n      groupItems.forEach(item => {\n        this.parseExpression(item);\n      });\n      return new Extended.Delay(\n        group.location,\n        new Atomic.Identifier(group.location, \"undefined\")\n      );\n    }\n    // Form: (delay <expr>)\n    // ensure that the group has 2 elements\n    if (group.length() !== 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(delay <expr>)\"\n      );\n    }\n    const elements = group.unwrap();\n    const expr = elements[1];\n\n    // Expr is treated as a single expression\n    const convertedExpr = this.parseExpression(expr);\n\n    return new Extended.Delay(group.location, convertedExpr);\n  }\n\n  // _____________________CHAPTER 3_____________________\n\n  /**\n   * Parse a define-syntax expression.\n   * @param group\n   * @returns nothing, this is for verification only.\n   */\n  private parseDefineSyntax(group: Group): Atomic.DefineSyntax {\n    // Form: (define-syntax <identifier> <transformer>)\n    // ensure that the group has 3 elements\n    if (group.length() !== 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(define-syntax <identifier> <transformer>)\"\n      );\n    }\n    const elements = group.unwrap();\n    const identifier = elements[1];\n    const transformer = elements[2];\n\n    // parse the identifier using quote mode\n    // (to capture redefinitions of syntax)\n    this.quoteMode = QuoteMode.QUOTE;\n    const convertedIdentifier = this.parseExpression(\n      identifier\n    ) as Atomic.Identifier;\n    this.quoteMode = QuoteMode.NONE;\n\n    if (!(convertedIdentifier instanceof Atomic.Symbol)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        convertedIdentifier.location.start,\n        identifier,\n        \"<identifier>\"\n      );\n    }\n\n    // Transformer is treated as a group\n    // it should be syntax-rules\n    if (!isGroup(transformer)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        transformer.pos,\n        transformer,\n        \"<transformer>\"\n      );\n    }\n\n    if (transformer.length() < 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        transformer.firstToken().pos,\n        transformer,\n        \"(syntax-rules ...)\"\n      );\n    }\n    const transformerToken = transformer.unwrap()[0];\n    if (!isToken(transformer.unwrap()[0])) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        transformer.firstToken().pos,\n        transformerToken,\n        \"syntax-rules\"\n      );\n    }\n\n    if ((transformerToken as Token).type !== TokenType.SYNTAX_RULES) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        (transformerToken as Token).pos,\n        transformerToken,\n        \"syntax-rules\"\n      );\n    }\n\n    // parse the transformer\n    const convertedTransformer = this.parseSyntaxRules(\n      transformer\n    ) as Atomic.SyntaxRules;\n\n    return new Atomic.DefineSyntax(\n      group.location,\n      convertedIdentifier,\n      convertedTransformer\n    );\n  }\n\n  /**\n   * Helper function to verify the validity of a pattern.\n   * @param pattern\n   * @returns validity of the pattern\n   */\n  private isValidPattern(pattern: Expression): boolean {\n    // a pattern is either a symbol, a literal or\n    // a list (<pattern>+), (<pattern>+ . <pattern>), (<pattern>+ ... <pattern>*)\n    // or (<pattern>+ ... <pattern>+ . <pattern>)\n    if (pattern instanceof Extended.List) {\n      // check if the list is a proper list\n      const isProper = pattern.terminator === undefined;\n      if (isProper) {\n        // scan to make sure that only one ellipsis is present\n        const ellipsisCount = pattern.elements.filter(\n          item => item instanceof Atomic.Symbol && item.value === \"...\"\n        ).length;\n\n        if (ellipsisCount > 1) {\n          return false;\n        }\n\n        const ellipsisIndex = pattern.elements.findIndex(\n          item => item instanceof Atomic.Symbol && item.value === \"...\"\n        );\n\n        if (ellipsisIndex != -1) {\n          // check if the ellipsis is behind any other element\n          // (ie it's not the first element)\n          if (ellipsisIndex === 0) {\n            return false;\n          }\n        }\n\n        // recursively check the elements\n        for (const element of pattern.elements) {\n          if (!this.isValidPattern(element)) {\n            return false;\n          }\n        }\n\n        return true;\n      } else {\n        // scan to make sure that only one ellipsis is present\n        const ellipsisCount = pattern.elements.filter(\n          item => item instanceof Atomic.Symbol && item.value === \"...\"\n        ).length;\n\n        if (ellipsisCount > 1) {\n          return false;\n        }\n\n        const ellipsisIndex = pattern.elements.findIndex(\n          item => item instanceof Atomic.Symbol && item.value === \"...\"\n        );\n\n        if (ellipsisIndex != -1) {\n          // check if the ellipsis is behind any other element\n          // (ie it's not the first element)\n          if (ellipsisIndex === 0) {\n            return false;\n          }\n\n          // since this is an improper list, the ellipsis must not\n          // be the last element either\n          if (ellipsisIndex === pattern.elements.length - 1) {\n            return false;\n          }\n        }\n\n        // recursively check the elements\n        for (const element of pattern.elements) {\n          if (!this.isValidPattern(element)) {\n            return false;\n          }\n        }\n\n        return this.isValidPattern(pattern.terminator as Expression);\n      }\n    } else if (\n      pattern instanceof Atomic.Symbol ||\n      pattern instanceof Atomic.BooleanLiteral ||\n      pattern instanceof Atomic.NumericLiteral ||\n      pattern instanceof Atomic.StringLiteral ||\n      pattern instanceof Atomic.Nil\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Helper function to verify the validity of a template.\n   * @param template\n   * @returns validity of the template\n   */\n  private isValidTemplate(template: Expression): boolean {\n    // a template is either a symbol, a literal or\n    // a list (<element>+), (<element>+ . <template>), (... <template>)\n    // where <element> is a template optionally followed by ...\n    if (template instanceof Extended.List) {\n      // check if the list is a proper list\n      const isProper = template.terminator === undefined;\n      if (isProper) {\n        // should have at least 1 element\n        if (template.elements.length === 0) {\n          return false;\n        }\n\n        // (... <template>) case\n        if (\n          template.elements.length === 2 &&\n          template.elements[0] instanceof Atomic.Symbol &&\n          template.elements[0].value === \"...\"\n        ) {\n          return this.isValidTemplate(template.elements[1]);\n        }\n\n        let ellipsisWorksOnLastElement = false;\n        // check each element for validity except for ellipses.\n        // for those, check if they follow a valid template.\n        for (let i = 0; i < template.elements.length; i++) {\n          const element = template.elements[i];\n          if (element instanceof Atomic.Symbol && element.value === \"...\") {\n            if (ellipsisWorksOnLastElement) {\n              ellipsisWorksOnLastElement = false;\n              continue;\n            }\n            // either consecutive ellipses or the first element is an ellipsis\n            return false;\n          } else {\n            if (!this.isValidTemplate(element)) {\n              return false;\n            }\n            ellipsisWorksOnLastElement = true;\n          }\n        }\n        return true;\n      } else {\n        if (template.elements.length === 0) {\n          return false;\n        }\n\n        let ellipsisWorksOnLastElement = false;\n        // check each element for validity except for ellipses.\n        // for those, check if they follow a valid template.\n        for (let i = 0; i < template.elements.length; i++) {\n          const element = template.elements[i];\n          if (element instanceof Atomic.Symbol && element.value === \"...\") {\n            if (ellipsisWorksOnLastElement) {\n              ellipsisWorksOnLastElement = false;\n              continue;\n            }\n            // either consecutive ellipses or the first element is an ellipsis\n            return false;\n          } else {\n            if (!this.isValidTemplate(element)) {\n              return false;\n            }\n            ellipsisWorksOnLastElement = true;\n          }\n        }\n        return this.isValidTemplate(template.terminator as Expression);\n      }\n    } else if (\n      template instanceof Atomic.Symbol ||\n      template instanceof Atomic.BooleanLiteral ||\n      template instanceof Atomic.NumericLiteral ||\n      template instanceof Atomic.StringLiteral ||\n      template instanceof Atomic.Nil\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Parse a syntax-rules expression.\n   * @param group\n   * @returns nothing, this is for verification only.\n   */\n  private parseSyntaxRules(group: Group): Atomic.SyntaxRules {\n    // syntax rules is of form\n    // (syntax-rules (<literal>*) <syntax-rule>+)\n    // where syntax-rule is of form\n    // (<pattern> <template>)\n    // ensure that the group has at least 3 elements\n    if (group.length() < 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.location.start,\n        group,\n        \"(syntax-rules (<literal>*) <syntax-rule>+)\"\n      );\n    }\n\n    const elements = group.unwrap();\n    const literals = elements[1];\n    const rules = elements.slice(2);\n\n    const finalLiterals: Atomic.Symbol[] = [];\n    // verify that literals is a group\n    if (!isGroup(literals)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        literals.pos,\n        literals,\n        \"(<literal>*)\"\n      );\n    }\n\n    // parse each literal as a symbol\n    this.quoteMode = QuoteMode.QUOTE;\n    for (const literal of literals.unwrap()) {\n      if (!isToken(literal)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          literal.location.start,\n          literal,\n          \"<literal>\"\n        );\n      }\n\n      const convertedLiteral = this.parseExpression(literal);\n      if (!(convertedLiteral instanceof Atomic.Symbol)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          literal.pos,\n          literal,\n          \"<literal>\"\n        );\n      }\n      finalLiterals.push(convertedLiteral);\n    }\n\n    const finalRules: [Expression, Expression][] = [];\n\n    // each rule is a group of size 2\n    for (const rule of rules) {\n      if (!isGroup(rule)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          rule.pos,\n          rule,\n          \"(<pattern> <template>)\"\n        );\n      }\n      if (rule.length() !== 2) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          rule.location.start,\n          rule,\n          \"(<pattern> <template>)\"\n        );\n      }\n      // verify the validity of the pattern and template\n      const [pattern, template] = rule.unwrap();\n\n      const convertedPattern = this.parseExpression(pattern);\n      const convertedTemplate = this.parseExpression(template);\n\n      if (!this.isValidPattern(convertedPattern)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          convertedPattern.location.start,\n          pattern,\n          \"<symbol> | <literal> | (<pattern>+) | (<pattern>+ ... <pattern>*) | (<pattern>+ ... <pattern>+ . <pattern>)\"\n        );\n      }\n\n      if (!this.isValidTemplate(convertedTemplate)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          convertedTemplate.location.start,\n          template,\n          \"<symbol> | <literal> | (<element>+) | (<element>+ . <template>) | (... <template>)\"\n        );\n      }\n\n      finalRules.push([convertedPattern, convertedTemplate]);\n    }\n\n    this.quoteMode = QuoteMode.NONE;\n    return new Atomic.SyntaxRules(group.location, finalLiterals, finalRules);\n  }\n\n  // ___________________MISCELLANEOUS___________________\n\n  /**\n   * Parse an import expression.\n   * @param group\n   * @returns\n   */\n  private parseImport(group: Group): Atomic.Import {\n    // Form: (import \"<source>\" (<identifier>*))\n    // ensure that the group has 3 elements\n    if (group.length() !== 3) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.firstToken().pos,\n        group.firstToken(),\n        '(import \"<source>\" (<identifier>*))'\n      );\n    }\n    const elements = group.unwrap();\n    const source = elements[1];\n    const identifiers = elements[2];\n\n    // source is treated as a single string\n    if (!isToken(source)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        source.location.start,\n        source,\n        '\"<source>\"'\n      );\n    }\n    if (source.type !== TokenType.STRING) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        source.pos,\n        source,\n        '\"<source>\"'\n      );\n    }\n\n    // Identifiers are treated as a group of identifiers\n    if (!isGroup(identifiers)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        identifiers.pos,\n        identifiers,\n        \"(<identifier>*)\"\n      );\n    }\n    const identifierElements = identifiers.unwrap();\n    const convertedIdentifiers: Atomic.Identifier[] = [];\n    for (const identifierElement of identifierElements) {\n      if (!isToken(identifierElement)) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          identifierElement.location.start,\n          identifierElement,\n          \"<identifier>\"\n        );\n      }\n      if (identifierElement.type !== TokenType.IDENTIFIER) {\n        throw new ParserError.ExpectedFormError(\n          this.source,\n          identifierElement.pos,\n          identifierElement,\n          \"<identifier>\"\n        );\n      }\n      convertedIdentifiers.push(\n        new Atomic.Identifier(\n          this.toLocation(identifierElement),\n          identifierElement.lexeme\n        )\n      );\n    }\n    const convertedSource = new Atomic.StringLiteral(\n      this.toLocation(source),\n      source.literal\n    );\n    return new Atomic.Import(\n      group.location,\n      convertedSource,\n      convertedIdentifiers\n    );\n  }\n\n  /**\n   * Parse an export expression.\n   * @param group\n   * @returns\n   */\n  private parseExport(group: Group): Atomic.Export {\n    // Form: (export (<definition>))\n    // ensure that the group has 2 elements\n    if (group.length() !== 2) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        group.firstToken().pos,\n        group.firstToken(),\n        \"(export (<definition>))\"\n      );\n    }\n    const elements = group.unwrap();\n    const definition = elements[1];\n\n    // assert that definition is a group\n    if (!isGroup(definition)) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        definition.pos,\n        definition,\n        \"(<definition>)\"\n      );\n    }\n\n    const convertedDefinition = this.parseExpression(definition);\n    // assert that convertedDefinition is a definition\n    if (\n      !(\n        convertedDefinition instanceof Atomic.Definition ||\n        convertedDefinition instanceof Extended.FunctionDefinition\n      )\n    ) {\n      throw new ParserError.ExpectedFormError(\n        this.source,\n        definition.location.start,\n        definition,\n        \"(<definition>)\"\n      );\n    }\n\n    return new Atomic.Export(group.location, convertedDefinition);\n  }\n\n  /**\n   * Parses a vector expression\n   */\n  private parseVector(group: Group): Atomic.Vector {\n    // Because of the group invariants, we can safely assume that the group\n    // is strictly of size 2.\n    // Additionally, we can safely assume that the second element is a group\n    // because token HASH_VECTOR expects a parenthesis as the next immediate\n    // token.\n    const elements = group.unwrap()[1] as Group;\n\n    // Vectors will be treated normally regardless of the quote mode.\n    // but interior expressions will be affected by the mode.\n    const convertedElements = elements\n      .unwrap()\n      .map(this.parseExpression.bind(this)) as Expression[];\n\n    return new Atomic.Vector(group.location, convertedElements);\n  }\n\n  // ___________________________________________________\n\n  /** Parses a sequence of tokens into an AST.\n   *\n   * @param group A group of tokens.\n   * @returns An AST.\n   */\n  parse(reparseAsSexpr: boolean = false): Expression[] {\n    if (reparseAsSexpr) {\n      this.quoteMode = QuoteMode.QUOTE;\n      this.current = 0;\n    }\n    // collect all top-level elements\n    const topElements: Expression[] = [];\n    while (!this.isAtEnd()) {\n      if (this.peek().type === TokenType.EOF) {\n        break;\n      }\n      const currentElement = this.grouping();\n      if (!currentElement) {\n        continue;\n      }\n      const convertedElement = this.parseExpression(currentElement);\n      topElements.push(convertedElement);\n    }\n    // if we are in the macro chapter,\n    // everything we have done so far was only to verify the program.\n    // we return everything as an s-expression - that is, we quote the\n    // entire program.\n    if (this.chapter >= MACRO_CHAPTER && !reparseAsSexpr) {\n      // so, redo the entire parsing, but now with the quote mode on.\n      // we do need to remove the imports from the top level elements,\n      // and append them here.\n\n      // assumption - all imports are top level forms. We will hoist all imports to the top.\n      // TODO: Figure out how to assert imports as top level forms.\n      const importElements: Expression[] = topElements.filter(\n        e => e instanceof Atomic.Import\n      );\n      const sexprElements = this.parse(true);\n\n      // we remove all of the quoted imports from the sexprElements.\n      // an import can be detected as a list\n      // that is not empty\n      // whose first element is a symbol\n      // in which the name is \"import\".\n      const restElements = sexprElements.filter(\n        e =>\n          !(\n            e instanceof Extended.List &&\n            e.elements &&\n            e.elements[0] instanceof Atomic.Symbol &&\n            e.elements[0].value === \"import\"\n          )\n      );\n\n      return [...importElements, ...restElements];\n    }\n    return topElements;\n  }\n}\n","import { Position } from '../../scheme_parser/transpiler/types/location';\n\nexport class SourceLocation {\n  constructor(\n    public source: string,\n    public startLine: number,\n    public startColumn: number,\n    public endLine: number,\n    public endColumn: number,\n  ) { }\n}\n\n\nexport class Syntax {\n  constructor(\n    public start: Position,\n    public end: Position,\n    public source: string\n  ) { }\n}\n\nexport class Location {\n  constructor(\n    public syntax: Syntax,\n    public forInfo: boolean\n  ) { }\n\n  public locationToSrcLoc(): SourceLocation {\n    return new SourceLocation(\n      this.syntax.source,\n      this.syntax.start.line,\n      this.syntax.start.column,\n      this.syntax.end.line,\n      this.syntax.end.column\n    )\n  }\n\n  public toString(): string {\n    return `${this.syntax.source}:${this.syntax.start.line}:${this.syntax.start.column}`;\n  }\n}\n\nexport function notForInfo(loc: Location): Location {\n  return new Location(loc.syntax, false);\n}\n","// Replace normal digits with subscript digits and vice versa\nconst subscriptReplacements: Record<string, string> = {\n  \"0\": \"\",\n  \"1\": \"\",\n  \"2\": \"\",\n  \"3\": \"\",\n  \"4\": \"\",\n  \"5\": \"\",\n  \"6\": \"\",\n  \"7\": \"\",\n  \"8\": \"\",\n  \"9\": \"\"\n}\n\nconst nonSubscripts: Record<string, string> = {\n  \"\": \"0\",\n  \"\": \"1\",\n  \"\": \"2\",\n  \"\": \"3\",\n  \"\": \"4\",\n  \"\": \"5\",\n  \"\": \"6\",\n  \"\": \"7\",\n  \"\": \"8\",\n  \"\": \"9\"\n}\n\n// Main freshen function\nexport function freshen(used: string[], x: string): string {\n  if (used.some(usedName => usedName === x)) {\n    const split = splitName(x);\n    return freshenAux(used, split);\n  }\n  return x;\n}\n\n\nfunction freshenAux(used: string[], split: [string, number]): string {\n  const joined = unsplitName(split);\n  if (used.map(sym => sym.toString()).includes(joined.toString())) {\n    return freshenAux(used, nextSplitName(split));\n  }\n  return joined;\n}\n\n// Check if a character is a subscript digit\nfunction isSubscriptDigit(c: string): boolean {\n  return Object.keys(nonSubscripts).includes(c);\n}\n\n// Replaces regular digits in the number with subscript digits\nfunction numberToSubscriptString(n: number): string {\n  const subscriptStr = n.toString().split(\"\").map(digit => subscriptReplacements[digit] || digit).join(\"\");\n  return subscriptStr;\n}\n\n// Replaces subscript digits with regular digits\nfunction subscriptToNumber(str: string): number {\n  const replaced = str.split(\"\").map(char => nonSubscripts[char] || char).join(\"\");\n  return parseInt(replaced, 10) || 1;\n}\n\n// Helper function to split the name (base name and subscript)\nfunction splitNameAux(str: string, i: number): [string, number] {\n  if (i < 0) {\n    return [str, 0]; // Default case if no subscript is found\n  }\n  if (isSubscriptDigit(str[i])) {\n    return splitNameAux(str, i - 1);\n  }\n  return [str.substring(0, i + 1), subscriptToNumber(str.substring(i + 1))];\n}\n\n// Increments the subscript part of a name\nfunction nextSplitName(split: [string, number]): [string, number] {\n  return [split[0], split[1] + 1];\n}\n\n// Splits the name into base name and subscript number\nfunction splitName(name: string): [string, number] {\n\n  // Call splitNameAux on the string representation\n  const [base, num] = splitNameAux(name, name.length - 1);\n  return [base, num];\n}\n\n// Joins the base name and subscript into a new name\nfunction unsplitName([base, num]: [string, number]): string {\n\n  // Convert number to subscript string\n  const subscriptStr = numberToSubscriptString(num);\n  return base + subscriptStr;\n}","import { Source } from \"./source\"\nimport { Core } from \"./core\"\nimport { Location } from \"../utils/locations\";\nimport { Value } from \"./value\";\nimport { Environment, extendEnvironment} from \"../utils/environment\";\nimport { Context } from \"../utils/context\";\nimport { freshen } from \"../utils/fresh\";\n\n\n// A SiteBinder is a variable name and its location, substitute BindingSite in original code.\n\nexport class SiteBinder {\n  constructor(\n    public location: Location,\n    public varName: string,\n  ) { }\n}\n\n// Define TypedBinder, which is a SiteBinder associated with a expression in Pie.\n\nexport class TypedBinder {\n  constructor(\n    public binder: SiteBinder,\n    public type: Source,\n  ) {}\n}\n\nexport function isPieKeywords(str : string) : boolean {\n  return str === 'U' ? true : \n    str === 'Nat' ? true :\n    str === 'zero' ? true :\n    str === 'add1' ? true :\n    str === 'which-Nat' ? true :\n    str === 'iter-Nat' ? true :\n    str === 'rec-Nat' ? true :\n    str === 'ind-Nat' ? true :\n    str === '->' ? true :\n    str === '' ? true :\n    str === '' ? true :\n    str === '' ? true :\n    str === 'Pi' ? true :\n    str === '' ? true :\n    str === 'lambda' ? true :\n    str === 'quote' ? true :\n    str === 'Atom' ? true :\n    str === 'car' ? true :\n    str === 'cdr' ? true :\n    str === 'cons' ? true :\n    str === '' ? true :\n    str === 'Sigma' ? true :\n    str === 'Pair' ? true :\n    str === 'Trivial' ? true :\n    str === 'sole' ? true :\n    str === 'List' ? true :\n    str === '::' ? true :\n    str === 'nil' ? true :\n    str === 'rec-List' ? true :\n    str === 'ind-List' ? true :\n    str === 'Absurd' ? true :\n    str === 'ind-Absurd' ? true :\n    str === '=' ? true :\n    str === 'same' ? true :\n    str === 'replace' ? true :\n    str === 'trans' ? true :\n    str === 'cong' ? true :\n    str === 'symm' ? true :\n    str === 'ind-=' ? true :\n    str === 'Vec' ? true :\n    str === 'vecnil' ? true :\n    str === 'vec::' ? true :\n    str === 'head' ? true :\n    str === 'tail' ? true :\n    str === 'ind-Vec' ? true :\n    str === 'Either' ? true :\n    str === 'left' ? true :\n    str === 'right' ? true :\n    str === 'ind-Either' ? true :\n    str === 'TODO' ? true :\n    str === 'the' ? true :\n    false;\n}\n\n\nexport class Message {\n  constructor(public message: Array<String|Core>) { }\n}\n\nexport abstract class Perhaps<T> { \n\n}\n\nexport class go<T> extends Perhaps<T> {\n  constructor(public result: T) { super() }\n}\n\n// A failure result named \"stop\"\nexport class stop extends Perhaps<undefined> {\n  constructor(\n    public where: Location,\n    public message: Message\n  ) { super() }\n}\n\nexport class PerhapsM<T> {\n  // name is majorly for debugging use.\n  constructor(public name: string, public value: T = null as any) { }\n}\n\n/*\n  go-on is very much like let*. The difference is that if any of the\n  values bound to variables in it are stop, then the entire\n  expression becomes that first stop. Otherwise, the variables are\n  bound to the contents of each go.\n*/\n\nexport function goOn<T>(\n  bindings: [PerhapsM<any>, () => Perhaps<any>][],\n  finalExpr: () => T): T {\n  for(const [meta, lazy] of bindings) {\n    const val = lazy();\n    if (val instanceof go) {\n      meta.value = (val as go<any>).result;\n    } else {\n      throw new Error(`Encountered stop when evaluating the sequence ${bindings}. Error message: ${(val as stop).message.message} at ${(val as stop).where}`);\n    }\n  }\n  return finalExpr();\n}\n\n/*\n  ### Closures ### \n\n  There are two kinds of closures: first-order closures and\n  higher-order closures. They are used for different purposes in\n  Pie. It would be possible to have only one representation, but they\n  are good for different things, so both are included. See\n  val-of-closure in normalize.rkt for how to find the value of a\n  closure, given the value for its free variable.\n*/\n\n\nexport abstract class Closure { \n\n  constructor() { }\n  /*\n    General-purpose helpers\n   \n    Given a value for a closure's free variable, find the value. This\n    cannot be used for DELAY-CLOS, because DELAY-CLOS's laziness\n    closures do not have free variables, but are instead just delayed\n    computations.\n  */\n  public abstract valOfClosure(v: Value): Value;\n\n  public abstract prettyPrint(): string;\n\n}\n\n/*\n  First-order closures, which are a pair of an environment an an\n  expression whose free variables are given values by the\n  environment, are used for most closures in Pie. They are easier to\n  debug, because their contents are visible rather than being part of\n  a compiled Racket function. On the other hand, they are more\n  difficult to construct out of values, because it would be necessary\n  to first read the values back into Core Pie syntax.\n*/\n\nexport class FirstOrderClosure extends Closure {\n  constructor(\n    public env: Environment,\n    public varName: string,\n    public expr: Core\n  ) { super() }\n\n  public valOfClosure(v: Value): Value {\n    return this.expr.valOf(extendEnvironment(this.env, this.varName, v));\n  }\n\n  public prettyPrint(): string {\n    return `(CLOS ${this.varName} ${this.expr.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n  \n}\n\n/*\n  Higher-order closures re-used Racket's built-in notion of\n  closure. They are more convenient when constructing closures from\n  existing values, which happens both during type checking, where\n  these values are used for things like the type of a step, and\n  during evaluation, where they are used as type annotations on THE\n  and NEU.\n*/\n\nexport class HigherOrderClosure extends Closure {\n  constructor(\n    public proc: (value: Value) => Value\n  ) { super() };\n\n  public valOfClosure(v: Value): Value {\n    return this.proc(v);\n  }\n\n  public prettyPrint(): string {\n    return `(HOCLOS)`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\n/*\n  ## Recognizing variable names ##\n\n  This macro causes a name to be defined both for Racket macros and\n  for use in ordinary Racket programs. In Racket, these are\n  separated.\n\n  Variable name recognition is needed in Racket macros in order to\n  parse Pie into the Src type, and it is needed in ordinary programs\n  in order to implement the type checker.\n\n  Here the codes are largely removed since the macro is not needed in TS.\n*/\n\n/*\n  The type of var-name? guarantees that the implementation will\n  always accept symbols that are not Pie keywords, and never accept\n  those that are.\n*/\n\nexport function isVarName(name: string): boolean {\n  return !isPieKeywords(name) && isNaN(Number(name));\n}\n\n/*\n  ### Finding fresh names ###\n\n  Find a fresh name, using none of those described in a context.\n\n  This is the implementation of the   fresh  x form of\n  judgment. Unlike the rules in the appendix to The Little Typer,\n  this implementation also accepts a name suggestion so that the code\n  produced by elaboration has names that are as similar as possible\n  to those written by the user.\n*/\n\n/*\n  Find the names that are described in a context, so they can be\n  avoided.\n*/\nfunction namesInContext(ctx: Context): string[] {\n  return Array.from(ctx.keys());\n}\n\nexport function fresh(ctx: Context, name: string): string {\n  return freshen(namesInContext(ctx), name);\n}\n\n/*\n  Find a fresh name, using none of those described in a context nor\n  occurring in an expression. This is used when constructing a fresh\n  binding to avoid capturing a free variable that would otherwise be\n  an error because it points at the context.\n*/\n\nexport function freshBinder(ctx: Context, src: Source, name: string): string {\n  return freshen(namesInContext(ctx).concat(src.findNames()), name);\n}\n\nexport function occurringBinderNames(binder: TypedBinder): string[] {\n  return [binder.binder.varName].concat(binder.type.findNames());\n}","import { Value } from '../types/value';\n\n/*  \n    ## Run-time Environments ##\n\n    Run-time environments\n    A run-time environment associates a value with each variable.\n*/\n\nexport type Environment = Map<string, Value>;\n  export function extendEnvironment(env: Environment, name: string, value: Value): Environment {\n    return new Map([...env, [name, value]]);\n  }\n\n  // Lookup the value of a variable in an environment (var-val)\n  export function getValueFromEnvironment(env: Environment, name: string): Value {\n    if (env.has(name)) {\n      // As we are sure that the variable is in the environment,\n      // we can use the non-nullable assertion operator (!)\n      return env.get(name)!;\n    } else {\n      throw new Error(`Variable ${name} not found in environment`);\n    }\n  }\n\n  // To find the value of a variable in an environment\n  export function ValueOfVar(env: Environment, name: string): Value {\n    if (env.has(name)) {\n      return env.get(name)!;\n    } else {\n      throw new Error(`Variable ${name} not in env: ${JSON.stringify(this)}`);\n    }\n  }\n\n","import { Value, Pi, Absurd } from \"./value\";\nimport { SourceLocation } from \"../utils/locations\";\nimport * as C from \"./core\";\nimport { Context } from \"../utils/context\";\nimport { readBack } from \"../evaluator/utils\";\n\n/*\n    Normal forms consist of syntax that is produced by read-back,\n    following the type. This structure contains a type value and a\n    value described by the type, so that read-back can later be applied\n    to it.\n*/\nexport class Norm {\n  constructor(public type: Value, public value: Value) { }\n}\n\n// Predicate function to check if an object is Norm\nexport function isNorm(obj: any): obj is Norm {\n  return obj instanceof Norm;\n}\n\n\n/*\n    ## Neutral Expressions ##\n    Neutral expressions are represented by structs that ensure that no\n    non-neutral expressions can be represented.\n*/\n\n// Base class for all Neutral types\nexport abstract class Neutral {\n\n  constructor() { } \n\n  public abstract readBackNeutral(context: Context): C.Core;\n\n  public toString(): string {\n    return \"Neutral\";\n  }\n\n  public prettyPrint(): string {\n    return \"Neutral\";\n  }\n}\n\nexport class Variable extends Neutral {\n  constructor(public name: string) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.VarName(this.name);\n  }\n}\n\nexport class TODO extends Neutral {\n  constructor(public where: SourceLocation, public type: Value) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.TODO(\n      this.where, this.type.readBackType(context)\n    );\n  }\n}\n\nexport class WhichNat extends Neutral {\n  constructor(public target: Neutral, public base: Norm, public step: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.WhichNat(\n      this.target.readBackNeutral(context),\n      new C.The(\n        this.base.type.readBackType(context),\n        readBack(context, this.base.type, this.base.value),\n      ),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IterNat extends Neutral {\n  constructor(public target: Neutral, public base: Norm, public step: Norm) {\n    super();\n  }\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IterNat(\n      this.target.readBackNeutral(context),\n      new C.The(\n        this.base.type.readBackType(context),\n        readBack(context, this.base.type, this.base.value),\n      ),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class RecNat extends Neutral {\n  constructor(public target: Neutral, public base: Norm, public step: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.RecNat(\n      this.target.readBackNeutral(context),\n      new C.The(\n        this.base.type.readBackType(context),\n        readBack(context, this.base.type, this.base.value),\n      ),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IndNat extends Neutral {\n  constructor(\n    public target: Neutral,\n    public motive: Norm,\n    public base: Norm,\n    public step: Norm\n  ) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndNat(\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class Car extends Neutral {\n  constructor(public target: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Car(this.target.readBackNeutral(context));\n  }\n}\n\nexport class Cdr extends Neutral {\n  constructor(public target: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Cdr(this.target.readBackNeutral(context));\n  }\n}\n\nexport class RecList extends Neutral {\n  constructor(public target: Neutral, public base: Norm, public step: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.RecList(\n      this.target.readBackNeutral(context),\n      new C.The(\n        this.base.type.readBackType(context),\n        readBack(context, this.base.type, this.base.value),\n      ),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IndList extends Neutral {\n  constructor(public target: Neutral, public motive: Norm, public base: Norm, public step: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndList(\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IndAbsurd extends Neutral {\n  constructor(public target: Neutral, public motive: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    // Here's some Absurd . The rest is in -equiv?.\n    return new C.IndAbsurd(\n      new C.The(\n        new C.Absurd(),\n        this.target.readBackNeutral(context)\n      ),\n      readBack(context, this.motive.type, this.motive.value)\n    );\n  }\n}\n\nexport class Replace extends Neutral {\n  constructor(public target: Neutral, public motive: Norm, public base: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Replace(\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value)\n    );\n  }\n}\n\nexport class Trans1 extends Neutral {\n  constructor(public target1: Neutral, public target2: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Trans(\n      this.target1.readBackNeutral(context),\n      readBack(context, this.target2.type, this.target2.value)\n    );\n  }\n}\n\nexport class Trans2 extends Neutral {\n  constructor(public target1: Norm, public target2: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Trans(\n      readBack(context, this.target1.type, this.target1.value),\n      this.target2.readBackNeutral(context)\n    )\n  }\n}\n\nexport class Trans12 extends Neutral {\n  constructor(public target1: Neutral, public target2: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Trans(\n      this.target1.readBackNeutral(context),\n      this.target2.readBackNeutral(context)\n    )\n  }\n}\n\nexport class Cong extends Neutral {\n  constructor(public target: Neutral, public func: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    const funcType = this.func.type;\n    if (funcType instanceof Pi) {\n      const closure = funcType.resultType;\n      return new C.Cong(\n        this.target.readBackNeutral(context),\n        closure\n          .valOfClosure(new Absurd())\n          .readBackType(context),\n        readBack(context, this.func.type, this.func.value)\n      );\n    } else {\n      throw new Error(\"Cong applied to non-Pi type.\");\n    }\n  }\n}\n\nexport class Symm extends Neutral {\n  constructor(public target: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Symm(this.target.readBackNeutral(context));\n  }\n}\n\nexport class IndEqual extends Neutral {\n  constructor(public target: Neutral, public motive: Norm, public base: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndEqual(\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value)\n    );\n  }\n}\n\nexport class Head extends Neutral {\n  constructor(public target: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Head(this.target.readBackNeutral(context));\n  }\n}\n\nexport class Tail extends Neutral {\n  constructor(public target: Neutral) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Tail(this.target.readBackNeutral(context));\n  }\n}\n\nexport class IndVec1 extends Neutral {\n  constructor(\n    public length: Neutral,\n    public target: Norm,\n    public motive: Norm,\n    public base: Norm,\n    public step: Norm\n  ) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n      return new C.IndVec(\n        this.length.readBackNeutral(context),\n        readBack(context, this.target.type, this.target.value),\n        readBack(context, this.motive.type, this.motive.value),\n        readBack(context, this.base.type, this.base.value),\n        readBack(context, this.step.type, this.step.value\n      ));\n  }\n}\n\nexport class IndVec2 extends Neutral {\n  constructor(\n    public length: Norm,\n    public target: Neutral,\n    public motive: Norm,\n    public base: Norm,\n    public step: Norm\n  ) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndVec(\n      readBack(context, this.length.type, this.length.value),\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IndVec12 extends Neutral {\n  constructor(\n    public length: Neutral,\n    public target: Neutral,\n    public motive: Norm,\n    public base: Norm,\n    public step: Norm\n  ) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndVec(\n      this.length.readBackNeutral(context),\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.base.type, this.base.value),\n      readBack(context, this.step.type, this.step.value)\n    );\n  }\n}\n\nexport class IndEither extends Neutral {\n  constructor(\n    public target: Neutral,\n    public motive: Norm,\n    public baseLeft: Norm,\n    public baseRight: Norm\n  ) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.IndEither(\n      this.target.readBackNeutral(context),\n      readBack(context, this.motive.type, this.motive.value),\n      readBack(context, this.baseLeft.type, this.baseLeft.value),\n      readBack(context, this.baseRight.type, this.baseRight.value)\n    );\n  }\n}\n\nexport class Application extends Neutral {\n  constructor(public operator: Neutral, public operand: Norm) {\n    super();\n  }\n\n  public readBackNeutral(context: Context): C.Core {\n    return new C.Application(\n      this.operator.readBackNeutral(context),\n      readBack(context, this.operand.type, this.operand.value)\n    );\n  }\n}\n\n// Predicate function to check if an object is Neutral\nexport function isNeutral(obj: any): obj is Neutral {\n  return obj instanceof Neutral;\n}\n","import * as util from \"util\";\nimport * as V from \"../types/value\";\nimport * as N from \"../types/neutral\";\nimport { HigherOrderClosure } from '../types/utils';\nimport { natEqual } from './utils';\n\n/*\n  ### The Evaluators ###\n\n  Functions whose names begin with \"do-\" are helpers that implement\n  the corresponding eliminator.\n*/\n\nexport function doApp(operator: V.Value, operand: V.Value): V.Value {\n  const operatorNow = operator.now();\n  if (operatorNow instanceof V.Lambda) {\n    return operatorNow.body.valOfClosure(operand);\n  } else if (operatorNow instanceof V.Neutral) {\n    const typeNow = operatorNow.type.now();\n    if (typeNow instanceof V.Pi) {\n      return new V.Neutral(\n        typeNow.resultType.valOfClosure(operand),\n        new N.Application(\n          operatorNow.neutral,\n          new N.Norm(typeNow.argType, operand)\n        )\n      );\n    }\n  }\n  throw new Error(`doApp: invalid input ${util.inspect([operatorNow, operand])}`);\n}\n\nexport function doWhichNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Zero) {\n    return base;\n  } else if (targetNow instanceof V.Add1) {\n    return doApp(step, targetNow.smaller);\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Nat) {\n      return new V.Neutral(\n        baseType,\n        new N.WhichNat(\n          targetNow.neutral,\n          new N.Norm(baseType, base),\n          new N.Norm(\n            new V.Pi(\n              \"n\",\n              new V.Nat(),\n              new HigherOrderClosure((_) => baseType)),\n            step)\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for whichNat ${util.inspect([target, baseType, base, step])}`);\n}\n\nexport function doIterNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Zero) {\n    return base;\n  } else if (targetNow instanceof V.Add1) {\n    return doApp(\n      step,\n      doIterNat(targetNow.smaller, baseType, base, step)\n    );\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Nat) {\n      return new V.Neutral(baseType, new N.IterNat(\n        targetNow.neutral,\n        new N.Norm(baseType, base),\n        new N.Norm(\n          new V.Pi(\n            \"n\",\n            new V.Nat(),\n            new HigherOrderClosure((_) => baseType)),\n          step)\n      )\n      );\n    }\n  }\n  throw new Error(`invalid input for iterNat ${util.inspect([target, baseType, base, step])}`);\n}\n\nexport function doRecNat(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Zero) {\n    return base;\n  } else if (targetNow instanceof V.Add1) {\n    return doApp(\n      step,\n      doRecNat(targetNow.smaller, baseType, base, step)\n    );\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Nat) {\n      return new V.Neutral(baseType, new N.RecNat(\n        targetNow.neutral,\n        new N.Norm(baseType, base),\n        new N.Norm(\n          new V.Pi(\n            \"n-1\",\n            new V.Nat(),\n            new HigherOrderClosure(\n              (_) => new V.Pi(\n                \"ih\",\n                baseType,\n                new HigherOrderClosure(\n                  (_) => baseType\n                )\n              )\n            )\n          ),\n          step\n        )\n      ));\n    }\n  }\n  throw new Error(`invalid input for recNat ${util.inspect([target, baseType, base, step])}`);\n\n}\n\nexport function doIndNat(target: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Zero) {\n    return base;\n  } else if (targetNow instanceof V.Add1) {\n    return doApp(\n      doApp(step, targetNow.smaller),\n      doIndNat(targetNow.smaller, motive, base, step)\n    );\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Nat) {\n      return new V.Neutral(\n        doApp(motive, target),\n        new N.IndNat(\n          targetNow.neutral,\n          new N.Norm(new V.Pi(\n            \"x\",\n            new V.Nat(),\n            new HigherOrderClosure((_) => new V.Universe())\n          ), motive),\n          new N.Norm(doApp(motive, new V.Zero()), base),\n          new N.Norm(\n            new V.Pi(\n              \"n-1\",\n              new V.Nat(),\n              new HigherOrderClosure(\n                (n_minus_1) =>\n                  new V.Pi(\n                    \"ih\",\n                    doApp(motive, n_minus_1),\n                    new HigherOrderClosure(\n                      (_) => doApp(motive, new V.Add1(n_minus_1))\n                    )\n                  )\n              )\n            ), step\n          )\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for indNat ${util.inspect([target, motive, base, step])}`);\n\n}\n\n\nexport function doCar(pair: V.Value): V.Value {\n  const pairNow: V.Value = pair.now();\n  if (pairNow instanceof V.Cons) {\n    return pairNow.car;\n  } else if (pairNow instanceof V.Neutral) {\n    const pairType = pairNow.type.now();\n    if (pairType instanceof V.Sigma) {\n      const sigma = pairType;\n      const neutral = pairNow.neutral;\n      return new V.Neutral(sigma.carType, new N.Car(neutral));\n    }\n  }\n  throw new Error(`invalid input for car ${util.inspect(pair)}`);\n\n}\n\n\nexport function doCdr(pair: V.Value): V.Value {\n  const pairNow: V.Value = pair.now();\n  if (pairNow instanceof V.Cons) {\n    return pairNow.cdr;\n  } else if (pairNow instanceof V.Neutral) {\n    const pairType = pairNow.type.now();\n    if (pairType instanceof V.Sigma) {\n      const sigma = pairType;\n      const neutral = pairNow.neutral;\n      return new V.Neutral(\n        sigma.cdrType.valOfClosure(doCar(pair)),\n        new N.Cdr(neutral)\n      );\n    }\n\n  }\n  throw new Error(`invalid input for cdr ${util.inspect(pair)}`);\n\n}\n\n\nexport function doIndList(target: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Nil) {\n    return base;\n  } else if (targetNow instanceof V.ListCons) {\n    return doApp(\n      doApp(\n        doApp(\n          step,\n          targetNow.head\n        ),\n        targetNow.tail\n      ),\n      doIndList(targetNow.tail, motive, base, step)\n    );\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.List) {\n      const entryType = typeNow.entryType;\n      const neutral = targetNow.neutral;\n      const motiveType = new V.Pi(\n        \"xs\",\n        new V.List(entryType),\n        new HigherOrderClosure((_) => new V.Universe())\n      );\n      return new V.Neutral(\n        doApp(motive, target),\n        new N.IndList(\n          neutral,\n          new N.Norm(motiveType, motive),\n          new N.Norm(doApp(motive, new V.Nil()), base),\n          new N.Norm(\n            new V.Pi(\n              \"h\",\n              entryType,\n              new HigherOrderClosure((h) =>\n                new V.Pi(\n                  \"t\",\n                  new V.List(entryType),\n                  new HigherOrderClosure((t) =>\n                    new V.Pi(\n                      \"ih\",\n                      doApp(motive, t),\n                      new HigherOrderClosure((_) =>\n                        doApp(motive, new V.ListCons(h, t))\n                      )\n                    )\n                  )\n                )\n              )\n            ),\n            step\n          )\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for indList ${util.inspect([targetNow, motive, base, step])}`);\n\n}\n\nexport function doRecList(target: V.Value, baseType: V.Value, base: V.Value, step: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Nil) {\n    return base;\n  } else if (targetNow instanceof V.ListCons) {\n    const head = targetNow.head;\n    const tail = targetNow.tail;\n    return doApp(\n      doApp(\n        doApp(step, head),\n        tail),\n      doRecList(tail, baseType, base, step)\n    );\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.List) {\n      const entryType = typeNow.entryType;\n      const neutral = targetNow.neutral;\n      return new V.Neutral(\n        baseType,\n        new N.RecList(\n          neutral,\n          new N.Norm(baseType, base),\n          new N.Norm(\n            new V.Pi(\n              \"h\",\n              entryType,\n              new HigherOrderClosure((_) =>\n                new V.Pi(\n                  \"t\",\n                  new V.List(entryType),\n                  new HigherOrderClosure((_) =>\n                    new V.Pi(\n                      \"ih\",\n                      baseType,\n                      new HigherOrderClosure((_) =>\n                        baseType,\n                      )\n                    )\n                  )\n                )\n              )\n            ),\n            step\n          ),\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for recList ${util.inspect([targetNow, baseType, base, step])}`);\n\n}\n\n\nexport function doIndAbsurd(target: V.Value, motive: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Absurd) {\n      return new V.Neutral(\n        motive,\n        new N.IndAbsurd(\n          targetNow.neutral,\n          new N.Norm(new V.Universe(), motive)\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for indAbsurd ${util.inspect([target, motive])}`);\n}\n\n\nexport function doReplace(target: V.Value, motive: V.Value, base: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Same) {\n    return base;\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Equal) {\n      const neutral = targetNow.neutral;\n      const eqType = typeNow.type;\n      const from = typeNow.from;\n      const to = typeNow.to;\n      return new V.Neutral(\n        doApp(motive, to),\n        new N.Replace(\n          neutral,\n          new N.Norm(\n            new V.Pi(\n              \"x\",\n              eqType,\n              new HigherOrderClosure(\n                (_) => new V.Universe()\n              )\n            ),\n            motive\n          ),\n          new N.Norm(doApp(motive, from), base)\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for replace ${util.inspect([target, motive, base])}`);\n\n}\n\n\nexport function doTrans(target1: V.Value, target2: V.Value): V.Value {\n  const target1Now = target1.now();\n  const target2Now = target2.now();\n  if (target1Now instanceof V.Same && target2Now instanceof V.Same) {\n    return new V.Same(target1Now.value);\n  } else if (target1Now instanceof V.Same && target2Now instanceof V.Neutral) {\n    const type2Now = target2Now.type.now();\n    if (type2Now instanceof V.Equal) {\n      const from = target1Now.value;\n      const to = type2Now.to;\n      const eqType = type2Now.type;\n      const neutral2 = target2Now.neutral;\n      return new V.Neutral(\n        new V.Equal(eqType, from, to),\n        new N.Trans2(\n          new N.Norm(\n            new V.Equal(eqType, from, from),\n            new V.Same(from)\n          ),\n          neutral2\n        )\n      )\n    }\n  } else if (target1Now instanceof V.Neutral && target2Now instanceof V.Same) {\n    const type1Now = target1Now.type.now();\n    if (type1Now instanceof V.Equal) {\n      const from = type1Now.from;\n      const to = target2Now.value;\n      const eqType = type1Now.type;\n      const neutral1 = target1Now.neutral;\n      return new V.Neutral(\n        new V.Equal(eqType, from, to),\n        new N.Trans1(\n          neutral1,\n          new N.Norm(\n            new V.Equal(eqType, to, to),\n            new V.Same(to)\n          )\n        )\n      );\n    }\n  } else if (\n    target1Now instanceof V.Neutral && target2Now instanceof V.Neutral) {\n    const type1Now = target1Now.type.now();\n    const type2Now = target2Now.type.now();\n    if (type1Now instanceof V.Equal && type2Now instanceof V.Equal) {\n      const from = type1Now.from;\n      const to = type2Now.to;\n      const eqType = type1Now.type;\n      const neutral1 = target1Now.neutral;\n      const neutral2 = target2Now.neutral;\n      return new V.Neutral(\n        new V.Equal(eqType, from, to),\n        new N.Trans12(neutral1, neutral2)\n      );\n    }\n  }\n  throw new Error(`invalid input for do-trans: ${util.inspect([target1, target2])}`);\n}\n\n\nexport function doCong(target: V.Value, base: V.Value, func: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Same) {\n    return new V.Same(doApp(func, targetNow.value));\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Equal) {\n      const eqType = typeNow.type;\n      const from = typeNow.from;\n      const to = typeNow.to;\n      const neutral = targetNow.neutral;\n      return new V.Neutral(\n        new V.Equal(\n          base,\n          doApp(func, from),\n          doApp(func, to)\n        ),\n        new N.Cong(\n          neutral,\n          new N.Norm(\n            new V.Pi(\n              \"x\",\n              eqType,\n              new HigherOrderClosure((x) => base)\n            ),\n            func\n          )\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for cong ${util.inspect([target, base, func])}`);\n}\n\nexport function doSymm(target: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Same) {\n    return new V.Same(targetNow.value);\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Equal) {\n      return new V.Neutral(\n        new V.Equal(\n          typeNow.type,\n          typeNow.to,\n          typeNow.from\n        ),\n        new N.Symm(targetNow.neutral)\n      );\n    }\n  }\n  throw new Error(`invalid input for symm ${util.inspect(target)}`);\n}\n\n\nexport function doIndEqual(target: V.Value, motive: V.Value, base: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Same) {\n    return base;\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Equal) {\n      const eqType = typeNow.type;\n      const from = typeNow.from;\n      const to = typeNow.to;\n      const neutral = targetNow.neutral;\n      return new V.Neutral(\n        doApp(doApp(motive, to), target),\n        new N.IndEqual(\n          neutral,\n          new N.Norm(\n            new V.Pi(\n              \"to\",\n              eqType,\n              new HigherOrderClosure(\n                (to) => new V.Pi(\n                  \"p\",\n                  new V.Equal(eqType, from, to),\n                  new HigherOrderClosure(\n                    (_) => new V.Universe()\n                  )\n                )\n              )\n            ),\n            motive\n          ),\n          new N.Norm(\n            doApp(doApp(motive, from), new V.Same(from)),\n            base\n          )\n        )\n      );\n    }\n  }\n  throw new Error(`invalid input for indEqual ${util.inspect([target, motive, base])}`);\n}\n\nexport function doHead(target: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.VecCons) {\n    return targetNow.head;\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Vec) {\n      const lengthNow = typeNow.length.now();\n      if (lengthNow instanceof V.Add1) {\n        return new V.Neutral(\n          typeNow.entryType,\n          new N.Head(targetNow.neutral)\n        );\n      }\n    }\n  }\n  throw new Error(`invalid input for head ${util.inspect(target)}`);\n}\n\n\nexport function doTail(target: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.VecCons) {\n    return targetNow.tail;\n  } else if (targetNow instanceof V.Neutral &&\n    targetNow.type instanceof V.Vec &&\n    targetNow.type.length instanceof V.Add1) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Vec) {\n      const lengthNow = typeNow.length.now();\n      if (lengthNow instanceof V.Add1) {\n        return new V.Neutral(\n          new V.Vec(\n            targetNow.type.entryType,\n            targetNow.type.length.smaller\n          ),\n          new N.Tail(targetNow.neutral)\n        );\n      }\n    }\n  }\n  throw new Error(`invalid input for tail ${util.inspect(target)}`);\n}\n\nexport function indVecStepType(Ev: V.Value, mot: V.Value): V.Value {\n  return new V.Pi(\n    \"k\",\n    new V.Nat(),\n    new HigherOrderClosure(\n      (k) => new V.Pi(\n        \"e\",\n        new V.Vec(Ev, k),\n        new HigherOrderClosure(\n          (e) => new V.Pi(\n            \"es\",\n            new V.Vec(Ev, k),\n            new HigherOrderClosure(\n              (es) => new V.Pi(\n                \"ih\",\n                doApp(doApp(mot, k), es),\n                new HigherOrderClosure(\n                  (_) =>\n                    doApp(\n                      doApp(mot, new V.Add1(k)),\n                      new V.VecCons(e, es)\n                    )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  );\n}\n\n\nexport function doIndVec(len: V.Value, vec: V.Value, motive: V.Value, base: V.Value, step: V.Value): V.Value {\n  const lenNow = len.now();\n  const vecNow = vec.now();\n  if (lenNow instanceof V.Zero && vecNow instanceof V.VecNil) {\n    return base;\n  } else if (lenNow instanceof V.Add1 && vecNow instanceof V.VecCons) {\n    return doApp(\n      doApp(\n        doApp(\n          doApp(step, lenNow.smaller),\n          vecNow.head\n        ),\n        doTail(vec)\n      ),\n      doIndVec(\n        lenNow.smaller,\n        vecNow.tail,\n        motive,\n        base,\n        step\n      )\n    );\n  } else if (lenNow instanceof V.Neutral && vecNow instanceof V.Neutral\n    && lenNow.type instanceof V.Nat && vecNow.type instanceof V.Vec) {\n    const entryType = vecNow.type.entryType;\n    return new V.Neutral(\n      doApp(doApp(motive, len), vec),\n      new N.IndVec12(\n        lenNow.neutral,\n        vecNow.neutral,\n        new N.Norm(\n          new V.Pi(\n            \"k\",\n            new V.Nat(),\n            new HigherOrderClosure(\n              (k) => new V.Pi(\n                \"es\",\n                new V.Vec(entryType, k),\n                new HigherOrderClosure(\n                  (_) => new V.Universe()\n                )\n              )\n            )\n          ),\n          motive\n        ),\n        new N.Norm(\n          doApp(\n            doApp(motive, new V.Zero), new V.VecNil()\n          ),\n          base\n        ),\n        new N.Norm(\n          indVecStepType(\n            vecNow.type.entryType, motive), step)\n      )\n    );\n  } else if (natEqual(lenNow, len) && vecNow instanceof V.Neutral && vecNow.type instanceof V.Vec) {\n    const entryType = vecNow.type.entryType;\n    return new V.Neutral(\n      doApp(doApp(motive, len), vec),\n      new N.IndVec2(\n        new N.Norm(new V.Nat(), len),\n        vecNow.neutral,\n        new N.Norm(\n          new V.Pi(\n            \"k\",\n            new V.Nat(),\n            new HigherOrderClosure(\n              (k) => new V.Pi(\n                \"es\",\n                new V.Vec(entryType, k),\n                new HigherOrderClosure(\n                  (_) => new V.Universe()\n                )\n              )\n            )\n          ),\n          motive\n        ),\n        new N.Norm(\n          doApp(\n            doApp(motive, new V.Nat()),\n            new V.VecNil\n          ),\n          base),\n        new N.Norm(\n          indVecStepType(\n            entryType, motive\n          ),\n          step\n        ),\n      )\n    );\n  } else {\n    throw new Error(`invalid input for indVec ${util.inspect([len, vec, motive, base, step])}`);\n  }\n}\n\nexport function doIndEither(target: V.Value, motive: V.Value, left: V.Value, right: V.Value): V.Value {\n  const targetNow = target.now();\n  if (targetNow instanceof V.Left) {\n    return doApp(left, targetNow.value);\n  } else if (targetNow instanceof V.Right) {\n    return doApp(right, targetNow.value);\n  } else if (targetNow instanceof V.Neutral) {\n    const typeNow = targetNow.type.now();\n    if (typeNow instanceof V.Either) {\n      const leftType = typeNow.leftType;\n      const rightType = typeNow.rightType;\n      const motiveType = new V.Pi(\n        \"x\",\n        new V.Either(leftType, rightType),\n        new HigherOrderClosure((x) => new V.Universe())\n      )\n      return new V.Neutral(\n        doApp(motive, target),\n        new N.IndEither(\n          targetNow.neutral,\n          new N.Norm(motiveType, motive),\n          new N.Norm(\n            new V.Pi(\n              \"x\",\n              leftType,\n              new HigherOrderClosure(\n                (x) => doApp(motive, new V.Left(x))\n              )\n            ),\n            left\n          ),\n          new N.Norm(\n            new V.Pi(\n              \"x\",\n              rightType,\n              new HigherOrderClosure(\n                (x) => doApp(motive, new V.Right(x))\n              )\n            ),\n            right\n          )\n        )\n      )\n    }\n  }\n  throw new Error(`invalid input for indEither: ${util.inspect([target, motive, left, right])}`);\n}","import * as V from \"../types/value\";\nimport * as C from '../types/core';\nimport * as N from '../types/neutral';\nimport { fresh } from '../types/utils';\nimport { bindFree, Context } from '../utils/context';\nimport { doApp, doCar, doCdr } from \"./evaluator\";\nimport * as util from 'util';\n\n/**\n *   ## Call-by-need evaluation ##\n\n  Pie is a total language, which means that every program will\n  eventually terminate. Because the steps taken during evaluation are\n  completely deterministic, and because Pie is total, it is\n  acceptable to choose any order of evaluation.\n\n  On the other hand, many useful Pie programs will take many more\n  evaluation steps to complete when using strict evaluation. For\n  instance, consider zerop from chapter 3 of The Little Typer. zerop\n  returns 'nil when its argument's value has V_Add1 at the top, or 't\n  if it is zero. If (zerop (double 10000)) is evaluated strictly, the\n  evaluator will first need to find out that (double 10000) is 20000,\n  requiring 10000 steps.  On the other hand, if it is evaluated\n  lazily, then it will need only one step to discover that the value\n  has V_Add1 at the top.\n\n  Pie uses call-by-need evaluation. This means that if two different\n  expressions make use of some expression, such as a definition, then\n  evaluation steps will be shared between them and will not need to\n  be repeated.\n\n  Call-by-need evaluation is achieved by introducing a new value that\n  represents evaluation that has not yet been performed, but should\n  instead be performed on demand. That value, which doesn't represent\n  any value in the Pie sense of the word, is called DELAY and is\n  defined in basics.rkt. When DELAY represents work that has not yet\n  been done, it is filled with a special kind of closure called\n  DELAY-CLOS that pairs an expression with its environment.\n\n  Not every DELAY represents evaluation that has not yet been\n  performed. Some represent evaluation that was already demanded by\n  some other operator. The work is shared by updating the contents of\n  DELAY with an actual value.\n\n  later is used to delay evaluation by constructing a DELAY value\n  that contains a DELAY-CLOS closure.\n*/\n\n// undelay is used to find the value that is contained in a\n// DELAY-CLOS closure by invoking the evaluator.\n/* export function undelay(c: V.DelayClosure): V.Value {\n  return now(c.expr.valOf(c.env));\n} */\n\n/*\n  now demands the _actual_ value represented by a DELAY. If the value\n  is a DELAY-CLOS, then it is computed using undelay. If it is\n  anything else, then it has already been computed, so it is\n  returned.\n  \n  now should be used any time that a value is inspected to see what\n  form it has, because those situations require that the delayed\n  evaluation steps be carried out.\n*/\n/* export function now(todo: V.Value): V.Value {\n  if (todo instanceof V.Delay) { //todo.val is nessarily a Box\n    const box = todo.val;\n    const content = box.get();\n    if (content instanceof V.DelayClosure) {\n      let theValue = undelay(content);\n      box.set(theValue);\n      return theValue;\n    } else { // content is a Value (content instanceof Value).\n      return box.get() as V.Value;\n    }\n  }\n  return todo;\n} */\n\nexport function natEqual(nat1: V.Value, nat2: V.Value): boolean {\n  const nat1Now = nat1.now();\n  const nat2Now = nat2.now();\n  if (nat1Now instanceof V.Zero && nat2Now instanceof V.Zero) {\n    return true;\n  } else if (nat1Now instanceof V.Add1 && nat2Now instanceof V.Add1) {\n    return natEqual(nat1Now.smaller, nat2Now.smaller);\n  } else {\n    return false;\n  }\n}\n\nexport function readBack(context: Context, type: V.Value, value: V.Value): C.Core {\n  const typeNow = type.now();\n  const valueNow = value.now();\n\n  if (typeNow instanceof V.Universe) {\n    return value.readBackType(context);\n  } else if (typeNow instanceof V.Nat\n    && valueNow instanceof V.Zero) {\n    return new C.Zero();\n  } else if (typeNow instanceof V.Nat\n    && valueNow instanceof V.Add1) {\n    return new C.Add1(\n      readBack(context, new V.Nat(), valueNow.smaller)\n    );\n  } else if (typeNow instanceof V.Pi) {\n    const y = valueNow instanceof V.Lambda ?\n      valueNow.argName : typeNow.argName;\n    const freshx = fresh(context, y);\n    return new C.Lambda(freshx, readBack(\n      bindFree(context, freshx, typeNow.argType),\n      typeNow.resultType.valOfClosure(\n        new V.Neutral(typeNow.argType, new N.Variable(freshx))\n      ),\n      doApp(\n        valueNow,\n        new V.Neutral(typeNow.argType, new N.Variable(freshx))\n      )\n    ));\n  } else if (typeNow instanceof V.Sigma) {\n    const car = doCar(value);\n    const cdr = doCdr(value);\n    return new C.Cons(\n      readBack(context, typeNow.carType, car),\n      readBack(\n        context,\n        typeNow.cdrType.valOfClosure(car),\n        cdr\n      )\n    );\n  } else if (typeNow instanceof V.Atom\n    && valueNow instanceof V.Quote) {\n    return new C.Quote(valueNow.name);\n  } else if (typeNow instanceof V.Trivial) {\n    return new C.Sole();\n  } else if (typeNow instanceof V.List\n    && valueNow instanceof V.Nil) {\n    return new C.Nil();\n  } else if (typeNow instanceof V.List\n    && valueNow instanceof V.ListCons) {\n    return new C.Cons(\n      readBack(context, typeNow.entryType, valueNow.head),\n      readBack(context, new V.List(typeNow.entryType), valueNow.tail));\n  } else if (typeNow instanceof V.Absurd\n    && valueNow instanceof V.Neutral) {\n    return new C.The(\n      new C.Absurd(),\n      valueNow.neutral.readBackNeutral(context)\n    );\n  } else if (typeNow instanceof V.Equal\n    && valueNow instanceof V.Same) {\n    return new C.Same(\n      readBack(context, typeNow.type, valueNow.value));\n  } else if (typeNow instanceof V.Vec\n    && typeNow.length instanceof V.Zero\n    && valueNow instanceof V.VecNil) {\n    return new C.VecNil();\n  } else if (typeNow instanceof V.Vec\n    && typeNow.length instanceof V.Add1\n    && valueNow instanceof V.VecCons) {\n    return new C.VecCons(\n      readBack(context, typeNow.entryType, valueNow.head),\n      readBack(\n        context,\n        new V.Vec(typeNow.entryType, typeNow.length.smaller),\n        valueNow.tail\n      )\n    );\n  } else if (typeNow instanceof V.Either\n    && valueNow instanceof V.Left) {\n    return new C.Left(\n      readBack(context, typeNow.leftType, valueNow.value)\n    );\n  } else if (typeNow instanceof V.Either\n    && valueNow instanceof V.Right) {\n    return new C.Right(\n      readBack(context, typeNow.rightType, valueNow.value)!\n    );\n  } else if (valueNow instanceof V.Neutral) {\n    return valueNow.neutral.readBackNeutral(context);\n  }\n  throw new Error(`Cannot read back ${valueNow} : ${typeNow}`);\n}","import { Neutral, Value } from '../types/value';\nimport { Location } from './locations';\nimport * as C from '../types/core';\nimport { go, stop, Perhaps, goOn, PerhapsM, Message } from '../types/utils';\nimport { Environment } from './environment';\nimport { readBack } from '../evaluator/utils';\nimport { Source } from '../types/source';\nimport { Variable } from '../types/neutral';\n/*\n    ## Contexts ##\n    A context maps free variable names to binders.\n*/\n\nexport type Context = Map<string, Binder>\n\n\n\nexport function extendContext(ctx: Context, name: string, binder: Binder): Context {\n  return new Map([...ctx, [name, binder]]);\n}\n\n/*\n  Find the value of an expression in the environment that\n  corresponds to a context.\n*/\nexport function valInContext(ctx: Context, expr: C.Core): Value {\n  return expr.valOf(contextToEnvironment(ctx));\n}\n\nexport function readBackContext(ctx: Context): SerializableContext {\n  const result = new Map();\n  for (const [x, binder] of ctx) {\n    if (binder instanceof Free) {\n      result.set(x, ['free', binder.type.readBackType(ctx)]);\n    } else if (binder instanceof Define) {\n      result.set(x,\n        ['def',\n          binder.type.readBackType(ctx),\n          readBack(ctx, binder.type, binder.value)\n        ]\n      );\n    } else if (binder instanceof Claim) {\n      result.set(x,\n        ['claim', binder.type.readBackType(ctx)]);\n    }\n  }\n  return result;\n}\n\nexport function nameNotUsed(ctx: Context, where: Location, name: string) {\n  if (ctx.has(name)) {\n    return new stop(\n      where,\n      new Message([`The name \"${name}\" is already in use in the context.`])\n    );\n  } else return new go<boolean>(true);\n}\n\nexport function getClaim(ctx: Context, where: Location, name: string): Perhaps<Value> {\n  for (const [x, binder] of ctx) {\n    if (x === name) {\n      if (binder instanceof Define) {\n        return new stop(where, new Message([`The name \"${name}\" is already defined.`]))\n      } else if (binder instanceof Claim) {\n        return new go<Value>(binder.type);\n      }\n    }\n  }\n  return new stop(where, new Message([`No claim: ${name}`]));\n}\n\nexport function addClaimToContext(ctx: Context, fun: string, funLoc: Location, type: Source): Perhaps<Context> {\n  const typeOut = new PerhapsM<C.Core>(\"typeOut\")\n  return goOn(\n    [\n      [new PerhapsM(\"_\"), () => nameNotUsed(ctx, funLoc, fun)],\n      [typeOut, () => type.isType(ctx, new Map())]\n    ],\n    () => new go(\n      extendContext(\n        ctx,\n        fun, \n        new Claim(valInContext(ctx, typeOut.value))\n      )\n    )\n  )\n}\n\nexport function removeClaimFromContext(ctx: Context, name: string): Context {\n  ctx.delete(name);\n  return ctx;\n}\n\nexport function addDefineToContext(ctx: Context,fun: string, funLoc: Location, expr: Source): Perhaps<Context> {\n  const typeOut = new PerhapsM<Value>(\"typeOut\");\n  const exprOut = new PerhapsM<C.Core>(\"exprOut\");\n  return goOn(\n    [\n      [typeOut, () => getClaim(ctx, funLoc, fun)],\n      [exprOut,\n        () => expr.check(\n          ctx,\n          new Map(),\n          typeOut.value)\n      ]\n    ],\n    () => new go(\n      bindVal(\n        removeClaimFromContext(ctx, fun),\n        fun,\n        typeOut.value,\n        valInContext(ctx, exprOut.value)\n      )\n    )\n  )\n}\n\nexport function contextToEnvironment(ctx: Context): Environment {\n  if (ctx.size === 0) {\n    return new Map();\n  }\n  const bindings = ctx.entries();\n  const env = new Map();\n  for (const [name, binder] of bindings) {\n    if (binder instanceof Define) {\n      env.set(name, binder.value);\n    } else if (binder instanceof Free) {\n      env.set(name, new Neutral(binder.type, new Variable(name)));\n    } // else continue;\n  }\n  return env;\n}\n\n\n\n\nexport const initCtx: Context = new Map();\n\n// There are three kinds of binders: a free binder represents a free\n// variable, that was bound in some larger context by , , or . A\n// def binder represents a name bound by define. A claim binder\n// doesn't actually bind a name; however, it reserves the name for\n// later definition with define and records the type that will be\n// used.\n\nexport abstract class Binder {\n  abstract type: Value;\n}\n\nexport class Claim extends Binder {\n  constructor(public type: Value) { super() }\n}\n\nexport class Define extends Binder {\n  constructor(public type: Value, public value: Value) { super() }\n}\n\nexport class Free extends Binder {\n  constructor(public type: Value) { super() }\n}\n\nexport function varType(ctx: Context, where: Location, x: string): Perhaps<Value> {\n  if (ctx.size === 0) {\n    throw new Error(`Unknown variable ${x}`);\n  }\n  for (const [y, binder] of ctx.entries()) {\n    if (binder instanceof Claim) {\n      continue;\n    } else if (x === y) {\n      return new go(binder.type);\n    }\n  }\n  throw new Error(`Unknown variable ${x}`);\n}\n\n// Function to bind a free variable in a context\nexport function bindFree(ctx: Context, varName: string, tv: Value): Context {\n  if (ctx.has(varName)) {\n    // CHANGE: REMOVE ctx LOOP AFTER FIXING THE BUG\n    for (const [x, binder] of ctx) {\n      if (x === varName) {\n        //console.log(`binding ${varName} to ${binder}`);\n        return extendContext(ctx, varName, new Free(tv));\n      }\n    }\n    throw new Error(`\n      ${varName} is already bound in ${JSON.stringify(ctx)}\n    `);\n  }\n  return extendContext(ctx, varName, new Free(tv));\n}\n\n// Function to bind a value in a context\nexport function bindVal(ctx: Context, varName: string, type: Value, value: Value): Context {\n  return extendContext(ctx, varName, new Define(type, value));\n}\n\n\n// For informationa bout serializable contexts, see the comments in\n// normalize.rkt.\nexport type SerializableContext = \n  Map<string, ['free', C.Core] | ['def', C.Core, C.Core] | ['claim', C.Core]>;\n\n// Predicate to check if something is a serializable context\nexport function isSerializableContext(ctx: any): ctx is SerializableContext {\n  return ctx instanceof Map && Array.from(ctx.values()).every(value => {\n    return Array.isArray(value) && \n           (\n            (value[0] === 'free' && value[1] instanceof C.Core) \n            || \n            (value[0] === 'def' && value[1] instanceof C.Core && value[2] instanceof C.Core) \n            || \n            (value[0] === 'claim' && value[2] instanceof C.Core)\n          );\n  });\n}\n\n","import { bindFree, Context } from \"../utils/context\";\nimport * as C from \"./core\";\nimport { Environment } from \"../utils/environment\";\nimport * as N from \"./neutral\";\nimport { Closure } from \"./utils\";\nimport { fresh } from \"./utils\";\nimport { readBack } from \"../evaluator/utils\";\n\n/*\n    ## Values ##\n    \n    In order to type check Pie, it is necessary to find the normal\n    forms of expressions and compare them with each other. The normal\n    form of an expression is determined by its type - types that have\n    -rules (such as , , Trivial, and Absurd) impose requirements on\n    the normal form. For instance, every normal function has  at the\n    top, and every normal pair has cons at the top.\n\n    Finding normal forms has two steps: first, programs are evaluated,\n    much as they are with the Scheme interpreter at the end of The\n    Little Schemer. Then, these values are \"read back\" into the syntax\n    of their normal forms. This happens in normalize.rkt. This file\n    defines the values that expressions can have. Structures or symbols\n    that represent values are written with prefix V_.\n\n    Laziness is implemented by allowing values to be a closure that\n    does not bind a variable. It is described in normalize.rkt (search\n    for \"Call-by-need\").\n*/\n\nexport abstract class Value {\n\n  /*\n  now demands the _actual_ value represented by a DELAY. If the value\n  is a DELAY-CLOS, then it is computed using undelay. If it is\n  anything else, then it has already been computed, so it is\n  returned.\n  \n  now should be used any time that a value is inspected to see what\n  form it has, because those situations require that the delayed\n  evaluation steps be carried out.\n  */\n  public now(): Value {\n    return this;\n  }\n\n  public abstract readBackType(context: Context): C.Core;\n\n  public abstract prettyPrint(): string;\n\n}\n\nexport class DelayClosure {\n  env: Environment;\n  expr: C.Core;\n\n  constructor(env: Environment, expr: C.Core) {\n    this.env = env;\n    this.expr = expr;\n  }\n  /*\n    undelay is used to find the value that is contained in a\n    DELAY-CLOS closure by invoking the evaluator.\n  */\n  public undelay(): Value {\n    return this.expr.valOf(this.env).now();\n  }\n\n  public toString(): string {\n    return `DelayClosure(${this.env}, ${this.expr})`;\n  }\n\n}\n\nexport class Box<Type> {\n  content: Type;\n\n  constructor(value: Type) {\n    this.content = value;\n  }\n\n  public get() {\n    return this.content;\n  }\n  public set(value: Type) {\n    this.content = value;\n  }\n}\n\n\nexport class Delay extends Value {\n\n  constructor(public val: Box<DelayClosure | Value>) { super() }\n\n  public now(): Value {\n    const boxContent = this.val.get();\n    if (boxContent instanceof DelayClosure) {\n      let theValue = boxContent.undelay();\n      this.val.set(theValue);\n      return theValue;\n    } else { // content is a Value (content instanceof Value).\n      return boxContent as Value;\n    }\n  }\n\n  public readBackType(context: Context): C.Core {\n    return this.now().readBackType(context);\n  }\n\n  public prettyPrint(): string {\n    return this.now().prettyPrint();\n  }\n\n  public toString(): string {\n    return `Delay(${this.val})`;\n  }\n\n}\n\nexport class Quote extends Value {\n  constructor(public name: string) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Quote.\");\n  }\n\n  public prettyPrint(): string {\n    return `'${this.name}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Nat extends Value {\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Nat();\n  }\n\n  public prettyPrint(): string {\n    return 'Nat';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Zero extends Value {\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Zero.\");\n  }\n\n  public prettyPrint(): string {\n    return 'zero';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Add1 extends Value {\n\n  constructor(public smaller: Value) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Add1.\");\n  }\n\n  public prettyPrint(): string {\n    return `(add1 ${this.smaller.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Pi extends Value {\n\n  constructor(\n    public argName: string,\n    public argType: Value,\n    public resultType: Closure\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    const Aexpr = this.argType.readBackType(context);\n    const freshedName =  fresh(context, this.argName);\n    const excludeNameCtx = bindFree(context, freshedName, this.argType);\n    return new C.Pi(\n      freshedName,\n      Aexpr,\n      this.resultType\n        .valOfClosure(\n          new Neutral(this.argType, new N.Variable(freshedName))\n        )\n        .readBackType(excludeNameCtx)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `( ${this.argName} ${this.argType.prettyPrint()} ${this.resultType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Lambda extends Value {\n\n  constructor(\n    public argName: string,\n    public body: Closure\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Lambda.\");\n  }\n\n  public prettyPrint(): string {\n    return `(lambda ${this.argName} ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Sigma extends Value {\n  constructor(\n    public carName: string,\n    public carType: Value,\n    public cdrType: Closure\n  ) { super() }\n  \n  public readBackType(context: Context): C.Core {\n    const Aexpr = this.carType.readBackType(context);\n    const freshedName = fresh(context, this.carName);\n    const excludeNameCtx = bindFree(context, freshedName, this.carType);\n    return new C.Sigma(\n      freshedName,\n      Aexpr,\n      this.cdrType\n        .valOfClosure(\n          new Neutral(this.carType, new N.Variable(freshedName))\n        )\n        .readBackType(excludeNameCtx)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `( ${this.carName} ${this.carType.prettyPrint()} ${this.cdrType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cons extends Value {\n\n  constructor(\n    public car: Value,\n    public cdr: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Cons.\");\n  }\n\n  public prettyPrint(): string {\n    return `(cons ${this.car.prettyPrint()} ${this.cdr.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class List extends Value {\n\n  constructor(public entryType: Value) { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.List(this.entryType.readBackType(context));\n  }\n\n  public prettyPrint(): string {\n    return `(List ${this.entryType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Nil extends Value {\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Nil.\");\n  }\n\n  public prettyPrint(): string {\n    return 'nil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class ListCons extends Value {\n\n  constructor(\n    public head: Value,\n    public tail: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for ListCons.\");\n  }\n\n  public prettyPrint(): string {\n    return `(:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\nexport class Equal extends Value {\n\n  constructor(\n    public type: Value,\n    public from: Value,\n    public to: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Equal(\n      this.type.readBackType(context),\n      readBack(context, this.type, this.from),\n      readBack(context, this.type, this.to)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(= ${this.type.prettyPrint()} ${this.from.prettyPrint()} ${this.to.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Same extends Value {\n\n  constructor(public value: Value) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Same.\");\n  }\n\n  public prettyPrint(): string {\n    return `(same ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Vec extends Value {\n\n  constructor(\n    public entryType: Value,\n    public length: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Vec(\n      this.entryType.readBackType(context),\n      readBack(context, new Nat(), this.length)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Vec ${this.entryType.prettyPrint()} ${this.length.prettyPrint()})`;\n  }\n\n}\n\nexport class VecNil extends Value {\n\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for VecNil.\");\n  }\n\n  public prettyPrint(): string {\n    return 'vecnil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VecCons extends Value {\n\n  constructor(\n    public head: Value,\n    public tail: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for VecCons.\");\n  }\n\n  public prettyPrint(): string {\n    return `(vec:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Either extends Value {\n\n  constructor(\n    public leftType: Value,\n    public rightType: Value\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Either(\n      this.leftType.readBackType(context),\n      this.rightType.readBackType(context)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Either ${this.leftType.prettyPrint()} ${this.rightType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Left extends Value {\n\n  constructor(public value: Value) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Left.\");\n  }\n\n  public prettyPrint(): string {\n    return `(left ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Right extends Value {\n  constructor(public value: Value) { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Right.\");\n  }\n\n  public prettyPrint(): string {\n    return `(right ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Neutral extends Value {\n  constructor(\n    public type: Value,\n    public neutral: N.Neutral\n  ) { super() }\n\n  public readBackType(context: Context): C.Core {\n    return this.neutral.readBackNeutral(context);\n  }\n\n  public prettyPrint(): string {\n    return `(neutral ${this.type.prettyPrint()} ${this.neutral.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Universe extends Value {\n\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Universe();\n  }\n\n  public prettyPrint(): string {\n    return 'U';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\n\nexport class Atom extends Value {\n\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Atom();\n  }\n\n  public prettyPrint(): string {\n    return 'Atom';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Trivial extends Value {\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Trivial();\n  }\n\n  public prettyPrint(): string {\n    return 'Trivial';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n}\n\nexport class Sole extends Value {\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    throw new Error(\"No readBackType for Sole.\");\n  }\n\n  public prettyPrint(): string {\n    return 'sole';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\nexport class Absurd extends Value {\n\n  constructor() { super() }\n\n  public readBackType(context: Context): C.Core {\n    return new C.Absurd();\n  }\n\n  public prettyPrint(): string {\n    return 'Absurd';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n  \n}","import * as V from \"./value\";\nimport * as N from './neutral';\n\nimport * as Evaluator from '../evaluator/evaluator';\nimport { Environment, getValueFromEnvironment} from '../utils/environment';\nimport { SourceLocation } from '../utils/locations';\n\nimport { FirstOrderClosure, isVarName } from './utils';\n\n\n/*\n  ### Core Types ###\n\n    Core Pie expressions are the result of type checking (elaborating)\n    an expression written in Pie. They do not have source positions,\n    because they by definition are not written by a user of the\n    implementation.\n\n*/\n\nexport abstract class Core {\n\n  public abstract valOf(env: Environment): V.Value;\n\n  public abstract prettyPrint(): string;\n\n  /*\n    Original \"later\" function. It is used to delay the evaluation.\n  */\n  public toLazy(env: Environment): V.Value {\n    return new V.Delay(new V.Box(new V.DelayClosure(env, this)));\n  }\n\n}\n\nexport class The extends Core {\n\n  constructor(\n    public type: Core,\n    public expr: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return this.expr.valOf(env);\n  }\n\n  public prettyPrint(): string {\n    return `(the ${this.type.prettyPrint()} ${this.expr.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n}\n\nexport class Universe extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Universe();\n  }\n\n  public prettyPrint(): string {\n    return 'U';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Nat extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Nat();\n  }\n\n  public prettyPrint(): string {\n    return 'Nat';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Zero extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Zero();\n  }\n\n  public prettyPrint(): string {\n    return 'zero';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VarName extends Core {\n\n  constructor(\n    public name: string\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    if (isVarName(this.name)) {\n      return getValueFromEnvironment(env, this.name);\n    } else {\n      throw new Error(`{this.name} is not a valid variable name`);\n    }\n  }\n\n  public prettyPrint(): string {\n    return this.name;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Add1 extends Core {\n\n  constructor(\n    public n: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Add1(this.n.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(add1 ${this.n.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class WhichNat extends Core {\n\n  constructor(\n    public target: Core,\n    public base: The,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doWhichNat(\n      this.target.toLazy(env),\n      this.base.type.toLazy(env),\n      this.base.expr.toLazy(env),\n      this.step.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(which-Nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IterNat extends Core {\n\n  constructor(\n    public target: Core,\n    public base: The,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIterNat(\n      this.target.toLazy(env),\n      this.base.type.toLazy(env),\n      this.base.expr.toLazy(env),\n      this.step.toLazy(env)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(iter-Nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class RecNat extends Core {\n\n  constructor(\n    public target: Core,\n    public base: The,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doRecNat(\n      this.target.toLazy(env),\n      this.base.type.toLazy(env),\n      this.base.expr.toLazy(env),\n      this.step.toLazy(env)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(rec-Nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndNat extends Core {\n\n  constructor(\n    public target: Core,\n    public motive: Core,\n    public base: Core,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndNat(\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.base.toLazy(env),\n      this.step.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(ind-Nat ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Pi extends Core {\n\n  constructor(\n    public name: string,\n    public type: Core,\n    public body: Core\n  ) { super() }\n\n\n  public valOf(env: Environment): V.Value {\n    const typeVal = this.type.toLazy(env);\n    return new V.Pi(this.name, typeVal, \n      new FirstOrderClosure(env, this.name, this.body)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `( (${this.name} ${this.type.prettyPrint()}) \n          ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Lambda extends Core {\n\n  constructor(\n    public param: string,\n    public body: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Lambda(this.param, \n      new FirstOrderClosure(env, this.param, this.body));\n  }\n\n  public prettyPrint(): string {\n    return `( (${this.param}) ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Atom extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Atom();\n  }\n\n  public prettyPrint(): string {\n    return 'Atom';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Quote extends Core {\n  constructor(\n    public sym: string\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Quote(this.sym);\n  }\n\n  public prettyPrint(): string {\n    return `'${this.sym}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Sigma extends Core {\n\n  constructor(\n    public name: string,\n    public type: Core,\n    public body: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    const typeVal = this.type.toLazy(env);\n    return new V.Sigma(this.name, typeVal, \n      new FirstOrderClosure(env, this.name, this.body));\n  }\n\n  public prettyPrint(): string {\n    return `( (${this.name} ${this.type.prettyPrint()}) \n              ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cons extends Core {\n\n  constructor(\n    public first: Core,\n    public second: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    const first = this.first.toLazy(env);\n    const second = this.second.toLazy(env);\n    return new V.Cons(first, second);\n  }\n\n  public prettyPrint(): string {\n    return `(cons ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Car extends Core {\n\n  constructor(\n    public pair: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doCar(this.pair.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(car ${this.pair.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cdr extends Core {\n  constructor(\n    public pair: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doCdr(this.pair.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(cdr ${this.pair.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class ListCons extends Core {\n\n  constructor(\n    public head: Core,\n    public tail: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    const head = this.head.toLazy(env);\n    const tail = this.tail.toLazy(env);\n    return new V.ListCons(head, tail);\n  }\n\n  public prettyPrint(): string {\n    return `(:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Nil extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Nil();\n  }\n\n  public prettyPrint(): string {\n    return 'nil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class List extends Core {\n\n  constructor(\n    public elemType: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.List(this.elemType.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(List ${this.elemType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class RecList extends Core {\n\n  constructor(\n    public target: Core,\n    public base: The,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doRecList(\n      this.target.toLazy(env),\n      this.base.type.toLazy(env),\n      this.base.expr.toLazy(env),\n      this.step.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(rec-List ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndList extends Core {\n\n  constructor(\n    public target: Core,\n    public motive: Core,\n    public base: Core,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndList(\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.base.toLazy(env),\n      this.step.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(ind-List ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Trivial extends Core {\n  \n  public valOf(env: Environment): V.Value {\n    return new V.Trivial();\n  }\n\n  public prettyPrint(): string {\n    return 'Trivial';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Sole extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Sole();\n  }\n\n  public prettyPrint(): string {\n    return 'sole';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Absurd extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.Absurd();\n  }\n\n  public prettyPrint(): string {\n    return 'Absurd';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndAbsurd extends Core {\n\n  constructor(\n    public target: Core,\n    public motive: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndAbsurd(\n      this.target.toLazy(env),\n      this.motive.toLazy(env)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(ind-Absurd \n              ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Equal extends Core {\n\n  constructor(\n    public type: Core,\n    public left: Core,\n    public right: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Equal(\n      this.type.toLazy(env),\n      this.left.toLazy(env),\n      this.right.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(= ${this.type.prettyPrint()} \n              ${this.left.prettyPrint()} \n              ${this.right.prettyPrint()})`;  \n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Same extends Core {\n\n  constructor(\n    public type: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Same(this.type.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(same ${this.type.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Replace extends Core {\n\n  constructor(\n    public target: Core,\n    public motive: Core,\n    public base: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doReplace(\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.base.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(replace ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Trans extends Core {\n\n  constructor(\n    public left: Core,\n    public right: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doTrans(\n      this.left.toLazy(env),\n      this.right.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(trans ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cong extends Core {\n\n  constructor(\n    public target: Core,\n    public base: Core,\n    public fun: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doCong(\n      this.target.toLazy(env),\n      this.base.toLazy(env),\n      this.fun.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(cong ${this.target.prettyPrint()} ${this.fun.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Symm extends Core {\n  constructor(\n    public equality: Core\n  ) { super() }\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doSymm(\n      this.equality.toLazy(env)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(symm ${this.equality.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndEqual extends Core {\n  \n  constructor(\n    public target: Core,\n    public motive: Core,\n    public base: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndEqual(\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.base.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(ind-= ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Vec extends Core {\n  constructor(\n    public type: Core,\n    public length: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Vec(\n      this.type.toLazy(env), \n      this.length.toLazy(env)\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Vec ${this.type.prettyPrint()} ${this.length.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VecCons extends Core {\n\n  constructor(\n    public head: Core,\n    public tail: Core\n  ) { super() }\n\n\n  public valOf(env: Environment): V.Value {\n    return new V.VecCons(\n      this.head.toLazy(env),\n      this.tail.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(vec:: ${this.head.prettyPrint()} ${this.tail.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VecNil extends Core {\n\n  public valOf(env: Environment): V.Value {\n    return new V.VecNil();\n  }\n\n  public prettyPrint(): string {\n    return 'vecnil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Head extends Core {\n\n  constructor(\n    public vec: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doHead(this.vec.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(head ${this.vec.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Tail extends Core {\n\n  constructor(\n    public vec: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doTail(this.vec.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(tail ${this.vec.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndVec extends Core {\n\n  constructor(\n    public length: Core,\n    public target: Core,\n    public motive: Core,\n    public base: Core,\n    public step: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndVec(\n      this.length.toLazy(env),\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.base.toLazy(env),\n      this.step.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `ind-Vec ${this.length.prettyPrint()}\n              ${this.target.prettyPrint()}\n              ${this.motive.prettyPrint()}\n              ${this.base.prettyPrint()}\n              ${this.step.prettyPrint()}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Either extends Core {\n\n  constructor(\n    public left: Core,\n    public right: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Either(this.left.toLazy(env), this.right.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(Either ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n  \n}\n\nexport class Left extends Core {\n\n  constructor(\n    public value: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Left(this.value.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(left ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Right extends Core {\n\n  constructor(\n    public value: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Right(this.value.toLazy(env));\n  }\n\n  public prettyPrint(): string {\n    return `(right ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndEither extends Core {\n\n  constructor(\n    public target: Core,\n    public motive: Core,\n    public baseLeft: Core,\n    public baseRight: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doIndEither(\n      this.target.toLazy(env),\n      this.motive.toLazy(env),\n      this.baseLeft.toLazy(env),\n      this.baseRight.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(ind-Either ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.baseLeft.prettyPrint()} \n              ${this.baseRight.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class TODO extends Core {\n  constructor(\n    public loc: SourceLocation,\n    public type: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return new V.Neutral(\n      this.type.toLazy(env),\n      new N.TODO(this.loc, this.type.toLazy(env),)\n    )\n  }\n\n  public prettyPrint(): string {\n    return `TODO ${this.type.prettyPrint()}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Application extends Core {\n\n  constructor(\n    public fun: Core,\n    public arg: Core\n  ) { super() }\n\n  public valOf(env: Environment): V.Value {\n    return Evaluator.doApp(\n      this.fun.toLazy(env),\n      this.arg.toLazy(env),\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(${this.fun.prettyPrint()} ${this.arg.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n","import * as C from '../types/core';\nimport { isVarName } from '../types/utils';\nimport { SourceLocation } from './locations';\n\nexport function alphaEquiv(e1: C.Core, e2: C.Core): boolean {\n  return alphaEquivAux(0, new Map(), new Map(), e1, e2);\n}\n\n//-------------------------------------------------------------------------------------------//\n\n// ### Helpers ###\n\ntype Bindings = Map<string, number>;\n\nconst FV = -1;\n\nfunction bind(b: Bindings, x: string, lvl: number): Bindings {\n  return new Map([[x, lvl], ...b]);\n}\n\nfunction findBinding(x: string, b: Bindings): number {\n  if (b.has(x)) {\n    b.get(x)!;\n  }\n  // x is not bound, return -1.\n  return FV;  \n}\n\nfunction alphaEquivAux(lvl: number, b1: Bindings, b2: Bindings, e1: C.Core, e2: C.Core): boolean {\n  if (e1 instanceof C.VarName && e2 instanceof C.VarName) {\n    const n1 = e1.name;\n    const n2 = e2.name;\n    if (isVarName(n1) && isVarName(n2)) {\n      const xBinding = findBinding(n1, b1);\n      const yBinding = findBinding(n2, b2);\n      // both bound\n      if (xBinding !== FV && yBinding !== FV) {\n        return xBinding === yBinding;\n      } else if (xBinding === FV && yBinding === FV) {\n        // both free\n        return n1 === n2;\n      } else {\n        // one bound, one free\n        return false;\n      }\n      // Compare to the original version,\n      // the contructor equality is not considered here as our\n      // implementations of constructors are different.\n      // Orginally using strings, we use classes.\n      // they will be dealt with in the following cases.\n    } else {\n      return false;\n    }\n  } else if (e1 instanceof C.Quote && e2 instanceof C.Quote) {\n    // Atoms must be the same atom\n    return e1.sym === e2.sym;\n\n  } else if (e1 instanceof C.Pi && e2 instanceof C.Pi) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type) \n    &&\n    alphaEquivAux(lvl + 1, bind(b1, e1.name, lvl), bind(b2, e2.name, lvl), e1.body, e2.body);\n\n  } else if (e1 instanceof C.Sigma && e2 instanceof C.Sigma) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type) \n    &&\n    alphaEquivAux(lvl + 1, bind(b1, e1.name, lvl), bind(b2, e2.name, lvl), e1.body, e2.body);\n\n  } else if (e1 instanceof C.Lambda && e2 instanceof C.Lambda) {\n    return alphaEquivAux(\n      lvl + 1, \n      bind(b1, e1.param, lvl),\n      bind(b2, e2.param, lvl),\n      e1.body,\n      e2.body\n    );\n\n  } else if (e1 instanceof C.The \n    && e2 instanceof C.The\n    && e1.type instanceof C.Absurd\n    && e2.type instanceof C.Absurd) {\n      return true;\n\n  } else if (e1 instanceof C.Application && e2 instanceof C.Application) {\n    return alphaEquivAux(lvl, b1, b2, e1.fun, e2.fun) \n    &&\n    alphaEquivAux(lvl, b1, b2, e1.arg, e2.arg);\n\n  }\n  // following cases are one word constructors \n  else if (\n    (e1 instanceof C.Universe && e2 instanceof C.Universe) ||\n    (e1 instanceof C.Nat && e2 instanceof C.Nat) ||\n    (e1 instanceof C.Zero && e2 instanceof C.Zero) ||\n    (e1 instanceof C.Atom && e2 instanceof C.Atom) ||\n    (e1 instanceof C.Absurd && e2 instanceof C.Absurd) ||\n    (e1 instanceof C.Sole && e2 instanceof C.Sole) ||\n    (e1 instanceof C.Nil && e2 instanceof C.Nil) ||\n    (e1 instanceof C.VecNil && e2 instanceof C.VecNil) ||\n    (e1 instanceof C.Trivial && e2 instanceof C.Trivial)\n  ) {\n    return true;\n  }\n  // following cases are for multiple word constructors, and eliminators.\n  else if (e1 instanceof C.The && e2 instanceof C.The) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.expr, e2.expr);\n  } else if (e1 instanceof C.List && e2 instanceof C.List) {\n    return alphaEquivAux(lvl, b1, b2, e1.elemType, e2.elemType);\n  } else if (e1 instanceof C.Add1 && e2 instanceof C.Add1) {\n    return alphaEquivAux(lvl, b1, b2, e1.n, e2.n);\n\n  } else if (e1 instanceof C.WhichNat && e2 instanceof C.WhichNat) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n\n  } else if (e1 instanceof C.IterNat && e2 instanceof C.IterNat) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.RecNat && e2 instanceof C.RecNat) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.IndNat && e2 instanceof C.IndNat) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.Cons && e2 instanceof C.Cons) { \n    return alphaEquivAux(lvl, b1, b2, e1.first, e2.first)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.second, e2.second);\n  } else if (e1 instanceof C.Car && e2 instanceof C.Car) {\n    return alphaEquivAux(lvl, b1, b2, e1.pair, e2.pair);\n  } else if (e1 instanceof C.Cdr && e2 instanceof C.Cdr) {\n    return alphaEquivAux(lvl, b1, b2, e1.pair, e2.pair);\n  } else if (e1 instanceof C.ListCons && e2 instanceof C.ListCons) {\n    return alphaEquivAux(lvl, b1, b2, e1.head, e2.head)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.tail, e2.tail);\n  } else if (e1 instanceof C.RecList && e2 instanceof C.RecList) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.IndList && e2 instanceof C.IndList) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.IndAbsurd && e2 instanceof C.IndAbsurd) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive);\n  } else if (e1 instanceof C.Equal && e2 instanceof C.Equal) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.left, e2.left)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.right, e2.right);\n\n  } else if (e1 instanceof C.Same && e2 instanceof C.Same) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type);\n\n  } else if (e1 instanceof C.Replace && e2 instanceof C.Replace) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base);\n\n  } else if (e1 instanceof C.Trans && e2 instanceof C.Trans) {\n    return alphaEquivAux(lvl, b1, b2, e1.left, e2.left)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.right, e2.right);\n\n  } else if (e1 instanceof C.Cong && e2 instanceof C.Cong) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.fun, e2.fun);\n  } else if (e1 instanceof C.Symm && e2 instanceof C.Symm) {\n    return alphaEquivAux(lvl, b1, b2, e1.equality, e2.equality);\n\n  } else if (e1 instanceof C.IndEqual && e2 instanceof C.IndEqual) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base);\n  } else if (e1 instanceof C.Vec && e2 instanceof C.Vec) {\n    return alphaEquivAux(lvl, b1, b2, e1.type, e2.type)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.length, e2.length)\n  } else if (e1 instanceof C.VecCons && e2 instanceof C.VecCons) {\n    return alphaEquivAux(lvl, b1, b2, e1.head, e2.head)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.tail, e2.tail);\n  } else if (e1 instanceof C.Head && e2 instanceof C.Head) {\n    return alphaEquivAux(lvl, b1, b2, e1.vec, e2.vec);\n  } else if (e1 instanceof C.Tail && e2 instanceof C.Tail) {\n    return alphaEquivAux(lvl, b1, b2, e1.vec, e2.vec);\n  } else if (e1 instanceof C.IndVec && e2 instanceof C.IndVec) {\n    return alphaEquivAux(lvl, b1, b2, e1.length, e2.length)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.base, e2.base)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.step, e2.step);\n  } else if (e1 instanceof C.Either && e2 instanceof C.Either) {\n    return alphaEquivAux(lvl, b1, b2, e1.left, e2.left)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.right, e2.right);\n  } else if (e1 instanceof C.Left && e2 instanceof C.Left) {\n    return alphaEquivAux(lvl, b1, b2, e1.value, e2.value);\n  } else if (e1 instanceof C.Right && e2 instanceof C.Right) {\n    return alphaEquivAux(lvl, b1, b2, e1.value, e2.value);\n  } else if (e1 instanceof C.IndEither && e2 instanceof C.IndEither) {\n    return alphaEquivAux(lvl, b1, b2, e1.target, e2.target)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.motive, e2.motive)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.baseLeft, e2.baseLeft)\n    &&\n    alphaEquivAux(lvl, b1, b2, e1.baseRight, e2.baseRight);\n  } else if (e1 instanceof C.TODO && e2 instanceof C.TODO) {\n    return sameLocation(e1.loc, e2.loc) && alphaEquivAux(lvl, b1, b2, e1.type, e2.type);\n  }\n  // if none of the above cases are met, return false.\n  else {\n    return false;\n  }\n}\n\nfunction sameLocation(e1: SourceLocation, e2: SourceLocation): boolean {\n  return e1.startLine === e2.startLine && \n         e1.startColumn === e2.startColumn && \n         e1.endLine === e2.endLine && \n         e1.endColumn === e2.endColumn;\n}\n\n/* function alphaEquivAuxSeq(lvl: number, b1: Bindings, b2: Bindings, es1: C.Core[], es2: C.Core[]): boolean {\n  if (es1.length !== es2.length) {\n    return false;\n  }\n  for (let i = 0; i < es1.length; i++) {\n    if (!alphaEquivAux(lvl, b1, b2, es1[i], es2[i])) {\n      return false;\n    }\n  }\n  return true;\n} */","import { Value } from \"../types/value\";\nimport { Source } from \"../types/source\";\nimport { Application } from \"../types/source\";\nimport { Core } from \"../types/core\";\nimport { Location } from \"../utils/locations\";\nimport { Context, SerializableContext } from \"../utils/context\";\nimport { go, stop, Perhaps, Message } from \"../types/utils\";\nimport { alphaEquiv } from \"../utils/alphaeqv\";\nimport { readBack } from \"../evaluator/utils\";\n\n\ntype What = 'definition'\n  | ['binding-site', Core]\n  | ['is-type', Core]\n  | ['has-type', Core]\n  | ['TODO', SerializableContext, Core];\n\n\n// TODO: Implement PieInfoHook\n\nexport function PieInfoHook(where: Location, what: What): void {\n\n}\n\nexport function SendPieInfo(where: Location, what: What): void {\n  if (where.forInfo) {\n    PieInfoHook(where, what);\n  }\n}\n\n// ### Renamings\n\nexport type Renaming = Map<string, string>;\n\n// Function to rename a symbol using the Renaming list\nexport function rename(renames: Renaming, x: string): string {\n  const rename = renames.get(x);\n  return rename ? rename : x;\n}\n\n// Function to extend the Renaming list with a new pair\nexport function extendRenaming(renames: Renaming, from: string, to: string): Renaming {\n  const newRenames = new Map([[from, to], ...renames]);\n  return newRenames;\n}\n\n// ### Check the form of judgment   c  c type\nexport function sameType(ctx: Context, where: Location, given: Value, expected: Value): Perhaps<undefined> {\n  const givenE = given.readBackType(ctx);\n  const expectedE = expected.readBackType(ctx);\n  if (alphaEquiv(givenE, expectedE)) {\n    return new go(undefined);\n  } else {\n    return new stop(\n      where,\n      new Message([`Expected ${expectedE} but got ${givenE}`])\n    );\n  }\n}\n\n// ### Check the form of judgment   c : A type\nexport function convert(ctx: Context, where: Location, type: Value, from: Value, to: Value): Perhaps<undefined> {\n  const fromE = readBack(ctx, type, from);\n  const toE = readBack(ctx, type, to);\n  if (alphaEquiv(fromE, toE)) {\n    return new go(undefined);\n  } else {\n    return new stop(\n      where,\n      new Message([`The terms ${from} and ${to} are not the same ${type}.`])\n    );\n  }\n}\n\n// ### Claims + defines ###\n\nexport function atomOk(a: string): boolean {\n  return allOkAtom(a.split(''));\n}\n\nfunction allOkAtom(cs: string[]): boolean {\n  if (cs.length === 0) {\n    return true;\n  } else if (isAlphabetic(cs[0]) || cs[0] === '-') {\n    return allOkAtom(cs.slice(1));\n  } else {\n    return false;\n  }\n}\n\nfunction isAlphabetic(char: string): boolean {\n  return /^[a-zA-Z]$/.test(char);\n}\n\n// Helper to concoct a function application form in source syntax\nexport function makeApp(a: Source, b: Source, cs: Source[]): Source {\n  return new Application(a.location, a, b, cs);\n}","import * as C from \"../types/core\";\nimport * as S from \"../types/source\";\nimport * as V from \"../types/value\";\nimport {\n  go, Perhaps, stop, Message, freshBinder, PerhapsM, goOn,\n  fresh, FirstOrderClosure, HigherOrderClosure,\n  TypedBinder\n} from '../types/utils';\nimport { bindFree, Context, contextToEnvironment, Define, valInContext, varType } from '../utils/context';\nimport { atomOk, convert, extendRenaming, makeApp, PieInfoHook, rename, Renaming, sameType } from \"./utils\";\nimport { notForInfo } from \"../utils/locations\";\nimport { doApp, doCar, indVecStepType } from \"../evaluator/evaluator\";\nimport { readBack } from '../evaluator/utils';\nimport { Location } from '../utils/locations';\n\n\nexport class synthesizer {\n\n  public static synthNat(ctx: Context, r: Renaming): Perhaps<C.The> {\n    return new go(new C.The(\n      new C.Universe(),\n      new C.Nat()\n    ));\n  }\n\n  public static synthUniverse(ctx: Context, r: Renaming, location: Location): Perhaps<C.The> {\n    return new stop(location,\n      new Message([\"U is a type, but it does not have a type.\"])\n    );\n  }\n\n  public static synthArrow(context: Context, r: Renaming, location: Location, arg1 : S.Source, arg2 : S.Source, args : S.Source[]): Perhaps<C.The> {\n    if (args.length === 0) {\n      const z = freshBinder(context, arg2, 'x');\n      const Aout = new PerhapsM<C.Core>(\"Aout\");\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => \n            arg1.check(context, r, new V.Universe())],\n          [Bout, () => \n            arg2.check(\n              bindFree(context, z, valInContext(context, Aout.value)),\n              r,\n              new V.Universe()\n            )\n          ],\n        ],\n        (() => {\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Pi(\n                z,\n                Aout.value,\n                Bout.value\n              )))\n        })\n      );\n    } else {\n      const [first, ...rest] = args;\n      const z = freshBinder(context, makeApp(arg2, first, rest), 'x');\n      const Aout = new PerhapsM<C.Core>(\"Aout\");\n      const tout = new PerhapsM<C.Core>('tout');\n      return goOn(\n        [\n          [Aout, () => arg1.check(context, r, new V.Universe())],\n          [tout, () =>\n            new S.Arrow(notForInfo(location), arg2, first, rest)\n                .check(\n                  bindFree(context, z, valInContext(context, Aout.value)),\n                  r,\n                  new V.Universe()\n                )\n          ]\n        ],\n        () => {\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Pi(\n                z,\n                Aout.value,\n                tout.value\n              )\n            )\n          )\n        })\n    }\n  }\n\n  public static synthPi(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The> {\n    if (binders.length === 1) {\n      const [binder, type] = [binders[0].binder, binders[0].type];\n      const xhat = fresh(context, binder.varName);\n      const xloc = binder.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => type.check(context, r, new V.Universe())],\n          [Bout, () => body.check(\n            bindFree(context, xhat, valInContext(context, Aout.value)),\n            extendRenaming(r, binder.varName, xhat),\n            new V.Universe())],\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value!]);\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Pi(\n                xhat,\n                Aout.value,\n                Bout.value\n              )\n            )\n          )\n        }\n      )\n    } else if (binders.length > 1) {\n      const [fst, ...rest] = binders;\n      const [binder, type] = [fst.binder, fst.type];\n      const xloc = binder.location;\n      const x = binder.varName;\n      const xhat = fresh(context, x);\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => type.check(context, r, new V.Universe())],\n          [Bout, () =>\n            new S.Pi(notForInfo(location), rest, body)\n              .check(\n                bindFree(context, xhat, valInContext(context, Aout.value)),\n                extendRenaming(r, x, xhat),\n                new V.Universe()\n              )\n          ],\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value!]);\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Pi(\n                xhat,\n                Aout.value,\n                Bout.value\n              )\n            )\n          )\n        }\n      )\n    } else {\n      throw new Error('Invalid number of binders in Pi type');\n    }\n  }\n\n  public static synthZero(context: Context, r: Renaming): Perhaps<C.The> {\n    return new go(\n      new C.The(\n        new C.Nat(),\n        new C.Zero()\n      )\n    );\n  }\n\n\n  public static synthAdd1(context: Context, r: Renaming, base: S.Source): Perhaps<C.The> {\n    const nout = new PerhapsM<C.Core>('nout');\n    return goOn(\n      [[nout, () => base.check(context, r, new V.Nat())]],\n      () => new go<C.The>(\n        new C.The(\n          new C.Nat(),\n          new C.Add1(nout.value)\n        )\n      )\n    );\n  }\n\n  public static synthWhichNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.Core>('tgtout');\n    const bout = new PerhapsM<C.The>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    let n_minus_1 = fresh(context, 'n_minus_1');\n    return goOn(\n      [\n        [tgtout, () => target.check(context, r, new V.Nat())],\n        [bout, () => base.synth(context, r)],\n        [sout, () => step.check(\n          context,\n          r,\n          new V.Pi(\n            n_minus_1,\n            new V.Nat(),\n            new FirstOrderClosure(\n              contextToEnvironment(context),\n              n_minus_1,\n              bout.value.type\n            )\n          ))\n        ],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          bout.value.type,\n          new C.WhichNat(\n            tgtout.value,\n            new C.The(\n              bout.value.type,\n              bout.value.expr),\n            sout.value\n          )\n        )\n      )\n    );\n  }\n\n\n\n  public static synthIterNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.Core>('tgtout');\n    const bout = new PerhapsM<C.The>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    return goOn(\n      [\n        [tgtout, () => target.check(context, r, new V.Nat())],\n        [bout, () => base.synth(context, r)],\n        [sout, () => step.check(\n          context,\n          r,\n          (() => {\n            const old = fresh(context, 'old');\n            return valInContext(\n              context,\n              new C.Pi(\n                old,\n                bout.value.type,\n                bout.value.type\n              ))\n          })()\n        )],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          bout.value.type,\n          new C.IterNat(\n            tgtout.value,\n            new C.The(\n              bout.value.type,\n              bout.value.expr\n            ),\n            sout.value\n          )\n        )\n      )\n    );\n  }\n\n\n  public static synthRecNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.Core>('tgtout');\n    const bout = new PerhapsM<C.The>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    return goOn(\n      [\n        [tgtout, () => target.check(context, r, new V.Nat())],\n        [bout, () => base.synth(context, r)],\n        [sout, () => step.check(\n          context,\n          r,\n          (() => {\n            const n_minus_1 = fresh(context, 'n_minus_1');\n            const old = fresh(context, 'old');\n            return valInContext(\n              context,\n              new C.Pi(\n                n_minus_1,\n                new C.Nat(),\n                new C.Pi(\n                  old,\n                  bout.value.type,\n                  bout.value.type\n                )\n              )\n            )\n          })()\n        )],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          bout.value.type,\n          new C.RecNat(\n            tgtout.value,\n            new C.The(\n              bout.value.type,\n              bout.value.expr\n            ),\n            sout.value\n          )\n        )\n      )\n    );\n  }\n\n\n  public static synthIndNat(context: Context, r: Renaming, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.Core>('tgtout');\n    const motout = new PerhapsM<C.Core>('motout');\n    const motval = new PerhapsM<V.Value>('motval');\n    const bout = new PerhapsM<C.Core>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    return goOn(\n      [\n        [tgtout, () => target.check(context, r, new V.Nat())],\n        [motout, () => motive.check(context, r, \n          new V.Pi(\n            'n',\n            new V.Nat(),\n            new HigherOrderClosure((_) => new V.Universe())\n          )\n        )],\n        [motval, () => new go(\n          valInContext(context, motout.value)\n        )],\n        [bout, () => base.check(\n          context,\n          r,\n          doApp(motval.value, new V.Zero())\n        )],\n        [sout, () => step.check(\n          context,\n          r,\n          new V.Pi(\n            'n_minus_1',\n            new V.Nat(),\n            new HigherOrderClosure(\n              (n_minus_1) =>\n                new V.Pi(\n                  'ih',\n                  doApp(motval.value, n_minus_1),\n                  new HigherOrderClosure(\n                    (_) => doApp(motval.value, new V.Add1(n_minus_1))\n                  )\n                )\n            )\n          )\n        )],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.Application(\n            motout.value,\n            tgtout.value\n          ),\n          new C.IndNat(\n            tgtout.value,\n            motout.value,\n            bout.value,\n            sout.value\n          )\n        )\n      )\n    );\n  }\n\n  public static synthAtom(context: Context, r: Renaming): Perhaps<C.The> {\n    return new go(\n      new C.The(\n        new C.Universe(),\n        new C.Atom()\n      )\n    )\n  }\n\n\n  public static synthPair(context: Context, r: Renaming, first: S.Source, second: S.Source): Perhaps<C.The> {\n    const a = fresh(context, 'a');\n    const Aout = new PerhapsM<C.Core>('Aout');\n    const Dout = new PerhapsM<C.Core>('Dout');\n    return goOn(\n      [\n        [Aout, () => first.check(context, r, new V.Universe())],\n        [Dout, () => \n          second.check(\n            bindFree(context, a, valInContext(context, Aout.value)),\n            r,\n            new V.Universe()\n        )],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.Universe(),\n          new C.Sigma(\n            a,\n            Aout.value,\n            Dout.value\n          )\n        )\n      )\n    );\n  }\n\n\n  public static synthSigma(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The> {\n    if (binders.length === 1) {\n      const [bd, type] = [binders[0].binder, binders[0].type];\n      const xhat = fresh(context, bd.varName);\n      const xloc = bd.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Dout = new PerhapsM<C.Core>('Dout');\n      return goOn(\n        [\n          [Aout, () => type.check(context, r, new V.Universe())],\n          [Dout, () => body.check(\n            bindFree(context, xhat, valInContext(context, Aout.value)),\n            extendRenaming(r, bd.varName, xhat),\n            new V.Universe()\n          )],\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value!]);\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Sigma(\n                xhat,\n                Aout.value,\n                Dout.value\n              )\n            )\n          )\n        }\n      )\n    } else if (binders.length > 1) {\n      const [fst, ...rest] = binders;\n      const [binder, type] = [fst.binder, fst.type];\n      const xloc = binder.location;\n      const x = binder.varName;\n      const xhat = fresh(context, x);\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Dout = new PerhapsM<C.Core>('Dout');\n      return goOn(\n        [\n          [Aout, () => type.check(context, r, new V.Universe())],\n          [Dout, () => \n            new S.Sigma(\n              notForInfo(location),\n              rest,\n              body\n            ).check(\n              bindFree(context, xhat, valInContext(context, Aout.value)),\n              extendRenaming(r, x, xhat),\n              new V.Universe()\n            )\n          ],\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value]);\n          return new go<C.The>(\n            new C.The(\n              new C.Universe(),\n              new C.Sigma(\n                xhat,\n                Aout.value,\n                Dout.value\n              )\n            )\n          )\n        }\n      )\n    } else {\n      throw new Error('Invalid number of binders in Sigma type');\n    }\n  }\n\n  public static synthCar(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The> {\n    const pout = new PerhapsM<C.The>('p_rst');\n    return goOn(\n      [[pout, () => pair.synth(context, r)]],\n      () => {\n        const val = valInContext(context, pout.value.type);\n        if (val instanceof V.Sigma) {\n          return new go(\n            new C.The(\n              val.carType.readBackType(context),\n              new C.Car(\n                pout.value.expr,\n              )\n            )\n          )\n        } else {\n          return new stop(\n            location,\n            new Message([`car requires a Pair type, but was used as a: ${val}.`])\n          );\n        }\n      }\n    )\n  }\n\n  public static synthCdr(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The> {\n    const pout = new PerhapsM<C.The>('pout');\n    return goOn(\n      [[pout, () => pair.synth(context, r)]],\n      () => {\n        const val = valInContext(context, pout.value.type);\n        if (val instanceof V.Sigma) {\n          const [x, A, clos] = [val.carName, val.carType, val.cdrType];\n          return new go(\n            new C.The(\n              clos.valOfClosure(\n                doCar(valInContext(context, pout.value.expr))\n              ).readBackType(context),\n              new C.Cdr(\n                pout.value.expr,\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`cdr requires a Pair type, but was used as a: ${val}.`])\n          );\n        }\n      }\n    )\n  }\n\n  public static synthQuote(context: Context, r: Renaming, location: Location, atom: string): Perhaps<C.The> {\n    if (atomOk(atom)) {\n      return new go(\n        new C.The(\n          new C.Atom(),\n          new C.Quote(atom)\n        )\n      );\n    } else {\n      return new stop(\n        location,\n        new Message([`Invalid atom: ${atom}. Atoms consist of letters and hyphens.`])\n      );\n    }\n  }\n\n  public static synthTrivial(context: Context, r: Renaming): Perhaps<C.The> {\n    return new go(\n      new C.The(\n        new C.Universe(),\n        new C.Trivial()\n      )\n    );\n  }\n\n  public static synthSole(context: Context, r: Renaming): Perhaps<C.The> {\n    return new go(\n      new C.The(\n        new C.Trivial(),\n        new C.Sole()\n      )\n    )\n  }\n\n  public static synthIndList(context: Context, r: Renaming, \n    location: Location, target: S.Source, motive: S.Source, base: S.Source, step: S.Source,): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.The>('tgtout');\n    const motout = new PerhapsM<C.Core>('motout');\n    const motval = new PerhapsM<V.Value>('motval');\n    const bout = new PerhapsM<C.Core>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    return goOn(\n      [\n        [tgtout, () => target.synth(context, r)],\n      ],\n      (() => {\n        const [tgt_t, tgt_e] = [tgtout.value.type, tgtout.value.expr];\n        const type = valInContext(context, tgt_t);\n        if (type instanceof V.List) {\n          const E = type.entryType;\n          return goOn(\n            [\n              [\n                motout, \n                () => motive.check(\n                  context,\n                  r,\n                  new V.Pi(\n                    'xs',\n                    new V.List(E),\n                    new FirstOrderClosure(\n                      contextToEnvironment(context),\n                      'xs',\n                      new C.Universe()\n                    )\n                  )\n                )\n              ],\n              [motval, () => new go(valInContext(context, motout.value))],\n              [bout, () => base.check(\n                context,\n                r,\n                doApp(motval.value, new V.Nil())\n              )],\n              [sout, () => step.check(\n                context,\n                r,\n                new V.Pi(\n                  'e',\n                  E,\n                  new HigherOrderClosure(\n                    (e) => new V.Pi(\n                      'es',\n                      new V.List(E),\n                      new HigherOrderClosure(\n                        (es) => new V.Pi(\n                          'ih',\n                          doApp(motval.value, es),\n                          new HigherOrderClosure(\n                            (_) => doApp(motval.value, new V.ListCons(e, es))\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                new C.Application(\n                  motout.value,\n                  tgt_e\n                ),\n                new C.IndList(\n                  tgt_e,\n                  motout.value,\n                  bout.value,\n                  sout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Not a List: ${type.readBackType(context)}.`])\n          );\n        }\n      })\n    )\n  }\n\n\n  public static synthRecList(context: Context, r: Renaming, \n    location: Location, target: S.Source, base: S.Source, step: S.Source,): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.The>('tgtout');\n    return goOn(\n      [[tgtout, () => target.synth(context, r)]],\n      () => {\n        const [tgt_t, tgt_e] = [tgtout.value.type, tgtout.value.expr];\n        const type = valInContext(context, tgt_t);\n        if (type instanceof V.List) {\n          const E = type.entryType;\n          const bout = new PerhapsM<C.The>('bout');\n          const btval = new PerhapsM<V.Value>('btval');\n          const sout = new PerhapsM<C.Core>('sout');\n          return goOn(\n            [\n              [bout, () => base.synth(context, r)],\n              [btval, () => new go(valInContext(context, bout.value.type))],\n              [sout, () => \n                step.check(\n                  context,\n                  r,\n                  new V.Pi(\n                    'e',\n                    E,\n                    new HigherOrderClosure(\n                      (_) => new V.Pi(\n                        'es',\n                        new V.List(E),\n                        new HigherOrderClosure(\n                          (_) => new V.Pi(\n                            'ih',\n                            btval.value,\n                            new HigherOrderClosure(\n                              (_) => btval.value\n                            )\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              ],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                bout.value.type,\n                new C.RecList(\n                  tgt_e,\n                  new C.The(\n                    bout.value.type,\n                    bout.value.expr\n                  ),\n                  sout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Not a List: ${type.readBackType(context)}.`])\n          );\n        }\n      }\n    )\n  }\n\n\n  public static synthList(context: Context, r: Renaming, e: S.List): Perhaps<C.The> {\n    const Eout = new PerhapsM<C.Core>('Eout');\n    return goOn(\n      [[Eout, () => e.entryType.check(context, r, new V.Universe())]],\n      () => new go<C.The>(\n        new C.The(\n          new C.Universe(),\n          new C.List(Eout.value)\n        )\n      )\n    );\n  }\n\n\n  public static synthListCons(context: Context, r: Renaming, x: S.Source, xs: S.Source): Perhaps<C.The> {\n    const fstout = new PerhapsM<C.The>('eout');\n    const restout = new PerhapsM<C.Core>('esout');\n    return goOn(\n      [\n        [fstout, () => x.synth(context, r)],\n        [restout, () => \n          xs.check(\n            context,\n            r,\n            valInContext(context, new C.List(fstout.value.type))\n          )\n        ],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.List(fstout.value.type),\n          new C.ListCons(\n            fstout.value.expr,\n            restout.value\n          )\n        )\n      )\n    );\n  }\n\n  public static synthAbsurd(context: Context, r: Renaming, e: S.Absurd): Perhaps<C.The> {\n    return new go(\n      new C.The(\n        new C.Universe(),\n        new C.Absurd()\n      )\n    );\n  }\n\n\n\n  public static synthIndAbsurd(context: Context, r: Renaming, e: S.IndAbsurd): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.Core>('tgtout');\n    const motout = new PerhapsM<C.Core>('motout');\n    return goOn(\n      [\n        [tgtout, () => e.target.check(context, r, new V.Absurd())],\n        [motout, () => e.motive.check(context, r, new V.Universe())],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          motout.value,\n          new C.IndAbsurd(\n            tgtout.value,\n            motout.value\n          )\n        )\n      )\n    );\n  }\n\n\n\n  public static synthEqual(context: Context, r: Renaming, type: S.Source, left: S.Source, right: S.Source): Perhaps<C.The> {\n    const Aout = new PerhapsM<C.Core>('Aout');\n    const Av = new PerhapsM<V.Value>('Av');\n    const from_out = new PerhapsM<C.Core>('from_out');\n    const to_out = new PerhapsM<C.Core>('to_out');\n    return goOn(\n      [\n        [Aout, () => type.check(context, r, new V.Universe())],\n        [Av, () => new go(valInContext(context, Aout.value))],\n        [from_out, () => left.check(context, r, Av.value)],\n        [to_out, () => right.check(context, r, Av.value)],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.Universe(),\n          new C.Equal(\n            Aout.value,\n            from_out.value,\n            to_out.value\n          )\n        )\n      )\n    );\n  }\n\n\n  public static synthReplace(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.The>('tgt_rst');\n    const motout = new PerhapsM<C.Core>('motout');\n    const bout = new PerhapsM<C.Core>('bout');\n    return goOn(\n      [[tgtout, () => target.synth(context, r)]],\n      () => {\n        const result = valInContext(context, tgtout.value.type);\n        if (result instanceof V.Equal) {\n          const [Av, fromv, tov] = [result.type, result.from, result.to];\n          return goOn(\n            [\n              [motout, () =>\n                motive.check(\n                  context,\n                  r,\n                  new V.Pi(\n                    'x',\n                    Av,\n                    new HigherOrderClosure(\n                      (_) => new V.Universe()\n                    )\n                  )\n                )\n              ],\n              [bout, () => base.check(\n                context,\n                r,\n                doApp(valInContext(context, motout.value), fromv)\n              )],\n            ],\n            () => new go(\n              new C.The(\n                (doApp(valInContext(context, motout.value), tov)).readBackType(context),\n                new C.Replace(\n                  tgtout.value.expr,\n                  motout.value,\n                  bout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected an expression with = type, but the type was: ${tgtout.value.type}.`])\n          );\n        }\n      }\n    );\n  }\n\n  public static synthTrans(context: Context, r: Renaming, location: Location, left: S.Source, right: S.Source): Perhaps<C.The> {\n\n    const lout = new PerhapsM<C.The>('p1_rst');\n    const rout = new PerhapsM<C.The>('p2_rst');\n    return goOn(\n      [\n        [lout, () => left.synth(context, r)],\n        [rout, () => right.synth(context, r)],\n      ],\n      () => {\n        const result1 = valInContext(context, lout.value.type);\n        const result2 = valInContext(context, rout.value.type);\n        if (result1 instanceof V.Equal && result2 instanceof V.Equal) {\n          const [Av, fromv, midv] = [result1.type, result1.from, result1.to];\n          const [Bv, midv2, tov] = [result2.type, result2.from, result2.to];\n\n          return goOn(\n            [\n              [new PerhapsM(\"_\"), () => sameType(context, location, Av, Bv)],\n              [new PerhapsM(\"_\"), () => convert(context, location, Av, midv, midv2)],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                new V.Equal(Av, fromv, tov).readBackType(context),\n                new C.Trans(\n                  lout.value.expr,\n                  rout.value.expr\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected =, got ${result1} and ${result2}.`])\n          );\n        }\n      }\n    )\n  }\n\n  public static synthCong(context: Context, r: Renaming, location: Location, base: S.Source, fun: S.Source): Perhaps<C.The> {\n\n    const bout = new PerhapsM<C.The>('bout');\n    const fout = new PerhapsM<C.The>('f_rst');\n    return goOn(\n      [\n        [bout, () => base.synth(context, r)],\n        [fout, () => fun.synth(context, r)],\n      ],\n      () => {\n        const result1 = valInContext(context, bout.value.type);\n        const result2 = valInContext(context, fout.value.type);\n        if (result1 instanceof V.Equal) {\n          const [Av, fromv, tov] = [result1.type, result1.from, result1.to];\n          if (result2 instanceof V.Pi) {\n            const [x, Bv, c] = [result2.argName, result2.argType, result2.resultType];\n            const ph = new PerhapsM<any>('ph');\n            const Cv = new PerhapsM<V.Value>('Cv');\n            const fv = new PerhapsM<V.Value>('fv');\n            return goOn(\n              [\n                [ph, () => sameType(context, location, Av, Bv)],\n                [Cv, () => new go(c.valOfClosure(fromv))],\n                [fv, () => new go(valInContext(context, fout.value.expr))],\n              ],\n              () => new go(\n                new C.The(\n                  new C.Equal(\n                    Cv.value.readBackType(context),\n                    readBack(context, Cv.value, doApp(fv.value, fromv)),\n                    readBack(context, Cv.value, doApp(fv.value, tov))\n                  ),\n                  new C.Cong(\n                    bout.value.expr,\n                    Cv.value.readBackType(context),\n                    fout.value.expr\n                  )\n                )\n              )\n            );\n          } else {\n            return new stop(\n              location,\n              new Message([`Expected a function type, got ${result2.readBackType(context)}.`])\n            );\n          }\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected an = type, got ${result1.readBackType(context)}.`])\n          );\n        }\n      }\n    )\n  }\n\n  public static synthSymm(context: Context, r: Renaming, location: Location, eq: S.Source): Perhaps<C.The> {\n    const eout = new PerhapsM<C.The>('eout');\n    return goOn(\n      [[eout, () => eq.synth(context, r)]],\n      () => {\n        const result = valInContext(context, eout.value.type);\n        if (result instanceof V.Equal) {\n          const [Av, fromv, tov] = [result.type, result.from, result.to];\n          return new go(\n            new C.The(\n              (new V.Equal(\n                Av,\n                tov,\n                fromv\n              )).readBackType(context),\n              new C.Symm(\n                eout.value.expr\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected an = type, got ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n\n  public static synthIndEqual(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.The>('tgtout');\n    const motout = new PerhapsM<C.Core>('motout');\n    const motv = new PerhapsM<V.Value>('motv');\n    const baseout = new PerhapsM<C.Core>('baseout');\n    return goOn(\n      [[tgtout, () => target.synth(context, r)]],\n      () => {\n        const result = valInContext(context, tgtout.value.type);\n        if (result instanceof V.Equal) {\n          const [Av, fromv, tov] = [result.type, result.from, result.to];\n          return goOn(\n            [\n              [motout, () => \n                motive.check(\n                  context,\n                  r,\n                  new V.Pi(\n                    'to',\n                    Av,\n                    new HigherOrderClosure(\n                      (to) => new V.Pi(\n                        'p',\n                        new V.Equal(Av, fromv, to),\n                        new HigherOrderClosure(\n                          (_) => new V.Universe()\n                        )\n                      )\n                    )\n                  )\n                )\n              ],\n              [motv, () => new go(valInContext(context, motout.value))],\n              [baseout, () => \n                base.check(\n                  context,\n                  r,\n                  doApp(doApp(motv.value, fromv), new V.Same(fromv))\n                )\n              ],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                doApp(\n                  doApp(motv.value, tov),\n                  valInContext(context, tgtout.value.expr)\n                ).readBackType(context),\n                new C.IndEqual(\n                  tgtout.value.expr,\n                  motout.value,\n                  baseout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected evidence of equality, got ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n\n  public static synthVec(context: Context, r: Renaming, type: S.Source, len: S.Source): Perhaps<C.The> {\n    const tout = new PerhapsM<C.Core>('tout');\n    const lenout = new PerhapsM<C.Core>('lenout');\n    return goOn(\n      [\n        [tout, () => type.check(context, r, new V.Universe())],\n        [lenout, () => len.check(context, r, new V.Nat())],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.Universe(),\n          new C.Vec(tout.value, lenout.value)\n        )\n      )\n    );\n  }\n\n\n  public static synthHead(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The> {\n    const vout = new PerhapsM<C.The>('vout');\n    return goOn(\n      [[vout, () => vec.synth(context, r)]],\n      () => {\n        const result = valInContext(context, vout.value.type).now();\n        if (result instanceof V.Vec) {\n          const [T, len] = [result.entryType, result.length];\n          if (len instanceof V.Add1) {\n            return new go(\n              new C.The(\n                T.readBackType(context),\n                new C.Head(\n                  vout.value.expr\n                )\n              )\n            );\n          } else {\n            return new stop(\n              location,\n              new Message([`Expected a Vec with add1 at the top of the length, got ${readBack(context, new V.Nat(), len)}.`])\n            );\n          }\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n  public static synthTail(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The> {\n    const vout = new PerhapsM<C.The>('vout');\n    return goOn(\n      [[vout, () => vec.synth(context, r)]],\n      () => {\n        const result = valInContext(context, vout.value.type).now();\n        if (result instanceof V.Vec) {\n          const [T, len] = [result.entryType, result.length];\n          if (len instanceof V.Add1) {\n            const len_minus_1 = len.smaller;\n            return new go(\n              new C.The(\n                new C.Vec(\n                  T.readBackType(context),\n                  readBack(context, new V.Nat(), len_minus_1)),\n                new C.Tail(\n                  vout.value.expr\n                )\n              )\n            );\n          } else {\n            return new stop(\n              location,\n              new Message([`Expected a Vec with add1 at the top of the length, got ${readBack(context, new V.Nat(), len)}.`])\n            );\n          }\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n  public static synthIndVec(context: Context, r: Renaming, location: Location,\n      length: S.Source, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The> {\n    const lenout = new PerhapsM<C.Core>('lenout');\n    const lenv = new PerhapsM<V.Value>('lenv');\n    const vecout = new PerhapsM<C.The>('vecout');\n    const motout = new PerhapsM<C.Core>('motout');\n    const motval = new PerhapsM<V.Value>('motval');\n    const bout = new PerhapsM<C.Core>('bout');\n    const sout = new PerhapsM<C.Core>('sout');\n    return goOn(\n      [\n        [lenout, () => length.check(context, r, new V.Nat())],\n        [lenv, () => new go(valInContext(context, lenout.value))],\n        [vecout, () => target.synth(context, r)],\n      ],\n      () => {\n        const result = valInContext(context, vecout.value.type);\n        if (result instanceof V.Vec) {\n          const [E, len2v] = [result.entryType, result.length];\n          return goOn(\n            [\n              [new PerhapsM<any>('_'), () => convert(context, location, new V.Nat(), lenv.value, len2v)],\n              [motout, () => motive.check(\n                context,\n                r,\n                new V.Pi(\n                  'k',\n                  new V.Nat(),\n                  new HigherOrderClosure(\n                    (k) => new V.Pi(\n                      'es',\n                      new V.Vec(E, k),\n                      new HigherOrderClosure(\n                        (_) => new V.Universe()\n                      )\n                    )\n                  )\n                )\n              )],\n              [motval, () => new go(valInContext(context, motout.value))],\n              [bout, () => base.check(\n                context,\n                r,\n                doApp(doApp(motval.value, new V.Zero()), new V.VecNil())\n              )],\n              [sout, () => step.check(\n                context,\n                r,\n                indVecStepType(E, motval.value)\n              )],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                new C.Application(\n                  new C.Application(\n                    motout.value,\n                    lenout.value\n                  ),\n                  vecout.value.expr\n                ),\n                new C.IndVec(\n                  lenout.value,\n                  vecout.value.expr,\n                  motout.value,\n                  bout.value,\n                  sout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected a Vec, got ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n  public static synthEither(context: Context, r: Renaming, left: S.Source, right: S.Source): Perhaps<C.The> {\n    const Lout = new PerhapsM<C.Core>('Lout');\n    const Rout = new PerhapsM<C.Core>('Rout');\n    return goOn(\n      [\n        [Lout, () => left.check(context, r, new V.Universe())],\n        [Rout, () => right.check(context, r, new V.Universe())],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          new C.Universe(),\n          new C.Either(Lout.value, Rout.value)\n        )\n      )\n    );\n  }\n\n\n  public static synthIndEither(context: Context, r: Renaming, location: Location, target: S.Source,\n      motive: S.Source, baseLeft: S.Source, baseRight: S.Source,): Perhaps<C.The> {\n    const tgtout = new PerhapsM<C.The>('tgtout');\n    const motout = new PerhapsM<C.Core>('motout');\n    const motval = new PerhapsM<V.Value>('motval');\n    const lout = new PerhapsM<C.Core>('lout');\n    const rout = new PerhapsM<C.Core>('rout');\n    return goOn(\n      [[tgtout, () => target.synth(context, r)]],\n      () => {\n        const result = valInContext(context, tgtout.value.type);\n        if (result instanceof V.Either) {\n          const [Lv, Rv] = [result.leftType, result.rightType];\n          return goOn(\n            [\n              [motout, () => \n                motive.check(\n                  context,\n                  r,\n                  new V.Pi(\n                    'x',\n                    new V.Either(Lv, Rv),\n                    new HigherOrderClosure(\n                      (_) => new V.Universe()\n                    )\n                  )\n                )\n              ],\n              [motval, () => new go(valInContext(context, motout.value))],\n              [lout, () => baseLeft.check(\n                context,\n                r,\n                new V.Pi(\n                  'x',\n                  Lv,\n                  new HigherOrderClosure(\n                    (x) => doApp(motval.value, new V.Left(x))\n                  )\n                )\n              )],\n              [rout, () => baseRight.check(\n                context,\n                r,\n                new V.Pi(\n                  'x',\n                  Rv,\n                  new HigherOrderClosure(\n                    (x) => doApp(motval.value, new V.Right(x))\n                  )\n                )\n              )],\n            ],\n            () => new go<C.The>(\n              new C.The(\n                new C.Application(\n                  motout.value,\n                  tgtout.value.expr\n                ),\n                new C.IndEither(\n                  tgtout.value.expr,\n                  motout.value,\n                  lout.value,\n                  rout.value\n                )\n              )\n            )\n          );\n        } else {\n          return new stop(\n            location,\n            new Message([`Expected an Either, but got a ${result.readBackType(context)}.`])\n          );\n        }\n      }\n    );\n  }\n\n  public static synthThe(context: Context, r: Renaming, type: S.Source, value: S.Source): Perhaps<C.The> {\n    const tout = new PerhapsM<C.Core>('t_out');\n    const eout = new PerhapsM<C.Core>('e_out');\n    return goOn(\n      [\n        [tout, () => type.isType(context, r)],\n        [eout, () => value.check(context, r, valInContext(context, tout.value))],\n      ],\n      () => new go<C.The>(\n        new C.The(\n          tout.value,\n          eout.value\n        )\n      )\n    );\n  }\n\n  public static synthApplication(context: Context, r: Renaming, location: Location, fun: S.Source, arg: S.Source, args: S.Source[]): Perhaps<C.The> {\n    if (args.length === 0) {\n      const fout = new PerhapsM<C.The>('fout');\n      return goOn(\n        [[fout, () => fun.synth(context, r)]],\n        () => {\n          const result = valInContext(context, fout.value.type);\n          if (result instanceof V.Pi) {\n            const [_, A, c] = [result.argName, result.argType, result.resultType];\n            const argout = new PerhapsM<C.Core>('argout');\n            return goOn(\n              [[argout, () => arg.check(context, r, A)]],\n              () => new go(\n                new C.The(\n                  c.valOfClosure(valInContext(context, argout.value)).readBackType(context),\n                  new C.Application(\n                    fout.value.expr,\n                    argout.value\n                  )\n                )\n              )\n            );\n          } else {\n            return new stop(\n              location,\n              new Message([`Not a function type: ${result.readBackType(context)}.`])\n            );\n          }\n        }\n      );\n    } else {\n      const appout = new PerhapsM<C.The>('appout');\n      return goOn(\n        [[appout, () => (\n          new S.Application(\n            notForInfo(location),\n            fun,\n            arg,\n            args.slice(0, args.length - 1)\n          )\n        ).synth(context, r)]],\n        () => {\n          const result = valInContext(context, appout.value.type);\n          if (result instanceof V.Pi) {\n            const [x, A, c] = [result.argName, result.argType, result.resultType];\n            const argout = new PerhapsM<C.Core>('fout');\n            return goOn(\n              [[argout, () => args[args.length - 1].check(context, r, A)]],\n              () => new go(\n                new C.The(\n                  c.valOfClosure(valInContext(context, argout.value)).readBackType(context),\n                  new C.Application(\n                    appout.value.expr,\n                    argout.value\n                  )\n                )\n              )\n            );\n          } else {\n            return new stop(\n              location,\n              new Message([`Not a function type: ${result.readBackType(context)}.`])\n            );\n          }\n        }\n      );\n\n    }\n\n  }\n  /*\n  [x\n        (cond [(and (symbol? x) (var-name? x))\n               (let ((real-x (rename r x)))\n                (go-on ((x-tv (var-type  (src-loc e) real-x)))\n                  (begin (match (assv real-x )\n                           [(cons _ (def _ _))\n                            (send-pie-info (src-loc e) 'definition)]\n                           [_ (void)])\n                         (go `(the ,(read-back-type  x-tv) ,real-x)))))]\n              [(number? x)\n               (cond [(zero? x)\n                      (go `(the Nat zero))]\n                     [(positive? x)\n                      (go-on ((n-1-out (check \n                                              r\n                                              (@ (src-loc e) (sub1 x))\n                                              'NAT)))\n                        (go `(the Nat (add1 ,n-1-out))))])]\n              [else\n               (stop (src-loc e)\n                     `(\"Can't determine a type\"))])]\n  */\n\n  public static synthName(context: Context, r: Renaming, location: Location, name: string): Perhaps<C.The> {\n    const real_x = rename(r, name);\n    const x_tv = new PerhapsM<V.Value>('x_tv');\n    return goOn(\n      [[x_tv, () => varType(context, location, real_x)]],\n      () => {\n        const result = context.get(real_x);\n        if (result instanceof Define) {\n          PieInfoHook(location, 'definition');\n        }\n        return new go(\n          new C.The(\n            x_tv.value.readBackType(context),\n            new C.VarName(real_x)\n          )\n        )\n      }\n    );\n  }\n\n  public static synthNumber(context: Context, r: Renaming, location: Location, value: number): Perhaps<C.The> {\n    if (value === 0) {\n      return new go(\n        new C.The(\n          new C.Nat(),\n          new C.Zero()\n        )\n      );\n    } else if (value > 0) {\n      const n_minus_1_out = new PerhapsM<C.Core>('n_1_out');\n      return goOn(\n        [[n_minus_1_out, () => (new S.Number(location, value - 1)).check(context, r, new V.Nat())]],\n        () => new go(\n          new C.The(\n            new C.Nat(),\n            new C.Add1(n_minus_1_out.value)\n          )\n        )\n      );\n    } else {\n      return new stop(\n        location,\n        new Message([`Expected a positive number, got ${value}.`])\n      );\n    }\n  }\n}","import * as C from './core';\nimport * as V from './value';\nimport * as N from './neutral';\nimport * as S from './source';\n\nimport { PieInfoHook, Renaming, SendPieInfo, extendRenaming, makeApp, rename} from '../typechecker/utils';\nimport { Location, notForInfo } from '../utils/locations';\nimport { bindFree, Context, readBackContext, valInContext } from '../utils/context';\n\nimport { go, stop, goOn, occurringBinderNames, Perhaps, \n  PerhapsM, SiteBinder, TypedBinder, Message, freshBinder, \n  isVarName} from './utils';\nimport { convert, sameType } from '../typechecker/utils';\nimport { readBack } from '../evaluator/utils';\nimport { synthesizer as Synth } from '../typechecker/synthesizer';\nimport { fresh } from './utils';\nimport { varType } from '../utils/context';\n\nexport abstract class Source {\n\n  constructor(\n    public location: Location,\n  ) { }\n\n  /*\n    Find all the names that occur in an expression. For correctness, we\n    need only find the free identifiers, but finding the bound\n    identifiers as well means that the bindings introduced by\n    desugaring expressions are more different from the program as\n    written, which can help readability of internals.\n  */\n  public abstract findNames(): string[];\n\n  public abstract prettyPrint(): string;\n\n  public isType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const ok = new PerhapsM<C.Core>(\"ok\");\n    const theType = this.getType(ctx, renames);\n    return goOn(\n      [[ok, () => theType]],\n      () => {\n        SendPieInfo(this.location, ['is-type', ok.value]);\n        return new go(ok.value);\n      }\n    );\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const checkType = this.check(ctx, renames, new V.Universe());\n    if (checkType instanceof go) {\n      return checkType;\n    } else if (checkType instanceof stop) {\n      if (this instanceof Name && isVarName(this.name)) {\n        const otherTv = new PerhapsM<V.Value>(\"other-tv\");\n        return new goOn(\n          [\n            [otherTv, \n              () => varType(ctx, this.location, this.name)]\n          ],\n          () => {\n            new stop(this.location, new Message([`Expected , but given ${otherTv.value.readBackType(ctx)}`]));\n          }\n        );\n      } else {\n        return new stop(this.location, new Message([`not a type`]));\n      }\n    } else {\n      throw new Error('Invalid checkType');\n    }\n  }\n\n  public check(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const ok = new PerhapsM<C.Core>(\"ok\");\n    const out = this.checkOut(ctx, renames, type);\n    // SendPieInfo(srcLoc(input), ['has-type', readBackType(, tv)!]);\n    return goOn(\n      [[ok, () => out]],\n      () => new go(ok.value)\n    );\n  }\n\n  public synth(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    const ok = new PerhapsM<C.The>(\"ok\");\n    \n    return goOn(\n      [[ok, () => this.synthHelper(ctx, renames)]],\n      () => {\n        SendPieInfo(this.location, ['is-type', ok.value.type]);\n        return new go(ok.value)\n      }\n    );\n  }\n\n  protected abstract synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The>;\n\n  protected checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const theT = new PerhapsM<C.The>(\"theT\");\n    return goOn(\n      [\n        [theT, () => this.synth(ctx, renames)],\n        [\n          new PerhapsM<undefined>(\"_\"),\n          () => sameType(ctx, this.location, valInContext(ctx, theT.value.type), type)\n        ],\n      ],\n      () => new go(theT.value.expr)\n    );\n  }\n}\n\n\nexport class The extends Source {\n  \n  constructor(\n    public location: Location,\n    public type: Source,\n    public value: Source,\n  ) { \n    super(location);\n  }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthThe(ctx, renames, this.type, this.value);\n  }\n\n  public findNames(): string[] {\n    return this.type.findNames()\n      .concat(this.value.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(the ${this.type.prettyPrint()} ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Universe extends Source {\n\n  constructor(\n    public location: Location,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthUniverse(ctx, renames, this.location);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    return new go(new C.Universe());\n  }\n\n  public prettyPrint(): string {\n    return 'U';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Nat extends Source {\n\n  constructor(\n    public location: Location,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthNat(ctx, renames);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    return new go(new C.Nat());\n  }\n\n  public prettyPrint(): string {\n    return 'Nat';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Zero extends Source {\n  \n  constructor(\n    public location: Location,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthZero(ctx, renames);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public prettyPrint(): string {\n    return 'zero';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\nexport class Add1 extends Source {\n  \n  constructor(\n    public location: Location,\n    public base: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthAdd1(ctx, renames, this.base);\n  }\n\n  public findNames(): string[] {\n    return this.base.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(add1 ${this.base.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class WhichNat extends Source {\n  \n  constructor(\n    public location: Location,\n    public target: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthWhichNat(ctx, renames, this.target, this.base, this.step);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(which-nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IterNat extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIterNat(ctx, renames, this.target, this.base, this.step);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(iter-nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class RecNat extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthRecNat(ctx, renames, this.target, this.base, this.step);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(rec-nat ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndNat extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndNat(ctx, renames, this.target, this.motive, this.base, this.step);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames())\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(ind-nat ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n  \n}\n\n// Function types and operations\nexport class Arrow extends Source {\n\n  constructor(\n    public location: Location,\n    public arg1: Source,\n    public arg2: Source,\n    public args: Source[],\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthArrow(ctx, renames, this.location, this.arg1, this.arg2, this.args);\n  }\n\n  public findNames(): string[] {\n    return this.arg1.findNames()\n      .concat(this.arg2.findNames())\n      .concat(this.args.flatMap(arg => arg.findNames()));\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const [A, B, args] = [this.arg1, this.arg2, this.args];\n    if (args.length === 0) {\n      const x = freshBinder(ctx, B, 'x');\n      const Aout = new PerhapsM<C.Core>(\"Aout\");\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [Bout, \n            () => \n              B.isType(\n                bindFree(ctx, x, valInContext(ctx, Aout.value)), \n                renames)\n          ]\n        ],\n        () => {\n          return new go(\n            new C.Pi(x, Aout.value, Bout.value)\n          );\n        }\n      );\n    } else {\n      const [rest0, ...rest] = args;\n      const x = freshBinder(ctx, makeApp(B, rest0, rest), 'x');\n      const Aout = new PerhapsM<C.Core>(\"Aout\");\n      const tout = new PerhapsM<C.Core>('tout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [tout, \n            () => \n              new Arrow(\n                notForInfo(this.location),\n                B, \n                rest0,\n                rest\n              ).isType(\n                bindFree(ctx, x, valInContext(ctx, Aout.value)),\n                renames\n              )\n          ]\n        ],\n        () => new go(new C.Pi(x, Aout.value, tout.value))\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(-> ${this.arg1.prettyPrint()} ${this.arg2.prettyPrint()} ${this.args.map(arg => arg.prettyPrint()).join(' ')})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Pi extends Source {\n\n  constructor(\n    public location: Location,\n    public binders: TypedBinder[],\n    public body: Source,\n  ) { super(location); }\n  \n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthPi(ctx, renames, this.location, this.binders, this.body);\n  }\n\n  public findNames(): string[] {\n    // TEST THIS\n    return this.binders.flatMap(binder => occurringBinderNames(binder))\n      .concat(this.body.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const [binders, B] = [this.binders, this.body];\n    if (binders.length === 1) {\n      const [bd, A] = [binders[0].binder, binders[0].type];\n      const y = fresh(ctx, bd.varName);\n      const xloc = bd.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Aoutv = new PerhapsM<V.Value>('Aoutv');\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [Aoutv, () => \n            new go(valInContext(ctx, Aout.value))\n          ],\n          [Bout, () => \n            B.isType(\n              bindFree(ctx, y, Aoutv.value),\n              extendRenaming(renames, bd.varName, y)\n            )\n          ],\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value]);\n          return new go(\n            new C.Pi(\n              y,\n              Aout.value,\n              Bout.value\n            )\n          )\n        }\n      );\n    } else if (binders.length > 1) {\n      const [bd, ...rest] = binders;\n      const [x, A] = [bd.binder.varName, bd.type];\n      const z = fresh(ctx, x);\n      const xloc = bd.binder.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Aoutv = new PerhapsM<V.Value>('Aoutv');\n      const Bout = new PerhapsM<C.Core>('Bout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [Aoutv, () => \n            new go(valInContext(ctx, Aout.value))\n          ],\n          [Bout, () => \n            new Pi(\n              notForInfo(this.location), \n              rest,\n              B\n            ).isType(\n              bindFree(ctx, z, Aoutv.value),\n              extendRenaming(renames, bd.binder.varName, z)\n            )\n          ]\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value]);\n          return new go(\n            new C.Pi(\n              z,\n              Aout.value,\n              Bout.value\n            )\n          );\n        }\n      );\n    } else {\n      throw new Error('Invalid number of binders in Pi type');\n    }\n  }\n\n  public prettyPrint(): string {\n    return `( ${this.binders.map(binder => `(${binder.binder.varName} ${binder.type.prettyPrint()})`).join(' ')} \n            ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\nexport class Lambda extends Source {\n\n  constructor(\n    public location: Location,\n    public binders: SiteBinder[],\n    public body: Source,\n  ) { super(location); }\n  \n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public findNames(): string[] { \n    return this.binders.map(binder => binder.varName)\n      .concat(this.body.findNames());\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    if (this.binders.length === 1) {\n      const body = this.body;\n      const binder = this.binders[0];\n      const x = binder.varName;\n      const xLoc = binder.location;\n      const typeNow = type.now();\n      if (typeNow instanceof V.Pi) {\n        const A = typeNow.argType;\n        const closure = typeNow.resultType;\n        const xRenamed = rename(renames, x);\n        const bout = new PerhapsM<C.Core>(\"bout\");\n        return goOn(\n          [\n            [\n              bout, \n              () => body.check(\n                bindFree(ctx, xRenamed, A),\n                extendRenaming(renames, x, xRenamed),\n                closure.valOfClosure(\n                  new V.Neutral(\n                    A, \n                    new N.Variable(xRenamed)\n                  )\n                )\n              )\n            ]\n          ],\n          () => {\n            PieInfoHook(xLoc, ['binding-site', A.readBackType(ctx)]);\n            return new go(new C.Lambda(xRenamed, bout.value));\n          }\n        );\n      } else {\n        return new stop(\n          xLoc, \n          new Message([`Not a function type: ${typeNow.readBackType(ctx)}.`])\n        );\n      }\n    } else { // xBinding.length > 1\n      return (new S.Lambda(\n        this.location,\n        [this.binders[0]],\n          (new S.Lambda(\n            notForInfo(this.location),\n            this.binders.slice(1), \n            this.body))\n          )).check(ctx, renames, type);\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(lambda ${this.binders.map(binder => binder.varName).join(' ')} ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Product types and operations\nexport class Sigma extends Source {\n\n  constructor(\n    public location: Location,\n    public binders: TypedBinder[],\n    public body: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthSigma(ctx, renames, this.location, this.binders, this.body);\n  }\n\n  public findNames(): string[] {\n    return this.binders.flatMap(binder => occurringBinderNames(binder))\n      .concat(this.body.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const [binders, D] = [this.binders, this.body];\n    if (binders.length === 1) {\n      const [bd, A] = [binders[0].binder, binders[0].type];\n      const x = bd.varName;\n      const y = fresh(ctx, x);\n      const xloc = bd.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Aoutv = new PerhapsM<V.Value>('Aoutv');\n      const Dout = new PerhapsM<C.Core>('Dout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [Aoutv, () => new go(valInContext(ctx, Aout.value))],\n          [Dout, () => \n            D.isType(\n              bindFree(ctx, y, Aoutv.value),\n              extendRenaming(renames, x, y)\n            )\n          ]\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value]);\n          return new go(\n            new C.Sigma(y, Aout.value, Dout.value)\n          );\n        }\n      );\n    } else if (binders.length > 1) {\n      const [[bd, A], ...rest] \n        = [[binders[0].binder, binders[0].type], binders[1], ...binders.slice(2)];\n      const x = bd.varName;\n      const z = fresh(ctx, x);\n      const xloc = bd.location;\n      const Aout = new PerhapsM<C.Core>('Aout');\n      const Aoutv = new PerhapsM<V.Value>('Aoutv');\n      const Dout = new PerhapsM<C.Core>('Dout');\n      return goOn(\n        [\n          [Aout, () => A.isType(ctx, renames)],\n          [Aoutv, () => new go(valInContext(ctx, Aout.value))],\n          [Dout, () => \n            new Sigma(this.location, rest, D)\n            .isType(\n              bindFree(ctx, x, Aoutv.value),\n              extendRenaming(renames, x, z)\n            )\n          ]\n        ],\n        () => {\n          PieInfoHook(xloc, ['binding-site', Aout.value]);\n          return new go(\n            new C.Sigma(z, Aout.value, Dout.value)\n          );\n        }\n      );\n    } else {\n      throw new Error('Invalid number of binders in Sigma type');\n    }\n  }\n\n  public prettyPrint(): string {\n    return `( ${this.binders.map(binder => `(${binder.binder.varName} ${binder.type.prettyPrint()})`).join(' ')} \n            ${this.body.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Name extends Source {\n\n  constructor(\n    public location: Location,\n    public name: string,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthName(ctx, renames, this.location, this.name);\n  }\n\n  public findNames(): string[] {\n    return [this.name];\n  }\n\n  public prettyPrint(): string {\n    return this.name;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Atom extends Source {\n\n  constructor(\n    public location: Location,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthAtom(ctx, renames);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    return new go(new C.Atom());\n  }\n\n  public prettyPrint(): string {\n    return 'Atom';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Quote extends Source {\n\n  constructor(\n    public location: Location,\n    public name: string,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthQuote(ctx, renames, this.location, this.name);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public prettyPrint(): string {\n    return `'${this.name}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Pair extends Source {\n\n  constructor(\n    public location: Location,\n    public first: Source,\n    public second: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthPair(ctx, renames, this.first, this.second);\n  }\n\n  public findNames(): string[] {\n    return this.first.findNames()\n      .concat(this.second.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const Aout = new PerhapsM<C.Core>('Aout');\n    const Dout = new PerhapsM<C.Core>('Dout');\n    const x = freshBinder(ctx, this.second, 'x');\n    return goOn(\n      [\n        [Aout, () => this.first.isType(ctx, renames)],\n        [Dout, () => this.second.isType(\n          bindFree(ctx, x, valInContext(ctx, Aout.value)), \n          renames)],\n      ],\n      () => new go(new C.Sigma(x, Aout.value, Dout.value))\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Pair ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cons extends Source {\n\n  constructor(\n    public location: Location,\n    public first: Source,\n    public second: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n\n  public findNames(): string[] {\n    return this.first.findNames()\n      .concat(this.second.findNames());\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Sigma) {\n      const A = typeNow.carType;\n      const closure = typeNow.cdrType;\n      const aout = new PerhapsM<C.Core>(\"aout\");\n      const dout = new PerhapsM<C.Core>(\"dout\");\n      return goOn(\n        [\n          [aout, () => this.first.check(ctx, renames, A)],\n          [\n            dout, \n            () => \n              this.second.check(\n                ctx, \n                renames, \n                closure.valOfClosure(valInContext(ctx, aout.value))\n              )\n          ]\n        ],\n        () => new go(\n          new C.Cons(aout.value, dout.value)\n        )\n      );\n    } else {\n      return new stop(\n        this.location,\n        new Message([`cons requires a Pair or  type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(cons ${this.first.prettyPrint()} ${this.second.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Car extends Source {\n\n  constructor(\n    public location: Location,\n    public pair: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthCar(ctx, renames, this.location, this.pair);\n  }\n\n  public findNames(): string[] {\n    return this.pair.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(car ${this.pair.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cdr extends Source {\n\n  constructor(\n    public location: Location,\n    public pair: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthCdr(ctx, renames, this.location, this.pair);\n  }\n\n  public findNames(): string[] {\n    return this.pair.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(cdr ${this.pair.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Basic constructors\nexport class Trivial extends Source {\n\n  constructor(\n    public location: Location,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthTrivial(ctx, renames);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    return new go(new C.Trivial());\n  }\n\n  public prettyPrint(): string {\n    return 'Trivial';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Sole extends Source {\n\n  constructor(\n    public location: Location,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthSole(ctx, renames);\n  }  \n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public prettyPrint(): string {\n    return 'Sole';\n  }\n\n}\n\nexport class Nil extends Source {\n  \n  constructor(\n    public location: Location \n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.List) {\n      return new go(new C.Nil());\n    } else {\n      return new stop(\n        this.location, \n        new Message([`nil requires a List type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return 'nil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Number extends Source {\n\n  constructor(\n    public location: Location,\n    public value: number,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthNumber(ctx, renames, this.location, this.value);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public prettyPrint(): string {\n    return `${this.value}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class List extends Source {\n\n  constructor(\n    public location: Location,\n    public entryType: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthList(ctx, renames, this);\n  }\n\n  public findNames(): string[] {\n    return this.entryType.findNames();\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const Eout = new PerhapsM<C.Core>('Eout');\n    return goOn(\n      [[Eout, () => this.entryType.isType(ctx, renames)]],\n      () => new go(new C.List(Eout.value))\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(List ${this.entryType.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n\n\nexport class ListCons extends Source {\n  \n  constructor(\n    public location: Location,\n    public x: Source,\n    public xs: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthListCons(ctx, renames, this.x, this.xs);\n  }\n\n  public findNames(): string[] {\n    return this.x.findNames()\n      .concat(this.xs.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(:: ${this.x.prettyPrint()} ${this.xs.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class RecList extends Source {\n  \n  constructor(\n    public location: Location,\n    public target: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthRecList(ctx, renames, this.location, this.target, this.base, this.step);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(rec-list ${this.target.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndList extends Source {\n  \n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndList(ctx, renames, this.location, this.target, this.motive, this.base, this.step);\n  }\n  \n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames())\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(ind-list ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()} \n              ${this.step.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Absurd and its operations\nexport class Absurd extends Source {\n  \n  constructor(\n    public location: Location,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthAbsurd(ctx, renames, this);\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    return new go(new C.Absurd());\n  }\n\n  public prettyPrint(): string {\n    return 'Absurd';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndAbsurd extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndAbsurd(ctx, renames, this);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(ind-Absurd \n              ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Equality types and operations\nexport class Equal extends Source {\n\n  constructor(\n    public location: Location,\n    public type: Source,\n    public left: Source,\n    public right: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthEqual(ctx, renames, this.type, this.left, this.right);\n  }\n  \n\n  public findNames(): string[] {\n    return this.type.findNames()\n      .concat(this.left.findNames())\n      .concat(this.right.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const [A, from, to] = [this.type, this.left, this.right];\n    const Aout = new PerhapsM<C.Core>('Aout');\n    const Av = new PerhapsM<V.Value>('Av');\n    const from_out = new PerhapsM<C.Core>('from_out');\n    const to_out = new PerhapsM<C.Core>('to_out');\n    return goOn(\n      [\n        [Aout, () => A.isType(ctx, renames)],\n        [Av, () => new go(valInContext(ctx, Aout.value))],\n        [from_out, () => from.check(ctx, renames, Av.value)],\n        [to_out, () => to.check(ctx, renames, Av.value)],\n      ],\n      () => new go(\n        new C.Equal(Aout.value, from_out.value, to_out.value)\n      )\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(= ${this.type.prettyPrint()} \n              ${this.left.prettyPrint()} \n              ${this.right.prettyPrint()})`;  \n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Same extends Source {\n\n  constructor(\n    public location: Location,\n    public type: Source,\n  ) { super(location); }\n\n  \n  public findNames(): string[] {\n    return this.type.findNames();\n  }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Equal) {\n      const A = typeNow.type;\n      const from = typeNow.from;\n      const to = typeNow.to;\n      const cout = new PerhapsM<C.Core>(\"cout\");\n      const val = new PerhapsM<V.Value>(\"val\");\n      return goOn(\n        [\n          [cout, () => this.type.check(ctx, renames, A)],\n          [val, () => new go(valInContext(ctx, cout.value))],\n          [\n            new PerhapsM<undefined>(\"_\"), \n            () => convert(ctx, this.type.location, A, from, val.value)\n          ],\n          [\n            new PerhapsM<undefined>(\"_\"),\n            () => convert(ctx, this.type.location, A, to, val.value)\n          ],\n        ],\n        () => new go(new C.Same(cout.value))\n      );\n    } else {\n      return new stop(\n        this.location,\n        new Message([`same requires an Equal type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(same ${this.type.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Replace extends Source {\n  \n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n    public base: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthReplace(ctx, renames, this.location, this.target, this.motive, this.base);\n  }\n  \n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames())\n      .concat(this.base.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(replace ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Trans extends Source {\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthTrans(ctx, renames, this.location, this.left, this.right);\n  }\n  constructor(\n    public location: Location,\n    public left: Source,\n    public right: Source,\n  ) { super(location); }\n\n  public findNames(): string[] {\n    return this.left.findNames()\n      .concat(this.right.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(trans ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Cong extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public fun: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthCong(ctx, renames, this.location, this.target, this.fun);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.fun.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(cong ${this.target.prettyPrint()} ${this.fun.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Symm extends Source {\n\n  constructor(\n    public location: Location,\n    public equality: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthSymm(ctx, renames, this.location, this.equality);\n  }\n\n\n  public findNames(): string[] {\n    return this.equality.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(symm ${this.equality.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndEqual extends Source {\n\n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n    public base: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndEqual(ctx, renames, this.location, this.target, this.motive, this.base);\n  }\n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames())\n      .concat(this.base.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(ind-= ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.base.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Vector types and operations\nexport class Vec extends Source {\n\n  constructor(\n    public location: Location,\n    public type: Source,\n    public length: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthVec(ctx, renames, this.type, this.length);\n  }\n\n  public findNames(): string[] {\n    return this.type.findNames()\n      .concat(this.length.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const Eout = new PerhapsM<C.Core>(\"Eout\");\n    const lenout = new PerhapsM<C.Core>('lenout');\n    return goOn(\n      [[Eout, () => this.isType(ctx, renames)],\n      [lenout, () => this.length.check(ctx, renames, new V.Nat())]],\n      () => new go(new C.Vec(Eout.value, lenout.value))\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Vec ${this.type.prettyPrint()} ${this.length.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VecNil extends Source {\n  \n  constructor(\n    public location: Location,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public findNames(): string[] {\n    return [];\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Vec) {\n      if (typeNow.length instanceof V.Zero) {\n        return new go('vecnil');\n      } else {\n        return new stop(this.location,\n          new Message([`vecnil requires a Vec type with length ZERO, but was used as a: \n          ${readBack(ctx, new V.Nat(), typeNow.length)}.`]));\n      }\n    } else {\n      return new stop(\n        this.location,\n        new Message([`vecnil requires a Vec type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return 'vecnil';\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class VecCons extends Source {\n  constructor(\n    public location: Location,\n    public x: Source,\n    public xs: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n    \n  public findNames(): string[] {\n    return this.x.findNames()\n      .concat(this.xs.findNames());\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Vec) {\n      if (typeNow.length instanceof V.Add1) {\n        const hout = new PerhapsM<C.Core>(\"hout\");\n        const tout = new PerhapsM<C.Core>(\"tout\");\n        const n_minus_1 = typeNow.length.smaller;\n        return goOn(\n          [\n            [hout, () => this.x.check(ctx, renames, typeNow.entryType)],\n            [tout, () => \n              this.xs.check(ctx, renames, new V.Vec(typeNow.entryType, n_minus_1))\n            ]\n          ],\n          () => new go(new C.VecCons(hout.value, tout.value))\n        );\n      } else {\n        return new stop(\n          this.location,\n          new Message([`vec:: requires a Vec type with length Add1, but was used with a: \n          ${readBack(ctx, new V.Nat(), typeNow.length)}.`])\n        );\n      }\n    } else {\n      return new stop(\n        this.location,\n        new Message([`vec:: requires a Vec type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(vec:: ${this.x.prettyPrint()} ${this.xs.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Head extends Source {\n\n  constructor(\n    public location: Location,\n    public vec: Source,\n  ) { super(location); }\n\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthHead(ctx, renames, this.location, this.vec);\n  }\n\n  public findNames(): string[] {\n    return this.vec.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(head ${this.vec.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Tail extends Source {\n\n  constructor(\n    public location: Location,\n    public vec: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthTail(ctx, renames, this.location, this.vec);\n  }\n\n  public findNames(): string[] {\n    return this.vec.findNames();\n  }\n\n  public prettyPrint(): string {\n    return `(tail ${this.vec.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndVec extends Source {\n\n  constructor(\n    public location: Location,\n    public length: Source,\n    public target: Source,\n    public motive: Source,\n    public base: Source,\n    public step: Source,\n  ) { super(location); }\n\n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndVec(ctx, renames, this.location, \n      this.length, this.target, this.motive, this.base, this.step);\n  }\n  \n  public findNames(): string[] {\n    return this.length.findNames()\n      .concat(this.target.findNames())\n      .concat(this.motive.findNames())\n      .concat(this.base.findNames())\n      .concat(this.step.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `ind-Vec ${this.length.prettyPrint()}\n              ${this.target.prettyPrint()}\n              ${this.motive.prettyPrint()}\n              ${this.base.prettyPrint()}\n              ${this.step.prettyPrint()}`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Either type and operations\nexport class Either extends Source {\n\n  constructor(\n    public location: Location,\n    public left: Source,\n    public right: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthEither(ctx, renames, this.left, this.right);\n  }\n\n  public findNames(): string[] {\n    return this.left.findNames()\n      .concat(this.right.findNames());\n  }\n\n  public getType(ctx: Context, renames: Renaming): Perhaps<C.Core> {\n    const Lout = new PerhapsM<C.Core>(\"Lout\");\n    const Rout = new PerhapsM<C.Core>(\"Rout\");\n    return goOn(\n      [\n        [Lout, () => this.left.isType(ctx, renames)],\n        [Rout, () => this.right.isType(ctx, renames)]\n      ],\n      () => new go(new C.Either(Lout.value, Rout.value))\n    );\n  }\n\n  public prettyPrint(): string {\n    return `(Either ${this.left.prettyPrint()} ${this.right.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Left extends Source {\n  constructor(\n    public location: Location,\n    public value: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public findNames(): string[] {\n    return this.value.findNames();\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Either) {\n      const lout = new PerhapsM<C.Core>(\"lout\");\n      return goOn(\n        [\n          [lout, () => this.value.check(ctx, renames, typeNow.leftType)]\n        ],\n        () => new go(new C.Left(lout.value))\n      );\n    } else {\n      return new stop(\n        this.location,\n        new Message([`left requires an Either type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(left ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class Right extends Source {\n  constructor(\n    public location: Location,\n    public value: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n\n  public findNames(): string[] {\n    return this.value.findNames();\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeNow = type.now();\n    if (typeNow instanceof V.Either) {\n      const rout = new PerhapsM<C.Core>(\"rout\");\n      return goOn(\n        [\n          [rout, () => this.value.check(ctx, renames, typeNow.rightType)]\n        ],\n        () => new go(new C.Right(rout.value))\n      );\n    } else {\n      return new stop(\n        this.location,\n        new Message([`right requires an Either type, but was used as a: ${typeNow.readBackType(ctx)}.`])\n      );\n    }\n  }\n\n  public prettyPrint(): string {\n    return `(right ${this.value.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\nexport class IndEither extends Source {\n  constructor(\n    public location: Location,\n    public target: Source,\n    public motive: Source,\n    public baseLeft: Source,\n    public baseRight: Source,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthIndEither(ctx, renames, this.location, this.target, this.motive, this.baseLeft, this.baseRight);\n  }  \n\n  public findNames(): string[] {\n    return this.target.findNames()\n      .concat(this.motive.findNames())\n      .concat(this.baseLeft.findNames())\n      .concat(this.baseRight.findNames());\n  }\n\n  public prettyPrint(): string {\n    return `(ind-Either ${this.target.prettyPrint()} \n              ${this.motive.prettyPrint()} \n              ${this.baseLeft.prettyPrint()} \n              ${this.baseRight.prettyPrint()})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Utility\nexport class TODO extends Source {\n  constructor(\n    public location: Location,\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    throw new Error('Method not implemented.');\n  }\n  \n  public findNames(): string[] {\n    return [];\n  }\n\n  public checkOut(ctx: Context, renames: Renaming, type: V.Value): Perhaps<C.Core> {\n    const typeVal = type.readBackType(ctx);\n    SendPieInfo(this.location, ['TODO', readBackContext(ctx), typeVal]);\n    return new go(new C.TODO(this.location.locationToSrcLoc(), typeVal));\n  }\n\n  public prettyPrint(): string {\n    return `TODO`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n\n}\n\n// Application\nexport class Application extends Source {\n  constructor(\n    public location: Location,\n    public func: Source,\n    public arg: Source,\n    public args: Source[],\n  ) { super(location); }\n  \n  protected synthHelper(ctx: Context, renames: Renaming): Perhaps<C.The> {\n    return Synth.synthApplication(ctx, renames, this.location, this.func, this.arg, this.args);\n  }\n\n  public findNames(): string[] {\n    return this.func.findNames()\n      .concat(this.arg.findNames())\n      .concat(this.args.flatMap(arg => arg.findNames()));\n  }\n\n  public prettyPrint(): string {\n    return `(${this.func.prettyPrint()} ${this.arg.prettyPrint()} ${this.args.map(arg => arg.prettyPrint()).join(' ')})`;\n  }\n\n  public toString(): string {\n    return this.prettyPrint();\n  }\n}","import { SchemeLexer } from \"../../scheme_parser/transpiler/lexer/scheme-lexer\";\nimport { SchemeParser } from \"../../scheme_parser/transpiler/parser/scheme-parser\";\nimport { Extended, Atomic, Expression,  } from '../../scheme_parser/transpiler/types/nodes/scheme-node-types';\nimport { Location, Syntax } from \"../utils/locations\";\nimport * as S from \"../types/source\";\nimport { Location as Loc, Position } from '../../scheme_parser/transpiler/types/location';\nimport { isVarName, SiteBinder, TypedBinder } from \"../types/utils\";\nimport * as util from 'util';\n\n\ntype Element = Extended.List | Atomic.Symbol | Atomic.NumericLiteral;\n\n// ### Helper functions\n\nfunction syntaxToLocation(syntax: Syntax): Location {\n  return new Location(\n    syntax,\n    true,\n  );\n}\n\nfunction syntaxToSiteBinder(syntax: Syntax): SiteBinder {\n  return new SiteBinder(\n    syntaxToLocation(syntax),\n    syntax.source\n  )\n}\n\nfunction getValue(element: Element): string {\n  if (element instanceof Atomic.Symbol) {\n    return element.value;\n  } else if (element instanceof Atomic.NumericLiteral) {\n    return element.value;\n  } else if (element instanceof Extended.List) {\n    return getValue(element.elements[0] as Element);\n  } else {\n    throw new Error('Expected a Element, but got: ' + element);\n  }\n}\n\nfunction locationToSyntax(source: string, location: Loc): Syntax {\n  return new Syntax(\n    location.start,\n    location.end,\n    source,\n  );\n}\n\nfunction elementToSyntax(element: Element, location: Loc): Syntax {\n  return locationToSyntax(getValue(element), location);\n}\n\n// ### Parser\n// The parser class is responsible for parsing the AST generated by the SchemeParser\nexport function schemeParse(stx: string): Extended.List[] {\n  const lexer = new SchemeLexer(stx);\n  const parser = new SchemeParser('', lexer.scanTokens());\n  const ast: Extended.List[] = parser.parse() as Extended.List[];\n  return ast;\n}\n\nexport class Parser {\n  public static parsePie(stx: string): S.Source {\n    return this.parseElements(schemeParse(stx)[0]); \n  }\n\n  static parseElements(element: Element): S.Source {\n    const parsee = getValue(element);\n    if (parsee === 'U') {\n      return makeU(locationToSyntax('U', element.location));\n    } else if (parsee === 'the') {\n      let elements = (element as Extended.List).elements;\n      let loc = element.location;\n      return makeThe(\n        locationToSyntax('the', loc),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element)\n      );\n    } else if (parsee === 'Nat') {\n      return makeNat(locationToSyntax('Nat', element.location));\n    } else if (parsee === 'zero') {\n      return makeZero(locationToSyntax('zero', element.location));\n    } else if (parsee === 'add1') {\n      return makeAdd1(\n        locationToSyntax('add1', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === '->' || parsee === '') {\n      let elements = (element as Extended.List).elements;\n      let loc = element.location;\n      return makeArrow(\n        locationToSyntax('->', loc),\n        [\n          this.parseElements(elements[1] as Element),\n          this.parseElements(elements[2] as Element),\n          elements.slice(3).map((x: Expression) => this.parseElements(x as Element))\n        ]\n      );\n    } else if (parsee === 'lambda' || parsee === '') {\n      let elements = (element as Extended.List).elements;\n      let loc = element.location;\n      let args = elements[1] as Extended.List;\n      let body = elements[2] as Element;\n      return makeLambda(\n        locationToSyntax('', loc),\n        args.elements.map(\n          (x: Expression) =>\n            syntaxToSiteBinder(\n              elementToSyntax(x as Element, element.location)\n            )\n        ),\n        this.parseElements(body)\n      );\n    } else if (parsee === 'Pi' || parsee === '') {\n      let elements = (element as Extended.List).elements;\n      let args = elements[1] as Extended.List;\n      let body = elements[2] as Element;\n\n      // Get first binding pair\n      let firstPair = args.elements[0] as Extended.List;\n      let x0 = firstPair.elements[0] as Element;\n      let A0 = firstPair.elements[1] as Element;\n\n      // Process remaining binding pairs\n      let remainingPairs = args.elements.slice(1) as Extended.List[];\n      let processedPairs = remainingPairs.map(pair => {\n        let x = pair.elements[0] as Element;\n        let A = pair.elements[1] as Element;\n        return new TypedBinder(\n          syntaxToSiteBinder(elementToSyntax(x, pair.location)),\n          this.parseElements(A)\n        );\n      });\n      return makePi(\n        locationToSyntax('', (element as Extended.List).location),\n        makeTypedBinders(\n          new TypedBinder(\n            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),\n            this.parseElements(A0)\n          ),\n          processedPairs\n        ),\n        this.parseElements(body)\n      );\n    } else if (parsee === 'Sigma' || parsee === '') {\n      let elements = (element as Extended.List).elements;\n      let args = elements[1] as Extended.List;\n      let body = elements[2] as Element;\n\n      // Get first binding pair\n      let firstPair = args.elements[0] as Extended.List;\n      let x0 = firstPair.elements[0] as Element;\n      let A0 = firstPair.elements[1] as Element;\n\n      // Process remaining binding pairs\n      let remainingPairs = args.elements.slice(1) as Extended.List[];\n      let processedPairs = remainingPairs.map(pair => {\n        let x = pair.elements[0] as Element;\n        let A = pair.elements[1] as Element;\n        return new TypedBinder(\n          syntaxToSiteBinder(elementToSyntax(x, pair.location)),\n          this.parseElements(A)\n        );\n      });\n      return makeSigma(\n        locationToSyntax('', (element as Extended.List).location),\n        makeTypedBinders(\n          new TypedBinder(\n            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),\n            this.parseElements(A0)\n          ),\n          processedPairs\n        ),\n        this.parseElements(body));\n    } else if (parsee === 'Pair') {\n      let elements = (element as Extended.List).elements;\n      return makePair(\n        locationToSyntax('Pair', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element)\n      );\n    } else if (parsee === 'cons') {\n      let elements = (element as Extended.List).elements;\n      return makeCons(\n        locationToSyntax('Cons', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element)\n      );\n    } else if (parsee === 'car') {\n      return makeCar(\n        locationToSyntax('car', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === 'cdr') {\n      return makeCdr(\n        locationToSyntax('cdr', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === 'which-Nat') {\n      let elements = (element as Extended.List).elements;\n      return makeWhichNat(\n        locationToSyntax('which-Nat', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'iter-Nat') {\n      let elements = (element as Extended.List).elements;\n      return makeIterNat(\n        locationToSyntax('iter-Nat', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'rec-Nat') {\n      let elements = (element as Extended.List).elements;\n      return makeRecNat(\n        locationToSyntax('rec-Nat', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'ind-Nat') {\n      let elements = (element as Extended.List).elements;\n      return makeIndNat(\n        locationToSyntax('ind-Nat', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n        this.parseElements(elements[4] as Element),\n      );\n    } else if (parsee === 'Atom') {\n      return makeAtom(locationToSyntax('Atom', element.location));\n    } else if (parsee === 'quote') {\n      return makeQuote(\n        locationToSyntax('Quote', element.location),\n        getValue((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === 'Trivial') {\n      return makeTrivial(locationToSyntax('Trivial', element.location));\n    } else if (parsee === 'sole') {\n      return makeSole(locationToSyntax('sole', element.location));\n    } else if (parsee === 'List') {\n      return makeList(\n        locationToSyntax('List', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === 'nil') {\n      return makeNil(locationToSyntax('nil', element.location));\n    } else if (parsee === '::') {\n      let elements = (element as Extended.List).elements;\n      return makeListCons(\n        locationToSyntax('::', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'rec-List') {\n      let elements = (element as Extended.List).elements;\n      return makeRecList(\n        locationToSyntax('rec-List', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'ind-List') {\n      let elements = (element as Extended.List).elements;\n      return makeIndList(\n        locationToSyntax('ind-List', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n        this.parseElements(elements[4] as Element),\n      );\n    } else if (parsee === '=') {\n      let elements = (element as Extended.List).elements;\n      return makeEqual(\n        locationToSyntax('=', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'same') {\n      return makeSame(\n        locationToSyntax('same', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element)\n      );\n    } else if (parsee === 'replace') {\n      let elements = (element as Extended.List).elements;\n      return makeReplace(\n        locationToSyntax('replace', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'trans') {\n      let elements = (element as Extended.List).elements;\n      return makeTrans(\n        locationToSyntax('trans', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'cong') {\n      let elements = (element as Extended.List).elements;\n      return makeCong(\n        locationToSyntax('cong', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'ind-=') {\n      let elements = (element as Extended.List).elements;\n      return makeIndEqual(\n        locationToSyntax('ind-=', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n      );\n    } else if (parsee === 'symm') {\n      return makeSymm(\n        locationToSyntax('symm', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element),\n      );\n    } else if (parsee === 'Vec') {\n      let elements = (element as Extended.List).elements;\n      return makeVec(\n        locationToSyntax('Vec', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'vecnil') {\n      return makeVecNil(\n        locationToSyntax('vecnil', element.location),\n      );\n    } else if (parsee === 'vec::') {\n      let elements = (element as Extended.List).elements;\n      return makeVecCons(\n        locationToSyntax('vec::', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'head') {\n      return makeHead(\n        locationToSyntax('head', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element),\n      );\n    } else if (parsee === 'tail') {\n      return makeTail(\n        locationToSyntax('tail', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element),\n      );\n    } else if (parsee === 'ind-Vec') {\n      let elements = (element as Extended.List).elements;\n      return makeIndVec(\n        locationToSyntax('ind-Vec', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n        this.parseElements(elements[4] as Element),\n        this.parseElements(elements[5] as Element),\n      );\n    } else if (parsee === 'Either') {\n      let elements = (element as Extended.List).elements;\n      return makeEither(\n        locationToSyntax('Either', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'left') {\n      return makeLeft(\n        locationToSyntax('left', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element),\n      );\n    }\n    else if (parsee === 'right') {\n      return makeRight(\n        locationToSyntax('right', element.location),\n        this.parseElements((element as Extended.List).elements[1] as Element),\n      );\n    } else if (parsee === 'ind-Either') {\n      let elements = (element as Extended.List).elements;\n      return makeIndEither(\n        locationToSyntax('ind-Either', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n        this.parseElements(elements[3] as Element),\n        this.parseElements(elements[4] as Element),\n      );\n    } else if (parsee === 'Absurd') {\n      return makeAbsurd(\n        locationToSyntax('Absurd', element.location),\n      );\n    } else if (parsee === 'ind-Absurd') {\n      let elements = (element as Extended.List).elements;\n      return makeIndAbsurd(\n        locationToSyntax('ind-Absurd', element.location),\n        this.parseElements(elements[1] as Element),\n        this.parseElements(elements[2] as Element),\n      );\n    } else if (parsee === 'TODO') {\n      return makeTODO(locationToSyntax('TODO', element.location));\n    } else if (element instanceof Extended.List && (element as Extended.List).elements.length > 1) {\n      let elements = (element as Extended.List).elements;\n      return makeApp(\n        locationToSyntax('App', element.location),\n        this.parseElements(elements[0] as Element),\n        this.parseElements(elements[1] as Element),\n        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)\n        )\n      );\n    } else if (isVarName(parsee)) {\n      return makeVarRef(locationToSyntax(parsee, element.location), parsee);\n    } else if (!isNaN(Number(parsee))) { // numeric literal\n      return makeNatLiteral(locationToSyntax(parsee, element.location), parsee);\n    }\n    throw new Error('Unexpected element: ' + element);\n  }\n}\n\n// ### Helper functions for parsing the AST\n\nfunction makeU(stx: Syntax): S.Source {\n  return new S.Universe(syntaxToLocation(stx));\n}\n\nfunction makeArrow(stx: Syntax, args: [S.Source, S.Source, S.Source[]]): S.Source {\n  return new S.Arrow(syntaxToLocation(stx), args[0], args[1], args[2]);\n}\n\nfunction makeNat(stx: Syntax): S.Source {\n  return new S.Nat(syntaxToLocation(stx));\n}\n\nfunction makeZero(stx: Syntax): S.Source {\n  return new S.Zero(syntaxToLocation(stx));\n}\n\nfunction makeAdd1(stx: Syntax, n: S.Source): S.Source {\n  return new S.Add1(syntaxToLocation(stx), n);\n}\n\nfunction makeLambda(stx: Syntax, binders: SiteBinder[], body: S.Source): S.Source {\n  return new S.Lambda(syntaxToLocation(stx), binders, body);\n}\n\nfunction makePi(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source {\n  return new S.Pi(syntaxToLocation(stx), binders, body);\n}\n\nfunction makeSigma(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source {\n  return new S.Sigma(syntaxToLocation(stx), binders, body);\n}\n\nfunction makeTypedBinders(head: TypedBinder, tail: TypedBinder[]): TypedBinder[] {\n  return [head, ...tail];\n}\n\nfunction makeApp(stx: Syntax, func: S.Source, arg0: S.Source, args: S.Source[]): S.Source {\n  return new S.Application(syntaxToLocation(stx), func, arg0, args);\n}\n\nfunction makeAtom(stx: Syntax): S.Source {\n  return new S.Atom(syntaxToLocation(stx));\n}\n\nfunction makeTrivial(stx: Syntax): S.Source {\n  return new S.Trivial(syntaxToLocation(stx));\n}\n\nfunction makeSole(stx: Syntax): S.Source {\n  return new S.Sole(syntaxToLocation(stx));\n}\n\nfunction makeList(stx: Syntax, type: S.Source): S.Source {\n  return new S.List(syntaxToLocation(stx), type);\n}\n\nfunction makeVec(stx: Syntax, type: S.Source, len: S.Source): S.Source {\n  return new S.Vec(syntaxToLocation(stx), type, len);\n}\n\nfunction makeEither(stx: Syntax, left: S.Source, right: S.Source): S.Source {\n  return new S.Either(syntaxToLocation(stx), left, right);\n}\n\nfunction makeNil(stx: Syntax): S.Source {\n  return new S.Nil(syntaxToLocation(stx));\n}\n\nfunction makeVecCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {\n  return new S.VecCons(syntaxToLocation(stx), head, tail);\n}\n\nfunction makeVecNil(stx: Syntax): S.Source {\n  return new S.VecNil(syntaxToLocation(stx));\n}\n\nfunction makeAbsurd(stx: Syntax): S.Source {\n  return new S.Absurd(syntaxToLocation(stx));\n}\n\nfunction makePair(stx: Syntax, head: S.Source, tail: S.Source): S.Source {\n  return new S.Pair(syntaxToLocation(stx), head, tail);\n}\n\nfunction makeCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {\n  return new S.Cons(syntaxToLocation(stx), head, tail);\n}\n\nfunction makeListCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source {\n  return new S.ListCons(syntaxToLocation(stx), head, tail);\n}\n\nfunction makeThe(stx: Syntax, type: S.Source, value: S.Source): S.Source {\n  return new S.The(syntaxToLocation(stx), type, value);\n}\n\nfunction makeIndAbsurd(stx: Syntax, head: S.Source, tail: S.Source): S.Source {\n  return new S.IndAbsurd(syntaxToLocation(stx), head, tail);\n}\n\nfunction makeTrans(stx: Syntax, from: S.Source, to: S.Source): S.Source {\n  return new S.Trans(syntaxToLocation(stx), from, to);\n}\n\nfunction makeCong(stx: Syntax, from: S.Source, to: S.Source): S.Source {\n  return new S.Cong(syntaxToLocation(stx), from, to);\n}\n\nfunction makeIndEqual(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source {\n  return new S.IndEqual(syntaxToLocation(stx), target, mot, base);\n}\n\nfunction makeWhichNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.WhichNat(syntaxToLocation(stx), target, base, step);\n}\n\nfunction makeIterNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.IterNat(syntaxToLocation(stx), target, base, step);\n}\n\nfunction makeRecNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.RecNat(syntaxToLocation(stx), target, base, step);\n}\n\nfunction makeIndNat(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.IndNat(syntaxToLocation(stx), target, mot, base, step);\n}\n\nfunction makeRecList(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.RecList(syntaxToLocation(stx), target, base, step);\n}\n\nfunction makeIndList(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.IndList(syntaxToLocation(stx), target, mot, base, step);\n}\n\nfunction makeIndEither(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.IndEither(syntaxToLocation(stx), target, mot, base, step);\n}\n\nfunction makeIndVec(stx: Syntax, length: S.Source, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source {\n  return new S.IndVec(syntaxToLocation(stx), length, target, mot, base, step);\n}\n\nfunction makeEqual(stx: Syntax, type: S.Source, left: S.Source, right: S.Source): S.Source {\n  return new S.Equal(syntaxToLocation(stx), type, left, right);\n}\n\nfunction makeReplace(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source {\n  return new S.Replace(syntaxToLocation(stx), target, mot, base);\n}\n\nfunction makeSymm(stx: Syntax, equality: S.Source): S.Source {\n  return new S.Symm(syntaxToLocation(stx), equality);\n}\n\nfunction makeHead(stx: Syntax, vec: S.Source): S.Source {\n  return new S.Head(syntaxToLocation(stx), vec);\n}\n\nfunction makeTail(stx: Syntax, vec: S.Source): S.Source {\n  return new S.Tail(syntaxToLocation(stx), vec);\n}\n\nfunction makeSame(stx: Syntax, type: S.Source): S.Source {\n  return new S.Same(syntaxToLocation(stx), type);\n}\n\nfunction makeLeft(stx: Syntax, value: S.Source): S.Source {\n  return new S.Left(syntaxToLocation(stx), value);\n}\n\nfunction makeRight(stx: Syntax, value: S.Source): S.Source {\n  return new S.Right(syntaxToLocation(stx), value);\n}\n\nfunction makeCar(stx: Syntax, pair: S.Source): S.Source {\n  return new S.Car(syntaxToLocation(stx), pair);\n}\n\nfunction makeCdr(stx: Syntax, pair: S.Source): S.Source {\n  return new S.Cdr(syntaxToLocation(stx), pair);\n}\n\nfunction makeQuote(stx: Syntax, quoted: string): S.Source {\n  return new S.Quote(syntaxToLocation(stx), quoted);\n}\n\nfunction makeVarRef(stx: Syntax, ref: string): S.Source {\n  return new S.Name(syntaxToLocation(stx), ref);\n}\n\nfunction makeNatLiteral(stx: Syntax, num: string): S.Source {\n  return new S.Number(syntaxToLocation(stx), Number(num));\n}\n\nfunction makeTODO(stx: Syntax): S.Source {\n  return new S.TODO(syntaxToLocation(stx));\n}\n\nexport class Claim {\n  constructor (\n    public location: Location,\n    public name: string,\n    public type: S.Source\n  ) {}\n}\n\nexport class Definition {\n  constructor (\n    public location: Location,\n    public name: string,\n    public expr: S.Source\n  ) {}\n}\n\nexport class SamenessCheck {\n  constructor (\n    public location: Location,\n    public type: S.Source,\n    public left: S.Source,\n    public right: S.Source\n  ) {}\n}\n\n\n\nexport type Declaration = Claim | Definition | SamenessCheck | S.Source;\n\n\nexport class pieDeclarationParser {\n  public static parseDeclaration(ast: Extended.List): Declaration {\n    const parsee = getValue(ast);\n    if (parsee === 'claim') {\n      let elements = (ast as Extended.List).elements;\n      return new Claim(\n        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),\n        getValue(elements[1] as Element),\n        Parser.parseElements(elements[2] as Element)\n      );\n    } else if (parsee === 'define') {\n      let elements = (ast as Extended.List).elements;\n      return new Definition(\n        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),\n        getValue(elements[1] as Element),\n        Parser.parseElements(elements[2] as Element)\n      );\n    } else if (parsee === 'check-same') {\n      let elements = (ast as Extended.List).elements;\n      return new SamenessCheck(\n        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),\n        Parser.parseElements(elements[1] as Element),\n        Parser.parseElements(elements[2] as Element),\n        Parser.parseElements(elements[3] as Element)\n      );\n    } else {\n      return Parser.parseElements(ast);\n    }\n  }\n}","import { Context, valInContext} from '../utils/context';\nimport { Source } from '../types/source';\nimport * as util from 'util';\nimport * as C from '../types/core';\nimport * as V from '../types/value';\nimport { go, goOn, Perhaps, PerhapsM } from '../types/utils';\nimport { readBack } from '../evaluator/utils';\nimport { Location } from '../utils/locations';\nimport { convert } from './utils';\n\n/**\n * Represent the expression in the context.\n */\nexport function represent(ctx: Context, expr: Source): Perhaps<C.Core> {\n  const outmeta = new PerhapsM<C.The>('outmeta');\n  return goOn([[outmeta, () => expr.synth(ctx, new Map())]],\n    () => {\n      console.log(outmeta.value)\n      const tv = valInContext(ctx, outmeta.value.type);\n      const v = valInContext(ctx, outmeta.value.expr);\n      return new go(\n        new C.The(tv.readBackType(ctx), readBack(ctx, tv, v))\n      );\n    }\n  );\n}\n\nexport function normType(ctx: Context, src: Source): Perhaps<C.Core> {\n  const eout = new PerhapsM<C.Core>('eout');\n  return goOn(\n    [[eout, () => src.isType(ctx, new Map())]],\n    () => {\n      return new go(valInContext(ctx, eout.value!).readBackType(ctx));\n    }\n  )\n}\n\n// (: check-same (-> Ctx Loc Src Src Src (Perhaps Void)))\n// (define (check-same  loc t a b)\n//   (go-on ((t-out (is-type  '() t))\n//           (tv (go (val-in-ctx  t-out)))\n//           (a-out (check  '() a tv))\n//           (b-out (check  '() b tv))\n//           (av (go (val-in-ctx  a-out)))\n//           (bv (go (val-in-ctx  b-out))))\n//     (convert  loc tv av bv)))\n\nexport function checkSame(ctx: Context, where: Location, t: Source, a: Source, b: Source): Perhaps<undefined> {\n  const typeOut = new PerhapsM<C.Core>('tOut');\n  const typeValue = new PerhapsM<V.Value>('tv');\n  const leftOut = new PerhapsM<C.Core>('aOut');\n  const rightOut = new PerhapsM<C.Core>('bOut');\n  const leftValue = new PerhapsM<V.Value>('av');\n  const rightValue = new PerhapsM<V.Value>('bv');\n  return goOn(\n    [\n      [typeOut, () => t.isType(ctx, new Map())],\n      [typeValue, () => valInContext(ctx, typeOut.value).readBackType(ctx)],\n      [leftOut, () => a.check(ctx, new Map(), typeValue.value)],\n      [rightOut, () => b.check(ctx, new Map(), typeValue.value)],\n      [leftValue, () => valInContext(ctx, leftOut.value)],\n      [rightValue, () => valInContext(ctx, rightOut.value)]\n    ],\n    () => {\n      return convert(ctx, where, typeValue.value, leftValue.value, rightValue.value);\n    }\n  );\n}\n","import { RunnerPlugin } from \"..\";\nimport { Conduit, IConduit, ILink } from \"../../../conduit\";\nimport { EvaluatorClass, IRunnerPlugin } from \"../types\";\n\n/**\n * Initialise this runner with the evaluator to be used.\n * @param evaluatorClass The Evaluator to be used on this runner.\n * @param link The underlying communication link.\n * @returns The initialised `runnerPlugin` and `conduit`.\n */\nexport function initialise(evaluatorClass: EvaluatorClass, link: ILink = self as ILink): { runnerPlugin: IRunnerPlugin, conduit: IConduit } {\n    const conduit = new Conduit(link, false);\n    const runnerPlugin = conduit.registerPlugin(RunnerPlugin, evaluatorClass);\n    return { runnerPlugin, conduit };\n}\n","import * as util from 'util';\nimport { initialise } from \"conductor/src/conductor/runner/util/\";\nimport { PieEvaluator } from './PieEvaluator';\n\nconst { runnerPlugin, conduit } = initialise(PieEvaluator);","import { BasicEvaluator } from \"conductor/src/conductor/runner\";\nimport { IRunnerPlugin } from \"conductor/src/conductor/runner/types\";\nimport { evaluatePie } from \"./main\";\n\n// const eval2 = eval;\n\nexport class PieEvaluator extends BasicEvaluator {\n    private executionCount: number;\n\n    constructor(conductor: IRunnerPlugin) {\n        super(conductor);\n        this.executionCount = 0;\n    }\n    \n    async evaluateChunk(chunk: string): Promise<void> {\n        this.executionCount++;\n        try {\n            let rep = evaluatePie(chunk);\n            this.conductor.sendOutput(`Result of expression: ${rep}`);\n        } catch (error) {\n            // Handle errors and send them to the REPL\n            if (error instanceof Error) {\n                this.conductor.sendOutput(`Error: ${error.message}`);\n            } else {\n                this.conductor.sendOutput(`Error: ${String(error)}`);\n            }\n        }\n        \n    }\n}","import {schemeParse, pieDeclarationParser, Claim, Definition, SamenessCheck} from './parser/parser'\nimport { checkSame, normType } from './typechecker/represent';\nimport { go, stop } from './types/utils';\nimport { prettyPrint } from './unparser/pretty';\nimport { addClaimToContext, addDefineToContext, Context, initCtx } from './utils/context';\nimport * as util from 'util';\nimport { Location } from './utils/locations';\n\n\nexport function evaluatePie(str){\n  const astList = schemeParse(str);\n  let ctx = initCtx;\n  let output = \"\";\n  for (const ast of astList) {\n    const src = pieDeclarationParser.parseDeclaration(ast);\n    let result;\n    // console.log(util.inspect(src, false, null, true));\n    if (src instanceof Claim) {\n      result = addClaimToContext(ctx, src.name, src.location, src.type);\n      if (result instanceof go) {\n        ctx = result.result;\n      } else {\n        throw new Error(\"\" + result.where + result.message);\n      }\n    } else if (src instanceof Definition) {\n      result = addDefineToContext(ctx, src.name, src.location, src.expr);\n      if (result instanceof go) {\n        ctx = result.result;\n      } else {\n        throw new Error(\"\" + result.where + result.message);\n      }\n    } else if (src instanceof SamenessCheck) {\n      result = checkSame(ctx, src.location, src.type, src.left, src.right);\n      if (result instanceof go) {\n        ctx = result.result;\n      } else {\n        throw new Error(\"\" + result.where + result.message);\n      }\n    } else {\n      result = normType(ctx, src);\n      if (result instanceof go) {\n        output += prettyPrint(result.result);\n      } else {\n        throw new Error(\"\" + result.where + result.message);\n      }\n    }\n    return output;\n  } \n// import { BasicEvaluator } from \"../../conductor/src/conductor/runner\";\n// import { IRunnerPlugin } from \"../../conductor/src/conductor/runner/types\";\n// import { Parser } from \"./parser/parser\";\n// import { represent } from \"./typechecker/represent\";\n// import { go } from \"./types/utils\";\n// import { initCtx } from \"./utils/context\";\n// import * as C from './types/core';\n\n// export function parsePie(src: string) {\n//   return Parser.parsePie(src);\n// }\n\n// export class PieEvaluator extends BasicEvaluator {\n\n//   constructor(conductor: IRunnerPlugin) {\n//     super(conductor);\n//   }\n\n//   async evaluateChunk(chunk: string): Promise<void> {\n//     try {\n//       const src = parsePie(chunk);\n//       const res = (represent(initCtx, src) as go<C.Core>).result.prettyPrint();\n//       this.conductor.sendOutput(`FUCK ${res}`);\n//     } catch (error) {\n//       // Handle errors and send them to the REPL\n//       if (error instanceof Error) {\n//         this.conductor.sendOutput(`Error: ${error.message}`);\n//       } else {\n//         this.conductor.sendOutput(`Error: ${String(error)}`);\n//       }\n//     }\n//   }\n}","import * as C from \"../types/core\";\n\n/**\n * Pretty print the Normalized Expression tree to a string.\n */\nexport function prettyPrint(expr: C.Core): string {\n  return expr.prettyPrint();\n}"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","f","y","t","_","label","sent","trys","ops","g","Iterator","verb","Symbol","iterator","n","v","op","pop","length","push","__spreadArray","to","from","pack","arguments","ar","i","l","slice","concat","SuppressedError","ConductorError","_super","message","_this","name","errorType","Error","ConductorInternalError","EvaluatorTypeError","expected","actual","line","column","fileName","rawMessage","EvaluatorError","location","undefined","BasicEvaluator","conductor","startEvaluator","entryPoint","requestFile","initialChunk","_a","evaluateFile","requestChunk","chunk","evaluateChunk","fileContent","importExternalPlugin","import","plugin","importExternalModule","InvalidModuleError","DataType","Channel","port","__subscribers","Set","__isAlive","__waitingMessages","replacePort","send","transfer","__verifyAlive","__port","postMessage","subscribe","subscriber","add","_i","unsubscribe","delete","close","__dispatch","data","listenToPort","addEventListener","start","Queue","__s1","__s2","item","temp","reverse","defineProperty","get","clone","newQueue","MessageQueue","__inputQueue","__promiseQueue","bind","_reject","tryPop","ChannelQueue","channel","__messageQueue","__channel","receive","tryReceive","Conduit","link","parent","__alive","__channels","Map","__pluginMap","__plugins","__link","__handlePort","__parent","__negotiateChannel","channelName","MessageChannel","port1","port2","set","registerPlugin","pluginClass","arg","attachedChannels","_b","channelAttach","has","unregisterPlugin","destroy","lookupPlugin","pluginName","terminate","_d","_c","RpcCallMessage","fn","args","invokeId","type","RpcErrorMessage","err","RpcReturnMessage","res","checkIsPluginClass","_pluginClass","prefix","NumberType","AbortServiceMessage","minVersion","HelloServiceMessage","version","PluginServiceMessage","RunnerPlugin","RunnerPlugin_1","conduit","evaluatorClass","fileChannel","chunkChannel","serviceChannel","ioChannel","errorChannel","statusChannel","__serviceHandlers","__serviceChannel","console","error","log","__conduit","__evaluator","__fileRpc","self","waiting","invocations","rpcMessage","_j","err_1","_f","_e","_h","_g","Proxy","target","receiver","cb","Reflect","newCallback","charAt","makeRpc","__chunkQueue","__ioQueue","__errorChannel","__statusChannel","__isCompatibleWithModules","hasDataInterface","requestInput","tryRequestInput","out","sendOutput","sendError","updateStatus","status","isActive","hostLoadPlugin","registerModule","moduleClass","unregisterModule","module","importAndRegisterExternalPlugin","importAndRegisterExternalModule","description","configurable","ctor","descriptorIn","decorators","contextIn","initializers","extraInitializers","accept","kind","key","descriptor","getOwnPropertyDescriptor","context","access","addInitializer","init","unshift","__esDecorate","_classDescriptor","_classThis","_classDecorators","metadata","_metadata","_classExtraInitializers","useValue","__runInitializers","Match","IntegerMatch","isSigned","build","SchemeInteger","RationalMatch","numerator","denominator","SchemeRational","RealMatch","integer","decimal","exponent","includes","SchemeReal","NEG_INFINITY","INFINITY","NAN","INEXACT_ZERO","coerce","Number","Math","pow","ComplexMatch","real","sign","imaginary","EXACT_ZERO","SchemeComplex","negate","isInteger","match","RegExp","exec","universalMatch","finalWillingType","integerMatch","INTEGER","rationalMatch","parts","split","numeratorMatch","denominatorMatch","isRational","RATIONAL","realMatch","checkBasicReal","isSpecialNumber","count","integerPart","decimalPart","decimalMatch","properInteger","properDecimal","first_e_index","indexOf","first_E_index","exponentIndex","basicRealPart","substring","exponentPart","basicRealMatch","exponentMatch","REAL","checkExtendedReal","isReal","complexMatch","splitPoint","search","imaginaryMatch_1","realPart","imaginaryPart","imaginaryMatch","isComplex","COMPLEX","numberType","_force","val","BigInt","promote","nType","equals","other","greaterThan","multiplicativeInverse","multiply","getBigInt","MAX_SAFE_INTEGER","Infinity","MIN_SAFE_INTEGER","toString","force","simplify","gcd","a","valueOf","divisor","numeratorSign","denominatorSign","getNumerator","getDenominator","newNumerator","newDenominator","workingNumerator","converterDenominator","wholePart","MAX_VALUE","remainder","remainderPart","isNaN","INEXACT_NEG_ZERO","NaN","complex","atomic_equals","atomic_greater_than","atomic_add","atomic_multiply","atomic_negate","getReal","getImaginary","toPolar","magnitude","sqrt","angle","atan2","SchemePolar","toCartesian","cos","sin","equalify","newA","newB","PI","E","SQRT2","LN2","LN10","LOG2E","LOG10E","SQRT1_2","TokenType","Location","end","merge","Position","extractLine","source","pos","showPoint","padStart","ParserError","loc","SyntaxError","GenericSyntaxError","ParenthesisMismatchError","UnexpectedEOFError","UnexpectedFormError","form","ExpectedFormError","MissingFormError","DisallowedTokenError","token","chapter","UnsupportedTokenError","Group","elements","firstPos","lastPos","onlyElement","isGroup","IDENTIFIER","NUMBER","STRING","BOOLEAN","firstElement_1","isToken","APOSTROPHE","BACKTICK","HASH_VECTOR","COMMA","COMMA_AT","isShortAffector","lParen","rParen","firstElement","lastElement","LEFT_PAREN","RIGHT_PAREN","LEFT_BRACKET","RIGHT_BRACKET","wrongGroup","first","firstToken","last","lastToken","isParenthesized","isSingleIdentifier","unwrap","map","join","datum","Token","Atomic","Extended","lexeme","literal","col","endPos","convertToken","QUOTE","QUASIQUOTE","VECTOR","UNQUOTE","UNQUOTE_SPLICING","LexerError","UnexpectedCharacterError","char","keywords","DOT","IF","LET","COND","ELSE","SET","BEGIN","DELAY","EXPORT","IMPORT","DEFINE","LAMBDA","DEFINE_SYNTAX","SYNTAX_RULES","SchemeLexer","current","tokens","isAtEnd","advance","jump","addToken","text","scanTokens","scanToken","EOF","c","booleanToken","comment","HASH_SEMICOLON","peek","LexerError.UnexpectedCharacterError","stringToken","identifierTokenLoose","isDigit","identifierNumberToken","isValidIdentifier","identifierToken","peekNext","LexerError.UnexpectedEOFError","checkKeyword","peekPrev","isSpecialSyntax","isWhitespace","Sequence","expressions","visitor","visitSequence","NumericLiteral","visitNumericLiteral","BooleanLiteral","visitBooleanLiteral","StringLiteral","visitStringLiteral","Lambda","params","rest","visitLambda","Identifier","visitIdentifier","Definition","visitDefinition","Application","operator","operands","visitApplication","Conditional","test","consequent","alternate","visitConditional","Pair","car","cdr","visitPair","Nil","visitNil","visitSymbol","SpliceMarker","visitSpliceMarker","Reassignment","visitReassignment","Import","identifiers","visitImport","Export","definition","visitExport","Vector","visitVector","DefineSyntax","transformer","visitDefineSyntax","SyntaxRules","literals","rules","visitSyntaxRules","FunctionDefinition","visitFunctionDefinition","Let","values","visitLet","Cond","predicates","consequents","catchall","visitCond","List","terminator","visitList","Begin","visitBegin","Delay","expression","visitDelay","QuoteMode","SchemeParser","quoteMode","NONE","previous","validateChapter","ParserError.DisallowedTokenError","toLocation","destructureList","list","verifier","_x","parseExpression","potentialDot","at","cdrElement","listElements_1","forEach","listElements","grouping","openparen","inList","innerGroup","ParserError.UnexpectedFormError","nextGrouping","affect","ParserError.UnexpectedEOFError","ParserError.ExpectedFormError","affector","expr","parseToken","parseGroup","group","parseAffectorGroup","parseNormalGroup","parseQuotedGroup","newLocation_1","newSymbol","quotedExpression","newLocation_2","quasiquotedExpression","preUnquoteMode","ParserError.UnsupportedTokenError","newLocation_3","unquotedExpression","preUnquoteSplicingMode","newLocation_4","unquoteSplicedExpression","newLocation","preVectorQuoteMode","vector","parseVector","parseLambda","parseDefinition","parseConditional","parseLet","parseExtendedCond","parseBegin","parseDelay","parseSet","parseDefineSyntax","parseImport","parseExport","parseApplication","elem","groupElements","formals","convertedFormals","convertedRest","formalsElements","formal","convertedBody","bodySequence","convertedIdentifier","identifier","isFunctionDefinition","identifierElements","functionName","splice","convertedExpr","convertedTest","convertedConsequent","convertedAlternate","convertedOperator","convertedOperands","operands_1","operand","bindings","convertedIdentifiers","convertedValues","bindingElements_1","bindingElement","clauses","lastClause","convertedClauses","convertedConsequents","clauses_1","clause","test_1","consequent_1","consequentExpressions_1","consequentLocation_1","isElse","consequentExpressions","consequentLocation","lastConsequent","lastTest","convertedExpressions","sequenceElements_1","sequenceElement","transformerToken","convertedTransformer","parseSyntaxRules","isValidPattern","pattern","ellipsisIndex","filter","findIndex","element","isValidTemplate","template","ellipsisWorksOnLastElement","finalLiterals","convertedLiteral","finalRules","rules_1","rule","convertedPattern","convertedTemplate","identifierElements_1","identifierElement","convertedSource","convertedDefinition","convertedElements","parse","reparseAsSexpr","topElements","currentElement","convertedElement","importElements","restElements","SourceLocation","startLine","startColumn","endLine","endColumn","Syntax","syntax","forInfo","locationToSrcLoc","notForInfo","subscriptReplacements","nonSubscripts","freshen","used","x","some","usedName","splitNameAux","base","num","splitName","freshenAux","subscriptStr","joined","digit","numberToSubscriptString","sym","nextSplitName","subscriptToNumber","str","replaced","parseInt","keys","SiteBinder","varName","TypedBinder","binder","Message","Perhaps","go","stop","where","PerhapsM","goOn","finalExpr","bindings_1","meta","lazy","Closure","FirstOrderClosure","env","valOfClosure","valOf","extendEnvironment","prettyPrint","HigherOrderClosure","proc","isVarName","namesInContext","ctx","fresh","freshBinder","src","findNames","occurringBinderNames","Norm","Neutral","Variable","readBackNeutral","C.VarName","TODO","C.TODO","readBackType","WhichNat","C.WhichNat","C.The","readBack","IterNat","C.IterNat","RecNat","C.RecNat","IndNat","motive","C.IndNat","Car","C.Car","Cdr","C.Cdr","RecList","C.RecList","IndList","C.IndList","IndAbsurd","C.IndAbsurd","C.Absurd","Replace","C.Replace","Trans1","target1","target2","C.Trans","Trans2","Trans12","Cong","func","funcType","Pi","closure","resultType","C.Cong","Absurd","Symm","C.Symm","IndEqual","C.IndEqual","Head","C.Head","Tail","C.Tail","IndVec1","C.IndVec","IndVec2","IndVec12","IndEither","baseLeft","baseRight","C.IndEither","C.Application","doApp","operatorNow","now","V.Lambda","V.Neutral","typeNow","V.Pi","N.Application","neutral","N.Norm","argType","util","inspect","doIterNat","baseType","targetNow","V.Zero","V.Add1","smaller","V.Nat","N.IterNat","doRecNat","N.RecNat","doIndNat","N.IndNat","V.Universe","n_minus_1","doCar","pair","pairNow","V.Cons","pairType","V.Sigma","sigma","carType","N.Car","doCdr","cdrType","N.Cdr","doIndList","V.Nil","V.ListCons","head","tail","V.List","entryType_1","entryType","motiveType","N.IndList","h","doRecList","entryType_2","N.RecList","doTail","V.VecCons","V.Vec","N.Tail","indVecStepType","Ev","mot","k","es","doIndVec","len","vec","lenNow","vecNow","V.VecNil","entryType_3","N.IndVec12","natEqual","entryType_4","N.IndVec2","nat1","nat2","nat1Now","nat2Now","valueNow","C.Zero","C.Add1","freshx","argName","C.Lambda","bindFree","N.Variable","C.Cons","V.Atom","V.Quote","C.Quote","V.Trivial","C.Sole","C.Nil","V.Absurd","V.Equal","V.Same","C.Same","C.VecNil","C.VecCons","V.Either","V.Left","C.Left","leftType","V.Right","C.Right","rightType","extendContext","valInContext","contextToEnvironment","readBackContext","ctx_1","Free","Define","Claim","addClaimToContext","fun","funLoc","typeOut","nameNotUsed","isType","addDefineToContext","exprOut","ctx_2","getClaim","check","bindVal","removeClaimFromContext","size","entries","name_1","initCtx","Binder","varType","tv","ctx_3","JSON","stringify","Value","DelayClosure","undelay","Box","content","boxContent","theValue","Quote","Nat","C.Nat","Zero","Add1","Aexpr","freshedName","excludeNameCtx","C.Pi","Sigma","carName","C.Sigma","Cons","C.List","ListCons","Equal","C.Equal","Same","Vec","C.Vec","VecNil","VecCons","Either","C.Either","Left","Right","Universe","C.Universe","Atom","C.Atom","Trivial","C.Trivial","Sole","Core","toLazy","V.Delay","V.Box","V.DelayClosure","The","VarName","getValueFromEnvironment","N.WhichNat","Evaluator.doWhichNat","Evaluator.doIterNat","Evaluator.doRecNat","Evaluator.doIndNat","typeVal","param","second","Evaluator.doCar","Evaluator.doCdr","elemType","Evaluator.doRecList","Evaluator.doIndList","V.Sole","N.IndAbsurd","Evaluator.doIndAbsurd","left","right","eqType","N.Replace","Evaluator.doReplace","Trans","target1Now","target2Now","type2Now","neutral2","N.Trans2","type1Now","neutral1","N.Trans1","N.Trans12","Evaluator.doTrans","N.Cong","Evaluator.doCong","equality","N.Symm","Evaluator.doSymm","eqType_1","from_1","N.IndEqual","Evaluator.doIndEqual","N.Head","Evaluator.doHead","Evaluator.doTail","IndVec","Evaluator.doIndVec","N.IndEither","Evaluator.doIndEither","N.TODO","Evaluator.doApp","alphaEquiv","e1","e2","alphaEquivAux","FV","lvl","findBinding","b1","b2","n1","n2","xBinding","yBinding","C.ListCons","sameLocation","SendPieInfo","what","rename","renames","extendRenaming","sameType","given","givenE","expectedE","convert","atomOk","allOkAtom","cs","makeApp","synthesizer","synthNat","r","synthUniverse","synthArrow","arg1","arg2","z_1","Aout_1","Bout_1","first_1","rest_1","z_2","Aout_2","tout_1","S.Arrow","synthPi","binders","binder_1","type_1","xhat_1","Aout_3","Bout_2","fst","rest_2","type_2","x_1","xhat_2","Aout_4","Bout_3","S.Pi","synthZero","synthAdd1","nout","synthWhichNat","tgtout","bout","sout","synth","synthIterNat","old","synthRecNat","synthIndNat","motout","motval","synthAtom","synthPair","Aout","Dout","synthSigma","bd_1","type_3","xhat_3","Aout_5","Dout_1","rest_3","type_4","x_2","xhat_4","Aout_6","Dout_2","S.Sigma","synthCar","pout","synthCdr","synthQuote","atom","synthTrivial","synthSole","synthIndList","tgt_e","E_1","synthRecList","E_2","bout_1","btval_1","sout_1","synthList","Eout","synthListCons","xs","fstout","restout","synthAbsurd","synthIndAbsurd","synthEqual","Av","from_out","to_out","synthReplace","Av_1","fromv_1","tov_1","synthTrans","lout","rout","result1","result2","Av_2","fromv_2","midv_1","Bv_1","midv2_1","tov_2","synthCong","fout","Av_3","fromv_3","tov_3","Bv_2","c_1","ph","Cv_1","fv_1","synthSymm","eq","eout","synthIndEqual","motv","baseout","Av_4","fromv_4","tov_4","synthVec","tout","lenout","synthHead","vout","synthTail","T","len_minus_1","synthIndVec","lenv","vecout","E_3","len2v_1","synthEither","Lout","Rout","synthIndEither","Lv_1","Rv_1","synthThe","synthApplication","fout_1","A_1","c_2","argout_1","appout_1","S.Application","A_2","c_3","argout_2","synthName","real_x","x_tv","synthNumber","n_minus_1_out_1","S.Number","Source","ok","theType","getType","checkType","Name","otherTv_1","checkOut","synthHelper","theT","Synth","Arrow","flatMap","A","B","rest0_1","y_1","Aoutv_1","bd_2","Aoutv_2","body_1","x_3","xLoc_1","A_3","closure_1","xRenamed_1","S.Lambda","D","A_4","x_4","bd","y_2","Aoutv_3","A_5","x_5","Aoutv_4","A_6","closure_2","aout_1","dout_1","A_7","to_1","cout_1","val_1","hout_1","tout_2","n_minus_1_1","lout_1","rout_1","syntaxToLocation","syntaxToSiteBinder","getValue","locationToSyntax","elementToSyntax","schemeParse","stx","lexer","Parser","parsePie","parseElements","parsee","S.Universe","S.The","makeThe","S.Nat","makeNat","S.Zero","makeZero","S.Add1","makeAdd1","makeArrow","makeLambda","x0","firstPair","A0","processedPairs","makePi","makeTypedBinders","makeSigma","S.Pair","makePair","S.Cons","makeCons","S.Car","makeCar","S.Cdr","makeCdr","S.WhichNat","makeWhichNat","S.IterNat","makeIterNat","S.RecNat","makeRecNat","S.IndNat","makeIndNat","S.Atom","makeAtom","quoted","S.Quote","makeQuote","S.Trivial","makeTrivial","S.Sole","makeSole","S.List","makeList","S.Nil","makeNil","S.ListCons","makeListCons","S.RecList","makeRecList","S.IndList","makeIndList","S.Equal","makeEqual","S.Same","makeSame","S.Replace","makeReplace","S.Trans","makeTrans","S.Cong","makeCong","S.IndEqual","makeIndEqual","S.Symm","makeSymm","S.Vec","makeVec","S.VecNil","makeVecNil","S.VecCons","makeVecCons","S.Head","makeHead","S.Tail","makeTail","S.IndVec","makeIndVec","S.Either","makeEither","S.Left","makeLeft","S.Right","makeRight","S.IndEither","makeIndEither","S.Absurd","makeAbsurd","S.IndAbsurd","makeIndAbsurd","S.TODO","makeTODO","arg0","ref","S.Name","makeVarRef","makeNatLiteral","SamenessCheck","pieDeclarationParser","parseDeclaration","ast","normType","checkSame","typeValue","leftOut","rightOut","leftValue","rightValue","initialise","PieEvaluator","executionCount","rep","astList","output","astList_1","evaluatePie"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,21,22,23,24,52]}