import * as C from "../types/core";
import * as S from "../types/source";
import { Perhaps, TypedBinder } from '../types/utils';
import { Context } from '../utils/context';
import { Renaming } from "./utils";
import { Location } from '../utils/locations';
export declare class synthesizer {
    static synthNat(ctx: Context, r: Renaming): Perhaps<C.The>;
    static synthUniverse(ctx: Context, r: Renaming, location: Location): Perhaps<C.The>;
    static synthArrow(context: Context, r: Renaming, location: Location, arg1: S.Source, arg2: S.Source, args: S.Source[]): Perhaps<C.The>;
    static synthPi(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The>;
    static synthZero(context: Context, r: Renaming): Perhaps<C.The>;
    static synthAdd1(context: Context, r: Renaming, base: S.Source): Perhaps<C.The>;
    static synthWhichNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthIterNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthRecNat(context: Context, r: Renaming, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthIndNat(context: Context, r: Renaming, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthAtom(context: Context, r: Renaming): Perhaps<C.The>;
    static synthPair(context: Context, r: Renaming, first: S.Source, second: S.Source): Perhaps<C.The>;
    static synthSigma(context: Context, r: Renaming, location: Location, binders: TypedBinder[], body: S.Source): Perhaps<C.The>;
    static synthCar(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The>;
    static synthCdr(context: Context, r: Renaming, location: Location, pair: S.Source): Perhaps<C.The>;
    static synthQuote(context: Context, r: Renaming, location: Location, atom: string): Perhaps<C.The>;
    static synthTrivial(context: Context, r: Renaming): Perhaps<C.The>;
    static synthSole(context: Context, r: Renaming): Perhaps<C.The>;
    static synthIndList(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthRecList(context: Context, r: Renaming, location: Location, target: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthList(context: Context, r: Renaming, e: S.List): Perhaps<C.The>;
    static synthListCons(context: Context, r: Renaming, x: S.Source, xs: S.Source): Perhaps<C.The>;
    static synthAbsurd(context: Context, r: Renaming, e: S.Absurd): Perhaps<C.The>;
    static synthIndAbsurd(context: Context, r: Renaming, e: S.IndAbsurd): Perhaps<C.The>;
    static synthEqual(context: Context, r: Renaming, type: S.Source, left: S.Source, right: S.Source): Perhaps<C.The>;
    static synthReplace(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The>;
    static synthTrans(context: Context, r: Renaming, location: Location, left: S.Source, right: S.Source): Perhaps<C.The>;
    static synthCong(context: Context, r: Renaming, location: Location, base: S.Source, fun: S.Source): Perhaps<C.The>;
    static synthSymm(context: Context, r: Renaming, location: Location, eq: S.Source): Perhaps<C.The>;
    static synthIndEqual(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, base: S.Source): Perhaps<C.The>;
    static synthVec(context: Context, r: Renaming, type: S.Source, len: S.Source): Perhaps<C.The>;
    static synthHead(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The>;
    static synthTail(context: Context, r: Renaming, location: Location, vec: S.Source): Perhaps<C.The>;
    static synthIndVec(context: Context, r: Renaming, location: Location, length: S.Source, target: S.Source, motive: S.Source, base: S.Source, step: S.Source): Perhaps<C.The>;
    static synthEither(context: Context, r: Renaming, left: S.Source, right: S.Source): Perhaps<C.The>;
    static synthIndEither(context: Context, r: Renaming, location: Location, target: S.Source, motive: S.Source, baseLeft: S.Source, baseRight: S.Source): Perhaps<C.The>;
    static synthThe(context: Context, r: Renaming, type: S.Source, value: S.Source): Perhaps<C.The>;
    static synthApplication(context: Context, r: Renaming, location: Location, fun: S.Source, arg: S.Source, args: S.Source[]): Perhaps<C.The>;
    static synthName(context: Context, r: Renaming, location: Location, name: string): Perhaps<C.The>;
    static synthNumber(context: Context, r: Renaming, location: Location, value: number): Perhaps<C.The>;
    static synthDefineDatatype(ctx: Context, renames: Renaming, datatype: S.DefineDatatype): Perhaps<C.The>;
}
//# sourceMappingURL=synthesizer.d.ts.map