import { Syntax } from "../utils/locations";
import * as S from "../types/source";
import { SiteBinder, TypedBinder } from "../types/utils";
import { Tactic, SpiltTactic } from "../tactics/tactics";
export declare function makeU(stx: Syntax): S.Source;
export declare function makeArrow(stx: Syntax, args: [S.Source, S.Source, S.Source[]]): S.Source;
export declare function makeNat(stx: Syntax): S.Source;
export declare function makeZero(stx: Syntax): S.Source;
export declare function makeAdd1(stx: Syntax, n: S.Source): S.Source;
export declare function makeLambda(stx: Syntax, binders: SiteBinder[], body: S.Source): S.Source;
export declare function makePi(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source;
export declare function makeSigma(stx: Syntax, binders: TypedBinder[], body: S.Source): S.Source;
export declare function makeTypedBinders(head: TypedBinder, tail: TypedBinder[]): TypedBinder[];
export declare function makeApp(stx: Syntax, func: S.Source, arg0: S.Source, args: S.Source[]): S.Source;
export declare function makeAtom(stx: Syntax): S.Source;
export declare function makeTrivial(stx: Syntax): S.Source;
export declare function makeSole(stx: Syntax): S.Source;
export declare function makeList(stx: Syntax, type: S.Source): S.Source;
export declare function makeVec(stx: Syntax, type: S.Source, len: S.Source): S.Source;
export declare function makeEither(stx: Syntax, left: S.Source, right: S.Source): S.Source;
export declare function makeNil(stx: Syntax): S.Source;
export declare function makeVecCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source;
export declare function makeVecNil(stx: Syntax): S.Source;
export declare function makeAbsurd(stx: Syntax): S.Source;
export declare function makePair(stx: Syntax, head: S.Source, tail: S.Source): S.Source;
export declare function makeCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source;
export declare function makeListCons(stx: Syntax, head: S.Source, tail: S.Source): S.Source;
export declare function makeThe(stx: Syntax, type: S.Source, value: S.Source): S.Source;
export declare function makeIndAbsurd(stx: Syntax, head: S.Source, tail: S.Source): S.Source;
export declare function makeTrans(stx: Syntax, from: S.Source, to: S.Source): S.Source;
export declare function makeCong(stx: Syntax, from: S.Source, to: S.Source): S.Source;
export declare function makeIndEqual(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source;
export declare function makeWhichNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeIterNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeRecNat(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeIndNat(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeRecList(stx: Syntax, target: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeIndList(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeIndEither(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeIndVec(stx: Syntax, length: S.Source, target: S.Source, mot: S.Source, base: S.Source, step: S.Source): S.Source;
export declare function makeEqual(stx: Syntax, type: S.Source, left: S.Source, right: S.Source): S.Source;
export declare function makeReplace(stx: Syntax, target: S.Source, mot: S.Source, base: S.Source): S.Source;
export declare function makeSymm(stx: Syntax, equality: S.Source): S.Source;
export declare function makeHead(stx: Syntax, vec: S.Source): S.Source;
export declare function makeTail(stx: Syntax, vec: S.Source): S.Source;
export declare function makeSame(stx: Syntax, type: S.Source): S.Source;
export declare function makeLeft(stx: Syntax, value: S.Source): S.Source;
export declare function makeRight(stx: Syntax, value: S.Source): S.Source;
export declare function makeCar(stx: Syntax, pair: S.Source): S.Source;
export declare function makeCdr(stx: Syntax, pair: S.Source): S.Source;
export declare function makeQuote(stx: Syntax, quoted: string): S.Source;
export declare function makeVarRef(stx: Syntax, ref: string): S.Source;
export declare function makeNatLiteral(stx: Syntax, num: string): S.Source;
export declare function makeTODO(stx: Syntax): S.Source;
export declare function makeIntro(stx: Syntax, name?: string): Tactic;
export declare function makeExact(stx: Syntax, expr: S.Source): Tactic;
export declare function makeExists(stx: Syntax, value: S.Source, name?: string): Tactic;
export declare function makeElimNat(stx: Syntax, target: string, motive: S.Source): Tactic;
export declare function makeElimList(stx: Syntax, target: string, motive: S.Source): Tactic;
export declare function makeElimVec(stx: Syntax, target: string, motive: S.Source, length: S.Source): Tactic;
export declare function makeElimEqual(stx: Syntax, target: string, motive: S.Source): Tactic;
export declare function makeLeftTactic(stx: Syntax): Tactic;
export declare function makeRightTactic(stx: Syntax): Tactic;
export declare function makeElimEither(stx: Syntax, target: string, motive: S.Source): Tactic;
export declare function makeSplit(stx: Syntax): SpiltTactic;
export declare function makeElimAbsurd(stx: Syntax, target: string, motive: S.Source): Tactic;
//# sourceMappingURL=makers.d.ts.map