{
  "version": 3,
  "sources": ["../../node_modules/@blueprintjs/select/src/common/classes.ts", "../../node_modules/@blueprintjs/select/src/common/itemListRenderer.ts", "../../node_modules/@blueprintjs/select/src/common/listItemsProps.ts", "../../node_modules/@blueprintjs/select/src/common/listItemsUtils.ts", "../../node_modules/@blueprintjs/select/src/components/multi-select/multiSelect.tsx", "../../node_modules/@blueprintjs/select/src/components/query-list/queryList.tsx", "../../node_modules/@blueprintjs/select/src/components/omnibar/omnibar.tsx", "../../node_modules/@blueprintjs/select/src/components/select/select.tsx", "../../node_modules/@blueprintjs/select/src/components/suggest/suggest.tsx"],
  "sourcesContent": ["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Classes } from \"@blueprintjs/core\";\n\nconst NS = Classes.getClassNamespace();\n\nexport const MULTISELECT = `${NS}-multi-select`;\nexport const MULTISELECT_POPOVER = `${MULTISELECT}-popover`;\nexport const MULTISELECT_POPOVER_DEFAULT_WIDTH = `${MULTISELECT}-popover-default-width`;\nexport const MULTISELECT_POPOVER_TAG_INPUT_MARGIN = `${MULTISELECT}-popover-tag-input-margin`;\nexport const MULTISELECT_TAG_INPUT_INPUT = `${MULTISELECT}-tag-input-input`;\nexport const OMNIBAR = `${NS}-omnibar`;\nexport const OMNIBAR_OVERLAY = `${OMNIBAR}-overlay`;\nexport const SELECT_POPOVER = `${NS}-select-popover`;\nexport const SUGGEST_POPOVER = `${NS}-suggest-popover`;\n", "/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { CreateNewItem } from \"./listItemsUtils\";\n\n/**\n * An object describing how to render the list of items.\n * An `itemListRenderer` receives this object as its sole argument.\n */\nexport interface ItemListRendererProps<T> {\n    /**\n     * The currently focused item (for keyboard interactions), or `null` to\n     * indicate that no item is active.\n     */\n    activeItem: T | CreateNewItem | null;\n\n    /**\n     * Array of items filtered by `itemListPredicate` or `itemPredicate`.\n     * See `items` for the full list of items.\n     *\n     * Use `renderFilteredItems()` utility function from this library to\n     * map each item in this array through `renderItem`, with support for\n     * optional `noResults` and `initialContent` states.\n     */\n    filteredItems: T[];\n\n    /**\n     * Array of all items in the list.\n     * See `filteredItems` for a filtered array based on `query` and predicate props.\n     */\n    items: T[];\n\n    /**\n     * The current query string.\n     */\n    query: string;\n\n    /**\n     * A ref handler that should be attached to the parent HTML element of the menu items.\n     * This is required for the active item to scroll into view automatically.\n     */\n    itemsParentRef: React.Ref<HTMLUListElement>;\n\n    /**\n     * Props to apply to the `Menu` created within the `itemListRenderer`\n     */\n    menuProps?: React.HTMLAttributes<HTMLUListElement>;\n\n    /**\n     * Call this function to render an item.\n     * This retrieves the modifiers for the item and delegates actual rendering\n     * to the owner component's `itemRenderer` prop.\n     */\n    renderItem: (item: T, index: number) => React.JSX.Element | null;\n\n    /**\n     * Call this function to render the \"create new item\" view component.\n     *\n     * @returns null when creating a new item is not available, and undefined if the createNewItemRenderer returns undefined\n     */\n    renderCreateItem: () => React.JSX.Element | null | undefined;\n}\n\n/** Type alias for a function that renders the list of items. */\nexport type ItemListRenderer<T> = (itemListProps: ItemListRendererProps<T>) => React.JSX.Element | null;\n\n/**\n * `ItemListRenderer` helper method for rendering each item in `filteredItems`,\n * with optional support for `noResults` (when filtered items is empty)\n * and `initialContent` (when query is empty).\n */\nexport function renderFilteredItems(\n    props: ItemListRendererProps<any>,\n    noResults?: React.ReactNode,\n    initialContent?: React.ReactNode | null,\n): React.ReactNode {\n    if (props.query.length === 0 && initialContent !== undefined) {\n        return initialContent;\n    }\n    const items = props.filteredItems.map(props.renderItem).filter(item => item != null);\n    return items.length > 0 ? items : noResults;\n}\n", "/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { type Props, Utils } from \"@blueprintjs/core\";\n\nimport type { ItemListRenderer } from \"./itemListRenderer\";\nimport type { ItemRenderer } from \"./itemRenderer\";\nimport type { CreateNewItem } from \"./listItemsUtils\";\nimport type { ItemListPredicate, ItemPredicate } from \"./predicate\";\n\n/**\n * Equality test comparator to determine if two {@link ListItemsProps} items are equivalent.\n *\n * @return `true` if the two items are equivalent.\n */\nexport type ItemsEqualComparator<T> = (itemA: T, itemB: T) => boolean;\n\n/**\n * Union of all possible types for {@link ListItemsProps#itemsEqual}.\n */\nexport type ItemsEqualProp<T> = ItemsEqualComparator<T> | keyof T;\n\n/** Reusable generic props for a component that operates on a filterable, selectable list of `items`. */\nexport interface ListItemsProps<T> extends Props {\n    /**\n     * The currently focused item for keyboard interactions, or `null` to\n     * indicate that no item is active. If omitted or `undefined`, this prop will be\n     * uncontrolled (managed by the component's state). Use `onActiveItemChange`\n     * to listen for updates.\n     */\n    activeItem?: T | CreateNewItem | null;\n\n    /** Array of items in the list. */\n    items: T[];\n\n    /**\n     * Specifies how to test if two items are equal. By default, simple strict\n     * equality (`===`) is used to compare two items.\n     *\n     * If your items have a unique identifier field, simply provide the name of\n     * a property on the item that can be compared with strict equality to\n     * determine equivalence: `itemsEqual=\"id\"` will check `a.id === b.id`.\n     *\n     * If more complex comparison logic is required, provide an equality\n     * comparator function that returns `true` if the two items are equal. The\n     * arguments to this function will never be `null` or `undefined`, as those\n     * values are handled before calling the function.\n     */\n    itemsEqual?: ItemsEqualProp<T>;\n\n    /**\n     * Determine if the given item is disabled. Provide a callback function, or\n     * simply provide the name of a boolean property on the item that exposes\n     * its disabled state.\n     */\n    itemDisabled?: keyof T | ((item: T, index: number) => boolean);\n\n    /**\n     * Customize querying of entire `items` array. Return new list of items.\n     * This method can reorder, add, or remove items at will.\n     * (Supports filter algorithms that operate on the entire set, rather than individual items.)\n     *\n     * If `itemPredicate` is also defined, this prop takes priority and the other will be ignored.\n     */\n    itemListPredicate?: ItemListPredicate<T>;\n\n    /**\n     * Customize querying of individual items.\n     *\n     * __Filtering a list of items.__ This function is invoked to filter the\n     * list of items as a query is typed. Return `true` to keep the item, or\n     * `false` to hide. This method is invoked once for each item, so it should\n     * be performant. For more complex queries, use `itemListPredicate` to\n     * operate once on the entire array. For the purposes of filtering the list,\n     * this prop is ignored if `itemListPredicate` is also defined.\n     *\n     * __Matching a pasted value to an item.__ This function is also invoked to\n     * match a pasted value to an existing item if possible. In this case, the\n     * function will receive `exactMatch=true`, and the function should return\n     * true only if the item _exactly_ matches the query. For the purposes of\n     * matching pasted values, this prop will be invoked even if\n     * `itemListPredicate` is defined.\n     */\n    itemPredicate?: ItemPredicate<T>;\n\n    /**\n     * Custom renderer for an item in the dropdown list. Receives a boolean indicating whether\n     * this item is active (selected by keyboard arrows) and an `onClick` event handler that\n     * should be attached to the returned element.\n     */\n    itemRenderer: ItemRenderer<T>;\n\n    /**\n     * Custom renderer for the contents of the dropdown.\n     *\n     * The default implementation invokes `itemRenderer` for each item that passes the predicate\n     * and wraps them all in a `Menu` element. If the query is empty then `initialContent` is returned,\n     * and if there are no items that match the predicate then `noResults` is returned.\n     */\n    itemListRenderer?: ItemListRenderer<T>;\n\n    /**\n     * React content to render when query is empty.\n     * If omitted, all items will be rendered (or result of `itemListPredicate` with empty query).\n     * If explicit `null`, nothing will be rendered when query is empty.\n     *\n     * This prop is ignored if a custom `itemListRenderer` is supplied.\n     */\n    initialContent?: React.ReactNode | null;\n\n    /**\n     * React content to render when filtering items returns zero results.\n     * If omitted, nothing will be rendered in this case.\n     *\n     * This prop is ignored if a custom `itemListRenderer` is supplied.\n     *\n     * NOTE: if passing a `MenuItem`, ensure it has `roleStructure=\"listoption\"` prop.\n     */\n    noResults?: React.ReactNode;\n\n    /**\n     * Invoked when user interaction should change the active item: arrow keys\n     * move it up/down in the list, selecting an item makes it active, and\n     * changing the query may reset it to the first item in the list if it no\n     * longer matches the filter.\n     *\n     * If the \"Create Item\" option is displayed and currently active, then\n     * `isCreateNewItem` will be `true` and `activeItem` will be `null`. In this\n     * case, you should provide a valid `CreateNewItem` object to the\n     * `activeItem` _prop_ in order for the \"Create Item\" option to appear as\n     * active.\n     *\n     * __Note:__ You can instantiate a `CreateNewItem` object using the\n     * `getCreateNewItem()` utility exported from this package.\n     */\n    onActiveItemChange?: (activeItem: T | null, isCreateNewItem: boolean) => void;\n\n    /**\n     * Callback invoked when an item from the list is selected,\n     * typically by clicking or pressing `enter` key.\n     */\n    onItemSelect: (item: T, event?: React.SyntheticEvent<HTMLElement>) => void;\n\n    /**\n     * Callback invoked when multiple items are selected at once via pasting.\n     */\n    onItemsPaste?: (items: T[]) => void;\n\n    /**\n     * Callback invoked when the query string changes.\n     */\n    onQueryChange?: (query: string, event?: React.ChangeEvent<HTMLInputElement>) => void;\n\n    /**\n     * If provided, allows new items to be created using the current query\n     * string. This is invoked when user interaction causes one or many items to be\n     * created, either by pressing the `Enter` key or by clicking on the \"Create\n     * Item\" option. It transforms a query string into one or many items type.\n     */\n    createNewItemFromQuery?: (query: string) => T | T[];\n\n    /**\n     * Custom renderer to transform the current query string into a selectable\n     * \"Create Item\" option. If this function is provided, a \"Create Item\"\n     * option will be rendered at the end of the list of items. If this function\n     * is not provided, a \"Create Item\" option will not be displayed.\n     */\n    createNewItemRenderer?: (\n        query: string,\n        active: boolean,\n        handleClick: React.MouseEventHandler<HTMLElement>,\n    ) => React.JSX.Element | undefined;\n\n    /**\n     * Determines the position of the `createNewItem` within the list: first or\n     * last. Only relevant when `createNewItemRenderer` is defined.\n     *\n     * @default 'last'\n     */\n    createNewItemPosition?: \"first\" | \"last\";\n\n    /**\n     * Whether the active item should be reset to the first matching item _every\n     * time the query changes_ (via prop or by user input).\n     *\n     * @default true\n     */\n    resetOnQuery?: boolean;\n\n    /**\n     * Whether the active item should be reset to the first matching item _when\n     * an item is selected_. The query will also be reset to the empty string.\n     *\n     * @default false\n     */\n    resetOnSelect?: boolean;\n\n    /**\n     * When `activeItem` is controlled, whether the active item should _always_\n     * be scrolled into view when the prop changes. If `false`, only changes\n     * that result from built-in interactions (clicking, querying, or using\n     * arrow keys) will scroll the active item into view. Ignored if the\n     * `activeItem` prop is omitted (uncontrolled behavior).\n     *\n     * @default true\n     */\n    scrollToActiveItem?: boolean;\n\n    /**\n     * Query string passed to `itemListPredicate` or `itemPredicate` to filter items.\n     * This value is controlled: its state must be managed externally by attaching an `onChange`\n     * handler to the relevant element in your `renderer` implementation.\n     */\n    query?: string;\n}\n\n/**\n * Utility function for executing the {@link ListItemsProps#itemsEqual} prop to test\n * for equality between two items.\n *\n * @return `true` if the two items are equivalent according to `itemsEqualProp`.\n */\nexport function executeItemsEqual<T>(\n    itemsEqualProp: ItemsEqualProp<T> | undefined,\n    itemA: T | null | undefined,\n    itemB: T | null | undefined,\n): boolean {\n    // Use strict equality if:\n    // A) Default equality check is necessary because itemsEqualProp is undefined.\n    // OR\n    // B) Either item is null/undefined. Note that null represents \"no item\", while\n    //    undefined represents an uncontrolled prop. This strict equality check ensures\n    //    nothing will ever be considered equivalent to an uncontrolled prop.\n    if (itemsEqualProp === undefined || itemA == null || itemB == null) {\n        return itemA === itemB;\n    }\n\n    if (Utils.isFunction(itemsEqualProp)) {\n        // itemsEqualProp is an equality comparator function, so use it\n        return itemsEqualProp(itemA, itemB);\n    } else {\n        // itemsEqualProp is a property name, so strictly compare the values of the property.\n        return itemA[itemsEqualProp] === itemB[itemsEqualProp];\n    }\n}\n", "/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-underscore-dangle */\n\n/**\n * The reserved type of the \"Create Item\" option in item lists. This is intended\n * not to conflict with any custom item type `T` that might be used in  item\n * list.\n */\nexport interface CreateNewItem {\n    __blueprintCreateNewItemBrand: \"blueprint-create-new-item\";\n}\n\n/** Returns an instance of a \"Create Item\" object. */\nexport function getCreateNewItem(): CreateNewItem {\n    return { __blueprintCreateNewItemBrand: \"blueprint-create-new-item\" };\n}\n\n/**\n * Type guard returning `true` if the provided item (e.g. the current\n * `activeItem`) is a \"Create Item\" option.\n */\nexport function isCreateNewItem<T>(item: T | CreateNewItem | null | undefined): item is CreateNewItem {\n    if (item == null) {\n        return false;\n    }\n\n    // see if the provided item exactly matches the `CreateNewItem` object,\n    // with no superfluous keys.\n    const keys = Object.keys(item);\n    if (keys.length !== 1 || keys[0] !== \"__blueprintCreateNewItemBrand\") {\n        return false;\n    }\n    return (item as CreateNewItem).__blueprintCreateNewItemBrand === \"blueprint-create-new-item\";\n}\n\n/**\n * Returns the type of the the current active item. This will be a no-op unless\n * the `activeItem` is `undefined` or a \"Create Item\" option, in which case\n * `null` will be returned instead.\n */\nexport function getActiveItem<T>(activeItem: T | CreateNewItem | null | undefined): T | null {\n    return activeItem == null || isCreateNewItem(activeItem) ? null : activeItem;\n}\n", "/*\n * Copyright 2022 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { createElement, createRef } from \"react\";\n\nimport {\n    AbstractPureComponent,\n    Button,\n    Classes as CoreClasses,\n    DISPLAYNAME_PREFIX,\n    type HTMLInputProps,\n    mergeRefs,\n    Popover,\n    type PopoverClickTargetHandlers,\n    type PopoverTargetProps,\n    PopupKind,\n    refHandler,\n    setRef,\n    TagInput,\n    type TagInputAddMethod,\n    type TagInputProps,\n    Utils,\n} from \"@blueprintjs/core\";\nimport { Cross } from \"@blueprintjs/icons\";\n\nimport { Classes, type ListItemsProps, type SelectPopoverProps } from \"../../common\";\nimport { QueryList, type QueryListRendererProps } from \"../query-list/queryList\";\n\nexport interface MultiSelectProps<T> extends ListItemsProps<T>, SelectPopoverProps {\n    /**\n     * Element which triggers the multiselect popover. Providing this prop will replace the default TagInput\n     * target thats rendered and move the search functionality to within the Popover.\n     */\n    customTarget?: (selectedItems: T[], isOpen: boolean) => React.ReactNode;\n\n    /**\n     * Whether the component is non-interactive.\n     * If true, the list's item renderer will not be called.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Whether the component should take up the full width of its container.\n     */\n    fill?: boolean;\n\n    /**\n     * Props to spread to the `Menu` listbox containing the selectable options.\n     */\n    menuProps?: React.HTMLAttributes<HTMLUListElement>;\n\n    /**\n     * If provided, this component will render a \"clear\" button inside its TagInput.\n     * Clicking that button will invoke this callback to clear all items from the current selection.\n     */\n    onClear?: () => void;\n\n    /**\n     * Callback invoked when an item is removed from the selection by\n     * removing its tag in the TagInput. This is generally more useful than\n     * `tagInputProps.onRemove`  because it receives the removed value instead of\n     * the value's rendered `ReactNode` tag.\n     *\n     * It is not recommended to supply _both_ this prop and `tagInputProps.onRemove`.\n     */\n    onRemove?: (value: T, index: number) => void;\n\n    /**\n     * If true, the component waits until a keydown event in the TagInput\n     * before opening its popover.\n     *\n     * If false, the popover opens immediately after a mouse click focuses\n     * the component's TagInput.\n     *\n     * N.B. the behavior of this prop differs slightly from the same one\n     * in the Suggest component; see https://github.com/palantir/blueprint/issues/4152.\n     *\n     * Ignored is customTarget prop is supplied.\n     *\n     * @default false\n     */\n    openOnKeyDown?: boolean;\n\n    /**\n     * Input placeholder text. Shorthand for `tagInputProps.placeholder`.\n     *\n     * @default \"Search...\"\n     */\n    placeholder?: string;\n\n    /** Controlled selected values. */\n    selectedItems: T[];\n\n    /**\n     * Props to pass to the [TagInput component](##core/components/tag-input).\n     *\n     * Some properties are unavailable:\n     * - `tagInputProps.inputValue`: use `query` instead\n     * - `tagInputProps.onInputChange`: use `onQueryChange` instead\n     *\n     * Some properties are available, but discouraged. If you find yourself using these due to a bug in MultiSelect\n     * or some edge case which is not handled by `onItemSelect`, `onItemsPaste`, `onRemove`, and `onClear`, please\n     * file a bug in the Blueprint repo:\n     * - `tagInputProps.onChange`\n     *\n     * Notes for `tagInputProps.rightElement`:\n     * - you are responsible for disabling any elements you may render here when the overall `MultiSelect` is disabled\n     * - if the `onClear` prop is defined, this element will override/replace the default rightElement,\n     *   which is a \"clear\" button that removes all items from the current selection.\n     *\n     * This prop is passed to either the default `TagInput` or the `TagInput` rendered within the Popover\n     * depending on whether `customTarget` is supplied.\n     */\n    tagInputProps?: Partial<Omit<TagInputProps, \"inputValue\" | \"onInputChange\">>;\n\n    /** Custom renderer to transform an item into tag content. */\n    tagRenderer: (item: T) => React.ReactNode;\n}\n\n/** Exported for testing, not part of public API */\nexport interface MultiSelectState {\n    isOpen: boolean;\n}\n\n/**\n * Multi select component.\n *\n * @see https://blueprintjs.com/docs/#select/multi-select\n */\nexport class MultiSelect<T> extends AbstractPureComponent<MultiSelectProps<T>, MultiSelectState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.MultiSelect`;\n\n    private listboxId = Utils.uniqueId(\"listbox\");\n\n    public static defaultProps = {\n        disabled: false,\n        fill: false,\n        placeholder: \"Search...\",\n    };\n\n    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */\n    public static ofType<U>() {\n        return MultiSelect as new (props: MultiSelectProps<U>) => MultiSelect<U>;\n    }\n\n    public state: MultiSelectState = {\n        isOpen: (this.props.popoverProps && this.props.popoverProps.isOpen) || false,\n    };\n\n    public input: HTMLInputElement | null = null;\n\n    public queryList: QueryList<T> | null = null;\n\n    private refHandlers: {\n        input: React.RefCallback<HTMLInputElement>;\n        popover: React.RefObject<Popover>;\n        queryList: React.RefCallback<QueryList<T>>;\n    } = {\n        input: refHandler(this, \"input\", this.props.tagInputProps?.inputRef),\n        popover: createRef(),\n        queryList: (ref: QueryList<T> | null) => (this.queryList = ref),\n    };\n\n    public componentDidUpdate(prevProps: MultiSelectProps<T>) {\n        if (prevProps.tagInputProps?.inputRef !== this.props.tagInputProps?.inputRef) {\n            setRef(prevProps.tagInputProps?.inputRef, null);\n            this.refHandlers.input = refHandler(this, \"input\", this.props.tagInputProps?.inputRef);\n            setRef(this.props.tagInputProps?.inputRef, this.input);\n        }\n        if (\n            (prevProps.onClear === undefined && this.props.onClear !== undefined) ||\n            (prevProps.onClear !== undefined && this.props.onClear === undefined)\n        ) {\n            this.forceUpdate();\n        }\n    }\n\n    public render() {\n        // omit props specific to this component, spread the rest.\n        const { menuProps, openOnKeyDown, popoverProps, tagInputProps, customTarget, ...restProps } = this.props;\n\n        return (\n            <QueryList<T>\n                {...restProps}\n                menuProps={{\n                    \"aria-label\": \"selectable options\",\n                    ...menuProps,\n                    \"aria-multiselectable\": true,\n                    id: this.listboxId,\n                }}\n                onItemSelect={this.handleItemSelect}\n                onQueryChange={this.handleQueryChange}\n                ref={this.refHandlers.queryList}\n                renderer={this.renderQueryList}\n            />\n        );\n    }\n\n    private renderQueryList = (listProps: QueryListRendererProps<T>) => {\n        const { disabled, popoverContentProps = {}, popoverProps = {} } = this.props;\n        const { handleKeyDown, handleKeyUp } = listProps;\n\n        // N.B. no need to set `popoverProps.fill` since that is unused with the `renderTarget` API\n        return (\n            <Popover\n                autoFocus={false}\n                canEscapeKeyClose={true}\n                disabled={disabled}\n                enforceFocus={false}\n                isOpen={this.state.isOpen}\n                placement={popoverProps.position || popoverProps.placement ? undefined : \"bottom-start\"}\n                {...popoverProps}\n                className={classNames(listProps.className, popoverProps.className)}\n                content={\n                    <div\n                        // In the case where customTarget is supplied and the TagInput is rendered within the Popover,\n                        // without matchTargetWidth there is no width defined in any of TagInput's\n                        // grandparents when it's rendered through usePortal, so it will never flex-wrap\n                        // and infinitely grow horizontally. To address this, if there is no width guidance\n                        // from matchTargetWidth, explicitly set a default width to so Tags will flex-wrap.\n                        className={\n                            this.props.customTarget != null && !this.props.popoverProps?.matchTargetWidth\n                                ? Classes.MULTISELECT_POPOVER_DEFAULT_WIDTH\n                                : undefined\n                        }\n                        {...popoverContentProps}\n                        onKeyDown={handleKeyDown}\n                        onKeyUp={handleKeyUp}\n                    >\n                        {/* If customTarget is provided, move the TagInput to within the Popover\n                        to retain core functionalities */}\n                        {this.props.customTarget != null &&\n                            this.getTagInput(\n                                listProps,\n                                classNames(CoreClasses.FILL, Classes.MULTISELECT_POPOVER_TAG_INPUT_MARGIN),\n                            )}\n                        {listProps.itemList}\n                    </div>\n                }\n                interactionKind=\"click\"\n                onInteraction={this.handlePopoverInteraction}\n                onOpened={this.handlePopoverOpened}\n                popoverClassName={classNames(Classes.MULTISELECT_POPOVER, popoverProps.popoverClassName)}\n                popupKind={PopupKind.LISTBOX}\n                ref={mergeRefs(this.refHandlers.popover, this.props.popoverRef)}\n                renderTarget={this.getPopoverTargetRenderer(listProps, this.state.isOpen)}\n            />\n        );\n    };\n\n    // We use the renderTarget API to flatten the rendered DOM and make it easier to implement features like\n    // the \"fill\" prop. Note that we must take `isOpen` as an argument to force this render function to be called\n    // again after that state changes.\n    private getPopoverTargetRenderer =\n        (listProps: QueryListRendererProps<T>, isOpen: boolean) =>\n        // N.B. pull out `isOpen` so that it's not forwarded to the DOM, but remember not to use it directly\n        // since it may be stale (`renderTarget` is not re-invoked on this.state changes).\n        // eslint-disable-next-line react/display-name\n        ({ isOpen: _isOpen, ref, ...targetProps }: PopoverTargetProps & PopoverClickTargetHandlers) => {\n            const { disabled, fill, selectedItems, popoverProps = {}, popoverTargetProps = {} } = this.props;\n            const { handleKeyDown, handleKeyUp } = listProps;\n\n            const { targetTagName = \"div\" } = popoverProps;\n\n            return createElement(\n                targetTagName,\n                {\n                    \"aria-autocomplete\": \"list\",\n                    \"aria-controls\": this.listboxId,\n                    ...popoverTargetProps,\n                    ...targetProps,\n                    \"aria-disabled\": disabled,\n                    \"aria-expanded\": isOpen,\n                    // Note that we must set FILL here in addition to TagInput to get the wrapper element to full width\n                    className: classNames(targetProps.className, popoverTargetProps.className, {\n                        [CoreClasses.FILL]: fill,\n                    }),\n                    // Normally, Popover would also need to attach its own `onKeyDown` handler via `targetProps`,\n                    // but in our case we fully manage that interaction and listen for key events to open/close\n                    // the popover, so we elide it from the DOM.\n                    onKeyDown: this.getTagInputKeyDownHandler(handleKeyDown),\n                    onKeyUp: this.getTagInputKeyUpHandler(handleKeyUp),\n                    ref,\n                    role: \"combobox\",\n                },\n                this.props.customTarget != null\n                    ? this.props.customTarget(selectedItems, isOpen)\n                    : this.getTagInput(listProps),\n            );\n        };\n\n    private getTagInput = (listProps: QueryListRendererProps<T>, className?: string) => {\n        const { disabled, fill, onClear, placeholder, selectedItems, tagInputProps = {} } = this.props;\n\n        const maybeClearButton =\n            onClear !== undefined && selectedItems.length > 0 ? (\n                // use both aria-label and title a11y attributes here, for screen readers\n                // and mouseover interactions respectively\n                <Button\n                    aria-label=\"Clear selected items\"\n                    disabled={disabled}\n                    icon={<Cross />}\n                    onClick={this.handleClearButtonClick}\n                    title=\"Clear selected items\"\n                    variant=\"minimal\"\n                />\n            ) : undefined;\n\n        // add our own inputProps.className so that we can reference it in event handlers\n        const inputProps: HTMLInputProps = {\n            ...tagInputProps.inputProps,\n            className: classNames(tagInputProps.inputProps?.className, Classes.MULTISELECT_TAG_INPUT_INPUT),\n        };\n\n        return (\n            <TagInput\n                placeholder={placeholder}\n                rightElement={maybeClearButton}\n                {...tagInputProps}\n                className={classNames(className, Classes.MULTISELECT, tagInputProps.className)}\n                disabled={disabled}\n                fill={fill}\n                inputRef={this.refHandlers.input}\n                inputProps={inputProps}\n                inputValue={listProps.query}\n                onAdd={this.getTagInputAddHandler(listProps)}\n                onInputChange={listProps.handleQueryChange}\n                onRemove={this.handleTagRemove}\n                values={selectedItems.map(this.props.tagRenderer)}\n            />\n        );\n    };\n\n    private handleItemSelect = (item: T, evt?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.input != null) {\n            this.input.focus();\n        }\n        this.props.onItemSelect?.(item, evt);\n        this.refHandlers.popover.current?.reposition(); // reposition when size of input changes\n    };\n\n    private handleQueryChange = (query: string, evt?: React.ChangeEvent<HTMLInputElement>) => {\n        this.setState({ isOpen: query.length > 0 || (this.props.customTarget == null && !this.props.openOnKeyDown) });\n        this.props.onQueryChange?.(query, evt);\n    };\n\n    // Popover interaction kind is CLICK, so this only handles click events.\n    // Note that we defer to the next animation frame in order to get the latest activeElement\n    private handlePopoverInteraction = (nextOpenState: boolean, evt?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.props.customTarget != null) {\n            this.setState({ isOpen: nextOpenState });\n            this.props.popoverProps?.onInteraction?.(nextOpenState, evt);\n            return;\n        }\n\n        this.requestAnimationFrame(() => {\n            const isInputFocused = this.input === Utils.getActiveElement(this.input);\n\n            if (this.input != null && !isInputFocused) {\n                // input is no longer focused, we should close the popover\n                this.setState({ isOpen: false });\n            } else if (!this.props.openOnKeyDown) {\n                // we should open immediately on click focus events\n                this.setState({ isOpen: true });\n            }\n\n            this.props.popoverProps?.onInteraction?.(nextOpenState, evt);\n        });\n    };\n\n    private handlePopoverOpened = (node: HTMLElement) => {\n        if (this.queryList != null) {\n            // scroll active item into view after popover transition completes and all dimensions are stable.\n            this.queryList.scrollActiveItemIntoView();\n        }\n\n        const hasCustomTarget = this.props.customTarget != null;\n        if (hasCustomTarget && this.input != null) {\n            const shouldAutofocus = this.props.tagInputProps?.inputProps?.autoFocus !== false;\n            if (shouldAutofocus) {\n                this.input.focus();\n            }\n        }\n\n        this.props.popoverProps?.onOpened?.(node);\n    };\n\n    private handleTagRemove = (tag: React.ReactNode, index: number) => {\n        const { selectedItems, onRemove, tagInputProps } = this.props;\n        onRemove?.(selectedItems[index], index);\n        tagInputProps?.onRemove?.(tag, index);\n        this.refHandlers.popover.current?.reposition(); // reposition when size of input changes\n    };\n\n    private getTagInputAddHandler =\n        (listProps: QueryListRendererProps<T>) => (values: any[], method: TagInputAddMethod) => {\n            if (method === \"paste\") {\n                listProps.handlePaste(values);\n            }\n        };\n\n    private getTagInputKeyDownHandler = (handleQueryListKeyDown: React.KeyboardEventHandler<HTMLElement>) => {\n        return (e: React.KeyboardEvent<HTMLElement>) => {\n            if (e.key === \"Escape\" || e.key === \"Tab\") {\n                // By default the escape key will not trigger a blur on the\n                // input element. It must be done explicitly.\n                if (e.key === \"Escape\") {\n                    this.input?.blur();\n                    // prevent other overlays from closing\n                    e.stopPropagation();\n                    // prevent browser-specific escape key behavior (Safari exits fullscreen)\n                    e.preventDefault();\n                }\n                this.setState({ isOpen: false });\n            } else if (!(e.key === \"Backspace\" || e.key === \"ArrowLeft\" || e.key === \"ArrowRight\")) {\n                // Custom target might not be an input, so certain keystrokes might have other effects (space pushing the scrollview down)\n                if (this.props.customTarget != null) {\n                    if (e.key === \" \") {\n                        e.preventDefault();\n                        this.setState({ isOpen: true });\n                    } else if (e.key === \"Enter\") {\n                        this.setState({ isOpen: true });\n                    }\n                } else {\n                    this.setState({ isOpen: true });\n                }\n            }\n\n            const isTargetingTagRemoveButton = (e.target as HTMLElement).closest(`.${CoreClasses.TAG_REMOVE}`) != null;\n\n            if (this.state.isOpen && !isTargetingTagRemoveButton) {\n                handleQueryListKeyDown?.(e);\n            }\n\n            this.props.popoverTargetProps?.onKeyDown?.(e);\n        };\n    };\n\n    private getTagInputKeyUpHandler = (handleQueryListKeyUp: React.KeyboardEventHandler<HTMLElement>) => {\n        return (e: React.KeyboardEvent<HTMLElement>) => {\n            const isTargetingInput = (e.target as HTMLElement).classList.contains(Classes.MULTISELECT_TAG_INPUT_INPUT);\n\n            // only handle events when the focus is on the actual <input> inside the TagInput, as that's\n            // what QueryList is designed to do\n            if (this.state.isOpen && isTargetingInput) {\n                handleQueryListKeyUp?.(e);\n            }\n\n            this.props.popoverTargetProps?.onKeyDown?.(e);\n        };\n    };\n\n    private handleClearButtonClick = () => {\n        this.props.onClear?.();\n        this.refHandlers.popover.current?.reposition(); // reposition when size of input changes\n    };\n}\n", "/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractComponent, DISPLAYNAME_PREFIX, Menu, type Props, Utils } from \"@blueprintjs/core\";\n\nimport {\n    type CreateNewItem,\n    executeItemsEqual,\n    getActiveItem,\n    getCreateNewItem,\n    isCreateNewItem,\n    type ItemListRendererProps,\n    type ItemModifiers,\n    type ListItemsProps,\n    renderFilteredItems,\n} from \"../../common\";\n\nexport interface QueryListProps<T> extends ListItemsProps<T> {\n    /**\n     * Initial active item, useful if the parent component is controlling its selectedItem but\n     * not activeItem.\n     */\n    initialActiveItem?: T;\n\n    /**\n     * Additional props to apply to the `Menu` that is created within the `QueryList`\n     */\n    menuProps?: React.HTMLAttributes<HTMLUListElement>;\n\n    /**\n     * Callback invoked when user presses a key, after processing `QueryList`'s own key events\n     * (up/down to navigate active item). This callback is passed to `renderer` and (along with\n     * `onKeyUp`) can be attached to arbitrary content elements to support keyboard selection.\n     */\n    onKeyDown?: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Callback invoked when user releases a key, after processing `QueryList`'s own key events\n     * (enter to select active item). This callback is passed to `renderer` and (along with\n     * `onKeyDown`) can be attached to arbitrary content elements to support keyboard selection.\n     */\n    onKeyUp?: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * ID prefix for generating unique IDs for list options.\n     * Defaults to a generated ID.\n     */\n    listId?: string;\n\n    /**\n     * Customize rendering of the component.\n     * Receives an object with props that should be applied to elements as necessary.\n     */\n    renderer: (listProps: QueryListRendererProps<T>) => React.JSX.Element;\n\n    /**\n     * Whether the list is disabled.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n}\n\n/**\n * An object describing how to render a `QueryList`.\n * A `QueryList` `renderer` receives this object as its sole argument.\n */\nexport interface QueryListRendererProps<T> // Omit `createNewItem`, because it's used strictly for internal tracking.\n    extends Pick<QueryListState<T>, \"activeItem\" | \"filteredItems\" | \"query\">,\n        Props {\n    /**\n     * Selection handler that should be invoked when a new item has been chosen,\n     * perhaps because the user clicked it.\n     */\n    handleItemSelect: (item: T, event?: React.SyntheticEvent<HTMLElement>) => void;\n\n    /**\n     * ID of the currently active item for aria-activedescendant.\n     */\n    activeItemId?: string;\n\n    /**\n     * ID of the list container for ARIA relationships.\n     */\n    listId: string;\n\n    /**\n     * Handler that should be invoked when the user pastes one or more values.\n     *\n     * This callback will use `itemPredicate` with `exactMatch=true` to find a\n     * subset of `items` exactly matching the pasted `values` provided, then it\n     * will invoke `onItemsPaste` with those found items. Each pasted value that\n     * does not exactly match an item will be ignored.\n     *\n     * If creating items is enabled (by providing both `createNewItemFromQuery`\n     * and `createNewItemRenderer`), then pasted values that do not exactly\n     * match an existing item will emit a new item as created via\n     * `createNewItemFromQuery`.\n     *\n     * If `itemPredicate` returns multiple matching items for a particular query\n     * in `queries`, then only the first matching item will be emitted.\n     */\n    handlePaste: (queries: string[]) => void;\n\n    /**\n     * Keyboard handler for up/down arrow keys to shift the active item.\n     * Attach this handler to any element that should support this interaction.\n     */\n    handleKeyDown: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Keyboard handler for enter key to select the active item.\n     * Attach this handler to any element that should support this interaction.\n     */\n    handleKeyUp: React.KeyboardEventHandler<HTMLElement>;\n\n    /**\n     * Change handler for query string. Attach this to an input element to allow\n     * `QueryList` to control the query.\n     */\n    handleQueryChange: React.ChangeEventHandler<HTMLInputElement>;\n\n    /** Rendered elements returned from `itemListRenderer` prop. */\n    itemList: React.ReactNode;\n}\n\n/** Exported for testing, not part of public API */\nexport interface QueryListState<T> {\n    /** The currently focused item (for keyboard interactions). */\n    activeItem: T | CreateNewItem | null;\n\n    /**\n     * The item returned from `createNewItemFromQuery(this.state.query)`, cached\n     * to avoid continuous reinstantions within `isCreateItemRendered`, where\n     * this element will be used to hide the \"Create Item\" option if its value\n     * matches the current `query`.\n     */\n    createNewItem: T | T[] | undefined;\n\n    /** The original `items` array filtered by `itemListPredicate` or `itemPredicate`. */\n    filteredItems: T[];\n\n    /** The current query string. */\n    query: string;\n}\n\n/**\n * Query list component.\n *\n * @see https://blueprintjs.com/docs/#select/query-list\n */\nexport class QueryList<T> extends AbstractComponent<QueryListProps<T>, QueryListState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.QueryList`;\n\n    public static defaultProps = {\n        disabled: false,\n        resetOnQuery: true,\n    };\n\n    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */\n    public static ofType<U>() {\n        return QueryList as new (props: QueryListProps<U>) => QueryList<U>;\n    }\n\n    private itemsParentRef?: HTMLElement | null;\n\n    private itemRefs = new Map<number, HTMLElement>();\n\n    private listId: string;\n\n    private refHandlers = {\n        itemsParent: (ref: HTMLElement | null) => (this.itemsParentRef = ref),\n    };\n\n    /**\n     * Flag indicating that we should check whether selected item is in viewport\n     * after rendering, typically because of keyboard change. Set to `true` when\n     * manipulating state in a way that may cause active item to scroll away.\n     */\n    private shouldCheckActiveItemInViewport = false;\n\n    /**\n     * The item that we expect to be the next selected active item (based on click\n     * or key interactions). When scrollToActiveItem = false, used to detect if\n     * an unexpected external change to the active item has been made.\n     */\n    private expectedNextActiveItem: T | CreateNewItem | null = null;\n\n    /**\n     * Flag which is set to true while in between an ENTER \"keydown\" event and its\n     * corresponding \"keyup\" event.\n     *\n     * When entering text via an IME (https://en.wikipedia.org/wiki/Input_method),\n     * the ENTER key is pressed to confirm the character(s) to be input from a list\n     * of options. The operating system intercepts the ENTER \"keydown\" event and\n     * prevents it from propagating to the application, but \"keyup\" is still\n     * fired, triggering a spurious event which this component does not expect.\n     *\n     * To work around this quirk, we keep track of \"real\" key presses by setting\n     * this flag in handleKeyDown.\n     */\n    private isEnterKeyPressed = false;\n\n    public constructor(props: QueryListProps<T>) {\n        super(props);\n\n        // Generate unique ID for accessibility\n        this.listId = props.listId ?? Utils.uniqueId(\"bp-query-list\");\n\n        const { query = \"\" } = props;\n        const createNewItem = props.createNewItemFromQuery?.(query);\n        const filteredItems = getFilteredItems(query, props);\n\n        this.state = {\n            activeItem:\n                props.activeItem !== undefined\n                    ? props.activeItem\n                    : (props.initialActiveItem ?? getFirstEnabledItem(filteredItems, props.itemDisabled)),\n            createNewItem,\n            filteredItems,\n            query,\n        };\n    }\n\n    public render() {\n        const { className, items, renderer, itemListRenderer = this.renderItemList, menuProps } = this.props;\n        const { createNewItem, ...spreadableState } = this.state;\n\n        // Generate ID for active item\n        const activeItemId = this.getActiveItemId();\n\n        return renderer({\n            ...spreadableState,\n            activeItemId,\n            className,\n            handleItemSelect: this.handleItemSelect,\n            handleKeyDown: this.handleKeyDown,\n            handleKeyUp: this.handleKeyUp,\n            handlePaste: this.handlePaste,\n            handleQueryChange: this.handleInputQueryChange,\n            itemList: itemListRenderer({\n                ...spreadableState,\n                items,\n                itemsParentRef: this.refHandlers.itemsParent,\n                menuProps: {\n                    ...menuProps,\n                    id: this.listId,\n                },\n                renderCreateItem: this.renderCreateItemMenuItem,\n                renderItem: this.renderItem,\n            }),\n            listId: this.listId,\n        });\n    }\n\n    public componentDidUpdate(prevProps: QueryListProps<T>) {\n        if (this.props.activeItem !== undefined && this.props.activeItem !== this.state.activeItem) {\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem: this.props.activeItem });\n        }\n\n        if (this.props.query != null && this.props.query !== prevProps.query) {\n            // new query\n            this.setQuery(this.props.query, this.props.resetOnQuery, this.props);\n        } else if (\n            // same query (or uncontrolled query), but items in the list changed\n            !Utils.shallowCompareKeys(this.props, prevProps, {\n                include: [\"items\", \"itemListPredicate\", \"itemPredicate\"],\n            })\n        ) {\n            this.setQuery(this.state.query);\n        }\n\n        if (this.shouldCheckActiveItemInViewport) {\n            // update scroll position immediately before repaint so DOM is accurate\n            // (latest filteredItems) and to avoid flicker.\n            this.requestAnimationFrame(() => this.scrollActiveItemIntoView());\n            // reset the flag\n            this.shouldCheckActiveItemInViewport = false;\n        }\n    }\n\n    public scrollActiveItemIntoView() {\n        const scrollToActiveItem = this.props.scrollToActiveItem !== false;\n        const externalChangeToActiveItem = !executeItemsEqual(\n            this.props.itemsEqual,\n            getActiveItem(this.expectedNextActiveItem),\n            getActiveItem(this.props.activeItem),\n        );\n        this.expectedNextActiveItem = null;\n\n        if (!scrollToActiveItem && externalChangeToActiveItem) {\n            return;\n        }\n\n        const activeElement = this.getActiveElement();\n        if (this.itemsParentRef != null && activeElement != null) {\n            const { offsetTop: activeTop, offsetHeight: activeHeight } = activeElement;\n            const {\n                offsetTop: parentOffsetTop,\n                scrollTop: parentScrollTop,\n                clientHeight: parentHeight,\n            } = this.itemsParentRef;\n            // compute padding on parent element to ensure we always leave space\n            const { paddingTop, paddingBottom } = this.getItemsParentPadding();\n\n            // compute the two edges of the active item for comparison, including parent padding\n            const activeBottomEdge = activeTop + activeHeight + paddingBottom - parentOffsetTop;\n            const activeTopEdge = activeTop - paddingTop - parentOffsetTop;\n\n            if (activeBottomEdge >= parentScrollTop + parentHeight) {\n                // offscreen bottom: align bottom of item with bottom of viewport\n                this.itemsParentRef.scrollTop = activeBottomEdge + activeHeight - parentHeight;\n            } else if (activeTopEdge <= parentScrollTop) {\n                // offscreen top: align top of item with top of viewport\n                this.itemsParentRef.scrollTop = activeTopEdge - activeHeight;\n            }\n        }\n    }\n\n    public setQuery(query: string, resetActiveItem = this.props.resetOnQuery, props = this.props) {\n        const { createNewItemFromQuery } = props;\n\n        this.shouldCheckActiveItemInViewport = true;\n        const hasQueryChanged = query !== this.state.query;\n        if (hasQueryChanged) {\n            props.onQueryChange?.(query);\n        }\n\n        // Leading and trailing whitespace can be confusing to display, so we remove it when passing it\n        // to functions dealing with data, like createNewItemFromQuery. But we need the unaltered user-typed\n        // query to remain in state to be able to render controlled text inputs properly.\n        const trimmedQuery = query.trim();\n        const filteredItems = getFilteredItems(trimmedQuery, props);\n        const createNewItem =\n            createNewItemFromQuery != null && trimmedQuery !== \"\" ? createNewItemFromQuery(trimmedQuery) : undefined;\n        this.setState({ createNewItem, filteredItems, query });\n\n        // always reset active item if it's now filtered or disabled\n        const activeIndex = this.getActiveIndex(filteredItems);\n        const shouldUpdateActiveItem =\n            resetActiveItem ||\n            activeIndex < 0 ||\n            isItemDisabled(getActiveItem(this.state.activeItem), activeIndex, props.itemDisabled);\n\n        if (shouldUpdateActiveItem) {\n            // if the `createNewItem` is first, that should be the first active item.\n            if (this.isCreateItemRendered(createNewItem) && this.isCreateItemFirst()) {\n                this.setActiveItem(getCreateNewItem());\n            } else {\n                this.setActiveItem(getFirstEnabledItem(filteredItems, props.itemDisabled));\n            }\n        }\n    }\n\n    public setActiveItem(activeItem: T | CreateNewItem | null) {\n        this.expectedNextActiveItem = activeItem;\n        if (this.props.activeItem === undefined) {\n            // indicate that the active item may need to be scrolled into view after update.\n            this.shouldCheckActiveItemInViewport = true;\n            this.setState({ activeItem });\n        }\n\n        if (isCreateNewItem(activeItem)) {\n            this.props.onActiveItemChange?.(null, true);\n        } else {\n            this.props.onActiveItemChange?.(activeItem, false);\n        }\n    }\n\n    /** default `itemListRenderer` implementation */\n    private renderItemList = (listProps: ItemListRendererProps<T>) => {\n        const { initialContent, noResults } = this.props;\n\n        // omit noResults if createNewItemFromQuery and createNewItemRenderer are both supplied, and query is not empty\n        const createItemView = listProps.renderCreateItem();\n        const maybeNoResults = createItemView != null ? null : noResults;\n        const menuContent = renderFilteredItems(listProps, maybeNoResults, initialContent);\n        if (menuContent == null && createItemView == null) {\n            return null;\n        }\n        const createFirst = this.isCreateItemFirst();\n        return (\n            <Menu role=\"listbox\" {...listProps.menuProps} ulRef={listProps.itemsParentRef}>\n                {createFirst && createItemView}\n                {menuContent}\n                {!createFirst && createItemView}\n            </Menu>\n        );\n    };\n\n    /** wrapper around `itemRenderer` to inject props */\n    private renderItem = (item: T, index: number) => {\n        if (this.props.disabled !== true) {\n            const { activeItem, query, filteredItems } = this.state;\n\n            const modifiers: ItemModifiers = {\n                active: executeItemsEqual(this.props.itemsEqual, getActiveItem(activeItem), item),\n                disabled: isItemDisabled(item, index, this.props.itemDisabled),\n                matchesPredicate: filteredItems.indexOf(item) >= 0,\n            };\n\n            // Generate accessibility attributes\n            const itemId = `${this.listId}-item-${index}`;\n\n            return this.props.itemRenderer(item, {\n                handleClick: e => this.handleItemSelect(item, e),\n                handleFocus: () => this.setActiveItem(item),\n                id: itemId,\n                index,\n                modifiers,\n                query,\n                ref: node => {\n                    if (node) {\n                        this.itemRefs.set(index, node);\n                    } else {\n                        this.itemRefs.delete(index);\n                    }\n                },\n            });\n        }\n\n        return null;\n    };\n\n    private renderCreateItemMenuItem = () => {\n        if (this.isCreateItemRendered(this.state.createNewItem)) {\n            const { activeItem, query } = this.state;\n            const trimmedQuery = query.trim();\n            const handleClick: React.MouseEventHandler<HTMLElement> = evt => {\n                this.handleItemCreate(trimmedQuery, evt);\n            };\n            const isActive = isCreateNewItem(activeItem);\n            return this.props.createNewItemRenderer!(trimmedQuery, isActive, handleClick);\n        }\n\n        return null;\n    };\n\n    private getActiveElement() {\n        const { activeItem } = this.state;\n        if (this.itemsParentRef != null) {\n            if (isCreateNewItem(activeItem)) {\n                const index = this.isCreateItemFirst() ? 0 : this.state.filteredItems.length;\n                return this.itemsParentRef.children.item(index) as HTMLElement;\n            } else {\n                const activeIndex = this.getActiveIndex();\n                return (\n                    this.itemRefs.get(activeIndex) ?? (this.itemsParentRef.children.item(activeIndex) as HTMLElement)\n                );\n            }\n        }\n        return undefined;\n    }\n\n    private getActiveIndex(items = this.state.filteredItems) {\n        const { activeItem } = this.state;\n        if (activeItem == null || isCreateNewItem(activeItem)) {\n            return -1;\n        }\n        // NOTE: this operation is O(n) so it should be avoided in render(). safe for events though.\n        for (let i = 0; i < items.length; ++i) {\n            if (executeItemsEqual(this.props.itemsEqual, items[i], activeItem)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    private getItemsParentPadding() {\n        // assert ref exists because it was checked before calling\n        const { paddingTop, paddingBottom } = getComputedStyle(this.itemsParentRef!);\n        return {\n            paddingBottom: pxToNumber(paddingBottom),\n            paddingTop: pxToNumber(paddingTop),\n        };\n    }\n\n    private handleItemCreate = (query: string, evt?: React.SyntheticEvent<HTMLElement>) => {\n        // we keep a cached createNewItem in state, but might as well recompute\n        // the result just to be sure it's perfectly in sync with the query.\n        const value = this.props.createNewItemFromQuery?.(query);\n\n        if (value != null) {\n            const newItems = Array.isArray(value) ? value : [value];\n            for (const item of newItems) {\n                this.props.onItemSelect?.(item, evt);\n            }\n            this.maybeResetQuery();\n        }\n    };\n\n    private handleItemSelect = (item: T, event?: React.SyntheticEvent<HTMLElement>) => {\n        this.setActiveItem(item);\n        this.props.onItemSelect?.(item, event);\n        this.maybeResetQuery();\n    };\n\n    private handlePaste = (queries: string[]) => {\n        const { createNewItemFromQuery, onItemsPaste } = this.props;\n\n        let nextActiveItem: T | undefined;\n        const nextQueries = [];\n\n        // Find an exising itemthat exactly matches each pasted value, or\n        // create a new item if possible. Ignore unmatched values if creating\n        // items is disabled.\n        const pastedItemsToEmit = [];\n\n        for (const query of queries) {\n            const equalItem = getMatchingItem(query, this.props);\n\n            if (equalItem !== undefined) {\n                nextActiveItem = equalItem;\n                pastedItemsToEmit.push(equalItem);\n            } else if (this.canCreateItems()) {\n                const value = createNewItemFromQuery?.(query);\n                if (value !== undefined) {\n                    const newItems = Array.isArray(value) ? value : [value];\n                    pastedItemsToEmit.push(...newItems);\n                }\n            } else {\n                nextQueries.push(query);\n            }\n        }\n\n        // UX nicety: combine all unmatched queries into a single\n        // comma-separated query in the input, so we don't lose any information.\n        // And don't reset the active item; we'll do that ourselves below.\n        this.setQuery(nextQueries.join(\", \"), false);\n\n        // UX nicety: update the active item if we matched with at least one\n        // existing item.\n        if (nextActiveItem !== undefined) {\n            this.setActiveItem(nextActiveItem);\n        }\n\n        onItemsPaste?.(pastedItemsToEmit);\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n        if (!event.nativeEvent.isComposing) {\n            const { key } = event;\n            const direction = Utils.getArrowKeyDirection(event, [\"ArrowUp\"], [\"ArrowDown\"]);\n            if (direction !== undefined) {\n                event.preventDefault();\n                const nextActiveItem = this.getNextActiveItem(direction);\n                if (nextActiveItem != null) {\n                    this.setActiveItem(nextActiveItem);\n                }\n            } else if (key === \"Enter\") {\n                this.isEnterKeyPressed = true;\n            }\n        }\n\n        this.props.onKeyDown?.(event);\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { onKeyUp } = this.props;\n        const { activeItem } = this.state;\n\n        if (event.key === \"Enter\" && this.isEnterKeyPressed) {\n            // We handle ENTER in keyup here to play nice with the Button component's keyboard\n            // clicking. Button is commonly used as the only child of Select. If we were to\n            // instead process ENTER on keydown, then Button would click itself on keyup and\n            // the Select popover would re-open.\n            event.preventDefault();\n            if (activeItem == null || isCreateNewItem(activeItem)) {\n                this.handleItemCreate(this.state.query, event);\n            } else {\n                this.handleItemSelect(activeItem, event);\n            }\n            this.isEnterKeyPressed = false;\n        }\n\n        onKeyUp?.(event);\n    };\n\n    private handleInputQueryChange = (event?: React.ChangeEvent<HTMLInputElement>) => {\n        const query = event == null ? \"\" : event.target.value;\n        this.setQuery(query);\n        this.props.onQueryChange?.(query, event);\n    };\n\n    /**\n     * Get the next enabled item, moving in the given direction from the start\n     * index. A `null` return value means no suitable item was found.\n     *\n     * @param direction amount to move in each iteration, typically +/-1\n     * @param startIndex item to start iteration\n     */\n    private getNextActiveItem(direction: 1 | -1, startIndex = this.getActiveIndex()): T | CreateNewItem | null {\n        if (this.isCreateItemRendered(this.state.createNewItem)) {\n            const reachedCreate =\n                (startIndex === 0 && direction === -1) ||\n                (startIndex === this.state.filteredItems.length - 1 && direction === 1);\n            if (reachedCreate) {\n                return getCreateNewItem();\n            }\n        }\n        return getFirstEnabledItem(this.state.filteredItems, this.props.itemDisabled, direction, startIndex);\n    }\n\n    /**\n     * @param createNewItem Checks if this item would match the current query. Cannot check this.state.createNewItem\n     *  every time since state may not have been updated yet.\n     */\n    private isCreateItemRendered(createNewItem?: T | T[]): boolean {\n        return (\n            this.canCreateItems() &&\n            this.state.query !== \"\" &&\n            // this check is unfortunately O(N) on the number of items, but\n            // alas, hiding the \"Create Item\" option when it exactly matches an\n            // existing item is much clearer.\n            !this.wouldCreatedItemMatchSomeExistingItem(createNewItem)\n        );\n    }\n\n    private isCreateItemFirst(): boolean {\n        return this.props.createNewItemPosition === \"first\";\n    }\n\n    private canCreateItems(): boolean {\n        return this.props.createNewItemFromQuery != null && this.props.createNewItemRenderer != null;\n    }\n\n    private wouldCreatedItemMatchSomeExistingItem(createNewItem?: T | T[]) {\n        // search only the filtered items, not the full items list, because we\n        // only need to check items that match the current query.\n        return this.state.filteredItems.some(item => {\n            const newItems = Array.isArray(createNewItem) ? createNewItem : [createNewItem];\n            return newItems.some(newItem => executeItemsEqual(this.props.itemsEqual, item, newItem));\n        });\n    }\n\n    private maybeResetQuery() {\n        if (this.props.resetOnSelect) {\n            this.setQuery(\"\", true);\n        }\n    }\n\n    /** Generate unique ID for the currently active item */\n    private getActiveItemId(): string | undefined {\n        const { activeItem } = this.state;\n\n        if (activeItem == null) {\n            return undefined;\n        }\n\n        if (isCreateNewItem(activeItem)) {\n            return `${this.listId}-create-item`;\n        }\n\n        const activeIndex = this.getActiveIndex();\n        return activeIndex >= 0 ? `${this.listId}-item-${activeIndex}` : undefined;\n    }\n}\n\nfunction pxToNumber(value: string | null) {\n    return value == null ? 0 : parseInt(value.slice(0, -2), 10);\n}\n\nfunction getMatchingItem<T>(query: string, { items, itemPredicate }: QueryListProps<T>): T | undefined {\n    if (Utils.isFunction(itemPredicate)) {\n        // .find() doesn't exist in ES5. Alternative: use a for loop instead of\n        // .filter() so that we can return as soon as we find the first match.\n        for (let i = 0; i < items.length; i++) {\n            const item = items[i];\n            if (itemPredicate(query, item, i, true)) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\n\nfunction getFilteredItems<T>(query: string, { items, itemPredicate, itemListPredicate }: QueryListProps<T>) {\n    if (Utils.isFunction(itemListPredicate)) {\n        // note that implementations can reorder the items here\n        return itemListPredicate(query, items);\n    } else if (Utils.isFunction(itemPredicate)) {\n        return items.filter((item, index) => itemPredicate(query, item, index));\n    }\n    return items;\n}\n\n/** Wrap number around min/max values: if it exceeds one bound, return the other. */\nfunction wrapNumber(value: number, min: number, max: number) {\n    if (value < min) {\n        return max;\n    } else if (value > max) {\n        return min;\n    }\n    return value;\n}\n\nfunction isItemDisabled<T>(item: T | null, index: number, itemDisabled?: ListItemsProps<T>[\"itemDisabled\"]) {\n    if (itemDisabled == null || item == null) {\n        return false;\n    } else if (Utils.isFunction(itemDisabled)) {\n        return itemDisabled(item, index);\n    }\n    return !!item[itemDisabled];\n}\n\n/**\n * Get the next enabled item, moving in the given direction from the start\n * index. A `null` return value means no suitable item was found.\n *\n * @param items the list of items\n * @param itemDisabled callback to determine if a given item is disabled\n * @param direction amount to move in each iteration, typically +/-1\n * @param startIndex which index to begin moving from\n */\nexport function getFirstEnabledItem<T>(\n    items: T[],\n    itemDisabled?: keyof T | ((item: T, index: number) => boolean),\n    direction = 1,\n    startIndex = items.length - 1,\n): T | CreateNewItem | null {\n    if (items.length === 0) {\n        return null;\n    }\n    // remember where we started to prevent an infinite loop\n    let index = startIndex;\n    const maxIndex = items.length - 1;\n    do {\n        // find first non-disabled item\n        index = wrapNumber(index + direction, 0, maxIndex);\n        if (!isItemDisabled(items[index], index, itemDisabled)) {\n            return items[index];\n        }\n    } while (index !== startIndex && startIndex !== -1);\n    return null;\n}\n", "/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { PureComponent } from \"react\";\n\nimport { DISPLAYNAME_PREFIX, InputGroup, type InputGroupProps, Overlay2, type OverlayProps } from \"@blueprintjs/core\";\nimport { Search } from \"@blueprintjs/icons\";\n\nimport { Classes, type ListItemsProps } from \"../../common\";\nimport { QueryList, type QueryListRendererProps } from \"../query-list/queryList\";\n\nexport interface OmnibarProps<T> extends ListItemsProps<T> {\n    /**\n     * Props to spread to the query `InputGroup`. Use `query` and\n     * `onQueryChange` instead of `inputProps.value` and `inputProps.onChange`\n     * to control this input.\n     */\n    inputProps?: InputGroupProps;\n\n    /**\n     * Toggles the visibility of the omnibar.\n     * This prop is required because the component is controlled.\n     */\n    isOpen: boolean;\n\n    /**\n     * A callback that is invoked when user interaction causes the omnibar to\n     * close, such as clicking on the overlay or pressing the `esc` key (if\n     * enabled). Receives the event from the user's interaction, if there was an\n     * event (generally either a mouse or key event).\n     *\n     * Note that due to controlled usage, this component will not actually close\n     * itself until the `isOpen` prop becomes `false`.\n     * .\n     */\n    onClose?: (event?: React.SyntheticEvent<HTMLElement>) => void;\n\n    /** Props to spread to `Overlay`. */\n    overlayProps?: Partial<OverlayProps>;\n}\n\n/**\n * Omnibar component.\n *\n * @see https://blueprintjs.com/docs/#select/omnibar\n */\nexport class Omnibar<T> extends PureComponent<OmnibarProps<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Omnibar`;\n\n    public static ofType<U>() {\n        return Omnibar as new (props: OmnibarProps<U>) => Omnibar<U>;\n    }\n\n    public render() {\n        // omit props specific to this component, spread the rest.\n        const { isOpen, inputProps, overlayProps, ...restProps } = this.props;\n        const initialContent = \"initialContent\" in this.props ? this.props.initialContent : null;\n\n        return (\n            <QueryList<T>\n                {...restProps}\n                // Omnibar typically does not keep track of and/or show its selection state like other\n                // select components, so it's more of a menu than a listbox. This means that users should return\n                // MenuItems with roleStructure=\"menuitem\" (the default value) in `props.itemRenderer`.\n                menuProps={{ role: \"menu\" }}\n                initialContent={initialContent}\n                renderer={this.renderQueryList}\n            />\n        );\n    }\n\n    private renderQueryList = (listProps: QueryListRendererProps<T>) => {\n        const { inputProps = {}, isOpen, overlayProps = {} } = this.props;\n        const { handleKeyDown, handleKeyUp } = listProps;\n        const handlers = isOpen ? { onKeyDown: handleKeyDown, onKeyUp: handleKeyUp } : {};\n\n        return (\n            <Overlay2\n                hasBackdrop={true}\n                {...overlayProps}\n                isOpen={isOpen}\n                className={classNames(Classes.OMNIBAR_OVERLAY, overlayProps.className)}\n                onClose={this.handleOverlayClose}\n            >\n                <div className={classNames(Classes.OMNIBAR, listProps.className)} {...handlers}>\n                    <InputGroup\n                        autoFocus={true}\n                        leftIcon={<Search />}\n                        placeholder=\"Search...\"\n                        size=\"large\"\n                        {...inputProps}\n                        onChange={listProps.handleQueryChange}\n                        value={listProps.query}\n                    />\n                    {listProps.itemList}\n                </div>\n            </Overlay2>\n        );\n    };\n\n    private handleOverlayClose = (event: React.SyntheticEvent<HTMLElement>) => {\n        this.props.overlayProps?.onClose?.(event);\n        this.props.onClose?.(event);\n    };\n}\n", "/*\n * Copyright 2022 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport { createElement } from \"react\";\n\nimport {\n    AbstractPureComponent,\n    Button,\n    Classes as CoreClasses,\n    DISPLAYNAME_PREFIX,\n    InputGroup,\n    type InputGroupProps,\n    Popover,\n    type PopoverClickTargetHandlers,\n    type PopoverTargetProps,\n    PopupKind,\n    refHandler,\n    setRef,\n    Utils,\n} from \"@blueprintjs/core\";\nimport { Cross, Search } from \"@blueprintjs/icons\";\n\nimport { Classes, type ListItemsProps, type SelectPopoverProps } from \"../../common\";\nimport { QueryList, type QueryListRendererProps } from \"../query-list/queryList\";\n\nexport interface SelectProps<T> extends ListItemsProps<T>, SelectPopoverProps {\n    /**\n     * Element which triggers the select popover. In most cases, you should display\n     * the name or label of the curently selected item here.\n     */\n    children?: React.ReactNode;\n\n    /**\n     * Whether the component is non-interactive.\n     * If true, the list's item renderer will not be called.\n     * Note that you'll also need to disable the component's children, if appropriate.\n     *\n     * @default false\n     */\n    disabled?: boolean;\n\n    /**\n     * Whether the component should take up the full width of its container.\n     * You also have to ensure that the child component has `fill` set to `true` or is styled appropriately.\n     */\n    fill?: boolean;\n\n    /**\n     * Whether the dropdown list can be filtered.\n     * Disabling this option will remove the `InputGroup` and ignore `inputProps`.\n     *\n     * @default true\n     */\n    filterable?: boolean;\n\n    /**\n     * Props to pass to the query [InputGroup component](#core/components/input-group).\n     *\n     * Some properties are unavailable:\n     * - `inputProps.value`: use `query` instead\n     * - `inputProps.onChange`: use `onQueryChange` instead\n     */\n    inputProps?: Partial<Omit<InputGroupProps, \"value\" | \"onChange\">>;\n\n    /**\n     * HTML attributes to add to the `Menu` listbox containing the selectable options.\n     */\n    menuProps?: React.HTMLAttributes<HTMLUListElement>;\n\n    /**\n     * A placeholder string passed to the filter text input.\n     * Applicable only when `filterable` is `true`.\n     *\n     * @default \"Filter...\"\n     */\n    placeholder?: string;\n\n    /**\n     * Whether the active item should be reset to the first matching item _when\n     * the popover closes_. The query will also be reset to the empty string.\n     *\n     * @default false\n     */\n    resetOnClose?: boolean;\n}\n\n/** Exported for testing, not part of public API */\nexport interface SelectState {\n    isOpen: boolean;\n}\n\n/**\n * Select component.\n *\n * @see https://blueprintjs.com/docs/#select/select\n */\nexport class Select<T> extends AbstractPureComponent<SelectProps<T>, SelectState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Select`;\n\n    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */\n    public static ofType<U>() {\n        return Select as new (props: SelectProps<U>) => Select<U>;\n    }\n\n    public state: SelectState = { isOpen: false };\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private queryList: QueryList<T> | null = null;\n\n    private previousFocusedElement: HTMLElement | undefined;\n\n    private handleInputRef: React.Ref<HTMLInputElement> = refHandler(\n        this,\n        \"inputElement\",\n        this.props.inputProps?.inputRef,\n    );\n\n    private handleQueryListRef = (ref: QueryList<T> | null) => (this.queryList = ref);\n\n    private listboxId = Utils.uniqueId(\"listbox\");\n\n    public render() {\n        // omit props specific to this component, spread the rest.\n        const { filterable, inputProps, menuProps, popoverProps, ...restProps } = this.props;\n\n        return (\n            <QueryList<T>\n                {...restProps}\n                listId={this.listboxId}\n                menuProps={{ \"aria-label\": \"selectable options\", ...menuProps }}\n                onItemSelect={this.handleItemSelect}\n                ref={this.handleQueryListRef}\n                renderer={this.renderQueryList}\n            />\n        );\n    }\n\n    public componentDidUpdate(prevProps: SelectProps<T>, prevState: SelectState) {\n        if (prevProps.inputProps?.inputRef !== this.props.inputProps?.inputRef) {\n            setRef(prevProps.inputProps?.inputRef, null);\n            this.handleInputRef = refHandler(this, \"inputElement\", this.props.inputProps?.inputRef);\n            setRef(this.props.inputProps?.inputRef, this.inputElement);\n        }\n\n        if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {\n            this.queryList.scrollActiveItemIntoView();\n        }\n    }\n\n    private renderQueryList = (listProps: QueryListRendererProps<T>) => {\n        // not using defaultProps cuz they're hard to type with generics (can't use <T> on static members)\n        const {\n            filterable = true,\n            disabled = false,\n            inputProps = {},\n            placeholder = \"Filter...\",\n            popoverContentProps = {},\n            popoverProps = {},\n            popoverRef,\n        } = this.props;\n\n        const input = (\n            <InputGroup\n                aria-activedescendant={listProps.activeItemId}\n                aria-autocomplete=\"list\"\n                aria-expanded={this.state.isOpen}\n                leftIcon={<Search />}\n                placeholder={placeholder}\n                rightElement={this.maybeRenderClearButton(listProps.query)}\n                role=\"combobox\"\n                {...inputProps}\n                inputRef={this.handleInputRef}\n                onChange={listProps.handleQueryChange}\n                value={listProps.query}\n            />\n        );\n\n        const { handleKeyDown, handleKeyUp } = listProps;\n\n        // N.B. no need to set `fill` since that is unused with the `renderTarget` API\n        return (\n            <Popover\n                autoFocus={false}\n                enforceFocus={false}\n                isOpen={this.state.isOpen}\n                disabled={disabled}\n                placement={popoverProps.position || popoverProps.placement ? undefined : \"bottom-start\"}\n                {...popoverProps}\n                className={classNames(listProps.className, popoverProps.className)}\n                content={\n                    <div {...popoverContentProps} onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>\n                        {filterable ? input : undefined}\n                        {listProps.itemList}\n                    </div>\n                }\n                onClosing={this.handlePopoverClosing}\n                onInteraction={this.handlePopoverInteraction}\n                onOpened={this.handlePopoverOpened}\n                onOpening={this.handlePopoverOpening}\n                popoverClassName={classNames(Classes.SELECT_POPOVER, popoverProps.popoverClassName)}\n                popupKind={PopupKind.LISTBOX}\n                ref={popoverRef}\n                renderTarget={this.getPopoverTargetRenderer(listProps, this.state.isOpen)}\n            />\n        );\n    };\n\n    // We use the renderTarget API to flatten the rendered DOM and make it easier to implement features like\n    // the \"fill\" prop. Note that we must take `isOpen` as an argument to force this render function to be called\n    // again after that state changes.\n    private getPopoverTargetRenderer =\n        (listProps: QueryListRendererProps<T>, isOpen: boolean) =>\n        // N.B. pull out `isOpen` so that it's not forwarded to the DOM, but remember not to use it directly\n        // since it may be stale (`renderTarget` is not re-invoked on this.state changes).\n        // eslint-disable-next-line react/display-name\n        ({ isOpen: _isOpen, ref, ...targetProps }: PopoverTargetProps & PopoverClickTargetHandlers) => {\n            const { disabled, filterable = true, popoverProps = {}, popoverTargetProps } = this.props;\n            const { handleKeyDown, handleKeyUp } = listProps;\n            const { targetTagName = \"div\" } = popoverProps;\n            return createElement(\n                targetTagName,\n                {\n                    \"aria-controls\": this.listboxId,\n                    ...popoverTargetProps,\n                    ...targetProps,\n                    \"aria-disabled\": disabled,\n                    \"aria-expanded\": isOpen,\n                    // When filterable, the InputGroup inside is the combobox; this trigger is just a button\n                    // When not filterable, this trigger is the combobox\n                    ...(filterable ? { \"aria-haspopup\": \"listbox\" } : {}),\n                    // Note that we must set FILL here in addition to children to get the wrapper element to full width\n                    className: classNames(targetProps.className, popoverTargetProps?.className, {\n                        [CoreClasses.FILL]: this.props.fill,\n                    }),\n                    // Normally, Popover would also need to attach its own `onKeyDown` handler via `targetProps`,\n                    // but in our case we fully manage that interaction and listen for key events to open/close\n                    // the popover, so we elide it from the DOM.\n                    onKeyDown: this.withPopoverTargetPropsHandler(\n                        \"keydown\",\n                        isOpen ? handleKeyDown : this.handleTargetKeyDown,\n                    ),\n                    onKeyUp: this.withPopoverTargetPropsHandler(\"keyup\", isOpen ? handleKeyUp : undefined),\n                    ref,\n                    role: filterable ? undefined : \"combobox\",\n                },\n                this.props.children,\n            );\n        };\n\n    private maybeRenderClearButton(query: string) {\n        return query.length > 0 ? (\n            <Button\n                aria-label=\"Clear filter query\"\n                icon={<Cross />}\n                onClick={this.resetQuery}\n                title=\"Clear filter query\"\n                variant=\"minimal\"\n            />\n        ) : undefined;\n    }\n\n    private withPopoverTargetPropsHandler = (\n        eventType: \"keydown\" | \"keyup\",\n        handler: React.KeyboardEventHandler<HTMLElement> | undefined,\n    ): React.KeyboardEventHandler<HTMLElement> => {\n        switch (eventType) {\n            case \"keydown\":\n                return event => {\n                    handler?.(event);\n                    this.props.popoverTargetProps?.onKeyDown?.(event);\n                };\n            case \"keyup\":\n                return event => {\n                    handler?.(event);\n                    this.props.popoverTargetProps?.onKeyUp?.(event);\n                };\n        }\n    };\n\n    /**\n     * Target wrapper element \"keydown\" handler while the popover is closed.\n     */\n    private handleTargetKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n        // open popover when arrow key pressed on target while closed\n        if (event.key === \"ArrowUp\" || event.key === \"ArrowDown\") {\n            event.preventDefault();\n            this.setState({ isOpen: true });\n        } else if (Utils.isKeyboardClick(event)) {\n            this.setState({ isOpen: true });\n        }\n    };\n\n    private handleItemSelect = (item: T, event?: React.SyntheticEvent<HTMLElement>) => {\n        const target = event?.target as HTMLElement;\n        const menuItem = target?.closest(`.${CoreClasses.MENU_ITEM}`);\n        const menuItemDismiss = menuItem?.matches(`.${CoreClasses.POPOVER_DISMISS}`);\n        const shouldDismiss = menuItemDismiss ?? true;\n\n        this.setState({ isOpen: !shouldDismiss });\n        this.props.onItemSelect?.(item, event);\n    };\n\n    private handlePopoverInteraction = (isOpen: boolean, event?: React.SyntheticEvent<HTMLElement>) => {\n        this.setState({ isOpen });\n        this.props.popoverProps?.onInteraction?.(isOpen, event);\n    };\n\n    private handlePopoverOpening = (node: HTMLElement) => {\n        // save currently focused element before popover steals focus, so we can restore it when closing.\n        this.previousFocusedElement = Utils.getActiveElement(this.inputElement) ?? undefined;\n\n        if (this.props.resetOnClose) {\n            this.resetQuery();\n        }\n\n        this.props.popoverProps?.onOpening?.(node);\n    };\n\n    private handlePopoverOpened = (node: HTMLElement) => {\n        // scroll active item into view after popover transition completes and all dimensions are stable.\n        if (this.queryList != null) {\n            this.queryList.scrollActiveItemIntoView();\n        }\n\n        this.requestAnimationFrame(() => {\n            const { inputProps = {} } = this.props;\n            // autofocus is enabled by default\n            if (inputProps.autoFocus !== false) {\n                this.inputElement?.focus();\n            }\n        });\n\n        this.props.popoverProps?.onOpened?.(node);\n    };\n\n    private handlePopoverClosing = (node: HTMLElement) => {\n        // restore focus to saved element.\n        // timeout allows popover to begin closing and remove focus handlers beforehand.\n        /* istanbul ignore next */\n        this.requestAnimationFrame(() => {\n            if (this.previousFocusedElement !== undefined) {\n                this.previousFocusedElement.focus();\n                this.previousFocusedElement = undefined;\n            }\n        });\n\n        this.props.popoverProps?.onClosing?.(node);\n    };\n\n    private resetQuery = () => this.queryList && this.queryList.setQuery(\"\", true);\n}\n", "/*\n * Copyright 2022 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\n\nimport {\n    AbstractPureComponent,\n    DISPLAYNAME_PREFIX,\n    InputGroup,\n    type InputGroupProps,\n    mergeRefs,\n    Popover,\n    type PopoverClickTargetHandlers,\n    type PopoverTargetProps,\n    PopupKind,\n    refHandler,\n    setRef,\n    Utils,\n} from \"@blueprintjs/core\";\n\nimport { Classes, type ListItemsProps, type SelectPopoverProps } from \"../../common\";\nimport { QueryList, type QueryListRendererProps } from \"../query-list/queryList\";\n\nexport interface SuggestProps<T> extends ListItemsProps<T>, Omit<SelectPopoverProps, \"popoverTargetProps\"> {\n    /**\n     * Whether the popover should close after selecting an item.\n     *\n     * @default true\n     */\n    closeOnSelect?: boolean;\n\n    /** Whether the input field should be disabled. */\n    disabled?: boolean;\n\n    /**\n     * Whether the component should take up the full width of its container.\n     */\n    fill?: boolean;\n\n    /**\n     * Props to pass to the query [InputGroup component](#core/components/input-group).\n     *\n     * Some properties are unavailable:\n     * - `inputProps.value`: use `query` instead\n     * - `inputProps.onChange`: use `onQueryChange` instead\n     * - `inputProps.disabled`: use `disabled` instead\n     * - `inputProps.fill`: use `fill` instead\n     *\n     * Other notes:\n     * - `inputProps.tagName` will override `popoverProps.targetTagName`\n     * - `inputProps.className` will work as expected, but this is redundant with the simpler `className` prop\n     */\n    inputProps?: Partial<Omit<InputGroupProps, \"disabled\" | \"fill\" | \"value\" | \"onChange\">>;\n\n    /** Custom renderer to transform an item into a string for the input value. */\n    inputValueRenderer: (item: T) => string;\n\n    /**\n     * The uncontrolled default selected item.\n     * This prop is ignored if `selectedItem` is used to control the state.\n     */\n    defaultSelectedItem?: T;\n\n    /**\n     * The currently selected item, or `null` to indicate that no item is selected.\n     * If omitted or `undefined`, this prop will be uncontrolled (managed by the component's state).\n     * Use `onItemSelect` to listen for updates.\n     */\n    selectedItem?: T | null;\n\n    /**\n     * HTML attributes to add to the `Menu` listbox containing the selectable options.\n     */\n    menuProps?: React.HTMLAttributes<HTMLUListElement>;\n\n    /**\n     * If true, the component waits until a keydown event in the TagInput\n     * before opening its popover.\n     *\n     * If false, the popover opens immediately after a mouse click or TAB key\n     * interaction focuses the component's TagInput.\n     *\n     * @default false\n     */\n    openOnKeyDown?: boolean;\n\n    /**\n     * Whether the active item should be reset to the first matching item _when\n     * the popover closes_. The query will also be reset to the empty string.\n     *\n     * @default false\n     */\n    resetOnClose?: boolean;\n}\n\nexport interface SuggestState<T> {\n    isOpen: boolean;\n    selectedItem: T | null;\n}\n\n/**\n * Suggest component.\n *\n * @see https://blueprintjs.com/docs/#select/suggest\n */\nexport class Suggest<T> extends AbstractPureComponent<SuggestProps<T>, SuggestState<T>> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Suggest`;\n\n    public static defaultProps: Partial<SuggestProps<any>> = {\n        closeOnSelect: true,\n        fill: false,\n        openOnKeyDown: false,\n        resetOnClose: false,\n    };\n\n    /** @deprecated no longer necessary now that the TypeScript parser supports type arguments on JSX element tags */\n    public static ofType<U>() {\n        return Suggest as new (props: SuggestProps<U>) => Suggest<U>;\n    }\n\n    public state: SuggestState<T> = {\n        isOpen: (this.props.popoverProps != null && this.props.popoverProps.isOpen) || false,\n        selectedItem: this.getInitialSelectedItem(),\n    };\n\n    public inputElement: HTMLInputElement | null = null;\n\n    private queryList: QueryList<T> | null = null;\n\n    private handleInputRef: React.Ref<HTMLInputElement> = refHandler(\n        this,\n        \"inputElement\",\n        this.props.inputProps?.inputRef,\n    );\n\n    private handleQueryListRef = (ref: QueryList<T> | null) => (this.queryList = ref);\n\n    private listboxId = Utils.uniqueId(\"listbox\");\n\n    public render() {\n        // omit props specific to this component, spread the rest.\n        const { disabled, inputProps, menuProps, popoverProps, ...restProps } = this.props;\n\n        return (\n            <QueryList<T>\n                {...restProps}\n                menuProps={{ \"aria-label\": \"selectable options\", ...menuProps, id: this.listboxId }}\n                initialActiveItem={this.props.selectedItem ?? undefined}\n                onItemSelect={this.handleItemSelect}\n                ref={this.handleQueryListRef}\n                renderer={this.renderQueryList}\n            />\n        );\n    }\n\n    public componentDidUpdate(prevProps: SuggestProps<T>, prevState: SuggestState<T>) {\n        if (prevProps.inputProps?.inputRef !== this.props.inputProps?.inputRef) {\n            setRef(prevProps.inputProps?.inputRef, null);\n            this.handleInputRef = refHandler(this, \"inputElement\", this.props.inputProps?.inputRef);\n            setRef(this.props.inputProps?.inputRef, this.inputElement);\n        }\n\n        // If the selected item prop changes, update the underlying state.\n        if (this.props.selectedItem !== undefined && this.props.selectedItem !== this.state.selectedItem) {\n            this.setState({ selectedItem: this.props.selectedItem });\n        }\n\n        if (this.state.isOpen === false && prevState.isOpen === true) {\n            // just closed, likely by keyboard interaction\n            // wait until the transition ends so there isn't a flash of content in the popover\n            const timeout = this.props.popoverProps?.transitionDuration ?? Popover.defaultProps.transitionDuration;\n            setTimeout(() => this.maybeResetActiveItemToSelectedItem(), timeout);\n        }\n\n        if (this.state.isOpen && !prevState.isOpen && this.queryList != null) {\n            this.queryList.scrollActiveItemIntoView();\n        }\n    }\n\n    private renderQueryList = (listProps: QueryListRendererProps<T>) => {\n        const { popoverContentProps = {}, popoverProps = {}, popoverRef } = this.props;\n        const { isOpen } = this.state;\n        const { handleKeyDown, handleKeyUp } = listProps;\n\n        // N.B. no need to set `popoverProps.fill` since that is unused with the `renderTarget` API\n        return (\n            <Popover\n                autoFocus={false}\n                enforceFocus={false}\n                isOpen={isOpen}\n                placement={popoverProps.position || popoverProps.placement ? undefined : \"bottom-start\"}\n                {...popoverProps}\n                className={classNames(listProps.className, popoverProps.className)}\n                content={\n                    <div {...popoverContentProps} onKeyDown={handleKeyDown} onKeyUp={handleKeyUp}>\n                        {listProps.itemList}\n                    </div>\n                }\n                interactionKind=\"click\"\n                onInteraction={this.handlePopoverInteraction}\n                onOpened={this.handlePopoverOpened}\n                onOpening={this.handlePopoverOpening}\n                popoverClassName={classNames(Classes.SUGGEST_POPOVER, popoverProps.popoverClassName)}\n                popupKind={PopupKind.LISTBOX}\n                ref={popoverRef}\n                renderTarget={this.getPopoverTargetRenderer(listProps, isOpen)}\n            />\n        );\n    };\n\n    // We use the renderTarget API to flatten the rendered DOM and make it easier to implement features like\n    // the \"fill\" prop. Note that we must take `isOpen` as an argument to force this render function to be called\n    // again after that state changes.\n    private getPopoverTargetRenderer =\n        (listProps: QueryListRendererProps<T>, isOpen: boolean) =>\n        // eslint-disable-next-line react/display-name\n        ({\n            // pull out `isOpen` so that it's not forwarded to the DOM\n            isOpen: _isOpen,\n            ref,\n            ...targetProps\n        }: PopoverTargetProps & PopoverClickTargetHandlers) => {\n            const { disabled, fill, inputProps = {}, inputValueRenderer, popoverProps = {}, resetOnClose } = this.props;\n            const { selectedItem } = this.state;\n            const { handleKeyDown, handleKeyUp } = listProps;\n\n            const selectedItemText = selectedItem == null ? \"\" : inputValueRenderer(selectedItem);\n            const { autoComplete = \"off\", placeholder = \"Search...\" } = inputProps;\n            // placeholder shows selected item while open.\n            const inputPlaceholder = isOpen && selectedItemText ? selectedItemText : placeholder;\n            // value shows query when open, and query remains when closed if nothing is selected.\n            // if resetOnClose is enabled, then hide query when not open. (see handlePopoverOpening)\n            const inputValue = isOpen\n                ? listProps.query\n                : selectedItemText === \"\"\n                  ? resetOnClose\n                      ? \"\"\n                      : listProps.query\n                  : selectedItemText;\n\n            return (\n                <InputGroup\n                    aria-controls={this.listboxId}\n                    autoComplete={autoComplete}\n                    disabled={disabled}\n                    tagName={popoverProps.targetTagName}\n                    {...targetProps}\n                    {...inputProps}\n                    aria-autocomplete=\"list\"\n                    aria-expanded={isOpen}\n                    className={classNames(targetProps.className, inputProps.className)}\n                    fill={fill}\n                    inputRef={mergeRefs(this.handleInputRef, ref)}\n                    onChange={listProps.handleQueryChange}\n                    onFocus={this.handleInputFocus}\n                    onKeyDown={this.getTargetKeyDownHandler(handleKeyDown)}\n                    onKeyUp={this.getTargetKeyUpHandler(handleKeyUp)}\n                    placeholder={inputPlaceholder}\n                    role=\"combobox\"\n                    value={inputValue}\n                />\n            );\n        };\n\n    private selectText = () => {\n        // wait until the input is properly focused to select the text inside of it\n        this.requestAnimationFrame(() => {\n            this.inputElement?.setSelectionRange(0, this.inputElement.value.length);\n        });\n    };\n\n    private handleInputFocus = (event: React.FocusEvent<HTMLInputElement>) => {\n        this.selectText();\n\n        // TODO can we leverage Popover.openOnTargetFocus for this?\n        if (!this.props.openOnKeyDown) {\n            this.setState({ isOpen: true });\n        }\n\n        this.props.inputProps?.onFocus?.(event);\n    };\n\n    private handleItemSelect = (item: T, event?: React.SyntheticEvent<HTMLElement>) => {\n        let nextOpenState: boolean;\n\n        if (!this.props.closeOnSelect) {\n            this.inputElement?.focus();\n            this.selectText();\n            nextOpenState = true;\n        } else {\n            this.inputElement?.blur();\n            nextOpenState = false;\n        }\n\n        // the internal state should only change when uncontrolled.\n        if (this.props.selectedItem === undefined) {\n            this.setState({\n                isOpen: nextOpenState,\n                selectedItem: item,\n            });\n        } else {\n            // otherwise just set the next open state.\n            this.setState({ isOpen: nextOpenState });\n        }\n\n        this.props.onItemSelect?.(item, event);\n    };\n\n    private getInitialSelectedItem(): T | null {\n        // controlled > uncontrolled > default\n        if (this.props.selectedItem !== undefined) {\n            return this.props.selectedItem;\n        } else if (this.props.defaultSelectedItem !== undefined) {\n            return this.props.defaultSelectedItem;\n        } else {\n            return null;\n        }\n    }\n\n    // Popover interaction kind is CLICK, so this only handles click events.\n    // Note that we defer to the next animation frame in order to get the latest activeElement\n    private handlePopoverInteraction = (nextOpenState: boolean, event?: React.SyntheticEvent<HTMLElement>) =>\n        this.requestAnimationFrame(() => {\n            const isInputFocused = this.inputElement === Utils.getActiveElement(this.inputElement);\n            if (this.inputElement != null && !isInputFocused) {\n                // the input is no longer focused, we should close the popover\n                this.setState({ isOpen: false });\n            }\n            this.props.popoverProps?.onInteraction?.(nextOpenState, event);\n        });\n\n    private handlePopoverOpening = (node: HTMLElement) => {\n        // reset query before opening instead of when closing to prevent flash of unfiltered items.\n        // this is a limitation of the interactions between QueryList state and Popover transitions.\n        if (this.props.resetOnClose && this.queryList) {\n            this.queryList.setQuery(\"\", true);\n        }\n        this.props.popoverProps?.onOpening?.(node);\n    };\n\n    private handlePopoverOpened = (node: HTMLElement) => {\n        // scroll active item into view after popover transition completes and all dimensions are stable.\n        if (this.queryList != null) {\n            this.queryList.scrollActiveItemIntoView();\n        }\n        this.props.popoverProps?.onOpened?.(node);\n    };\n\n    private getTargetKeyDownHandler = (\n        handleQueryListKeyDown: React.EventHandler<React.KeyboardEvent<HTMLElement>>,\n    ) => {\n        return (e: React.KeyboardEvent<HTMLInputElement>) => {\n            if (e.key === \"Escape\" || e.key === \"Tab\") {\n                // By default the escape key will not trigger a blur on the\n                // input element. It must be done explicitly.\n                if (e.key === \"Escape\") {\n                    this.inputElement?.blur();\n                }\n                this.setState({ isOpen: false });\n            } else if (\n                this.props.openOnKeyDown &&\n                e.key !== \"Backspace\" &&\n                e.key !== \"ArrowLeft\" &&\n                e.key !== \"ArrowRight\"\n            ) {\n                this.setState({ isOpen: true });\n            }\n\n            if (this.state.isOpen) {\n                handleQueryListKeyDown?.(e);\n            }\n\n            this.props.inputProps?.onKeyDown?.(e);\n        };\n    };\n\n    private getTargetKeyUpHandler = (handleQueryListKeyUp: React.EventHandler<React.KeyboardEvent<HTMLElement>>) => {\n        return (evt: React.KeyboardEvent<HTMLInputElement>) => {\n            if (this.state.isOpen) {\n                handleQueryListKeyUp?.(evt);\n            }\n            this.props.inputProps?.onKeyUp?.(evt);\n        };\n    };\n\n    private maybeResetActiveItemToSelectedItem() {\n        const shouldResetActiveItemToSelectedItem =\n            this.props.activeItem === undefined && this.state.selectedItem !== null && !this.props.resetOnSelect;\n\n        if (this.queryList !== null && shouldResetActiveItemToSelectedItem) {\n            this.queryList.setActiveItem(this.props.selectedItem ?? this.state.selectedItem);\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["classes_exports", "_jsxs", "_a", "_jsx", "classNames", "_jsxs", "_a", "classes_exports", "_b", "import_classnames", "import_react", "_jsx", "classNames", "classes_exports", "_jsxs", "_a", "import_classnames", "import_react", "_a", "_jsx", "classNames", "_jsxs", "classes_exports", "import_classnames", "_a", "_jsx", "classNames", "classes_exports"]
}
