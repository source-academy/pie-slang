import * as S from "../types/source";

import { SchemeLexer } from "../../scheme_parser/transpiler/lexer/scheme-lexer";
import { SchemeParser } from "../../scheme_parser/transpiler/parser/scheme-parser";

import { Extended, Atomic, Expression } from '../../scheme_parser/transpiler/types/nodes/scheme-node-types';
import { Location, Syntax } from "../utils/locations";
import { Location as Loc } from '../../scheme_parser/transpiler/types/location';
import { isVarName, SiteBinder, TypedBinder } from "../types/utils";
import { EliminateNatTactic, EliminateListTactic, ExactTactic, IntroTactic, Tactic } from "../tactics/tactics";
import { DefineDatatypeSource, GeneralConstructor } from "../typechecker/definedatatype";
import * as Maker from "./makers"

type Element = Extended.List | Atomic.Symbol | Atomic.NumericLiteral | Atomic.Nil;

// ### Helper functions

export function syntaxToLocation(syntax: Syntax): Location {
  return new Location(
    syntax,
    true,
  );
}

function syntaxToSiteBinder(syntax: Syntax): SiteBinder {
  return new SiteBinder(
    syntaxToLocation(syntax),
    syntax.source
  )
}

function getValue(element: Element): string {
  if (element instanceof Atomic.Symbol) {
    return element.value;
  } else if (element instanceof Atomic.NumericLiteral) {
    return element.value;
  } else if (element instanceof Extended.List) {
    return getValue(element.elements[0] as Element);
  } else {
    const elem = element as any;
    throw new Error(`Expected a Element, but got: ${JSON.stringify(elem)} (type: ${typeof elem}, constructor: ${elem?.constructor?.name})`);
  }
}

function locationToSyntax(source: string, location: Loc): Syntax {
  return new Syntax(
    location.start,
    location.end,
    source,
  );
}

function elementToSyntax(element: Element, location: Loc): Syntax {
  return locationToSyntax(getValue(element), location);
}

// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
export function schemeParse(stx: string): Extended.List[] {
  const lexer = new SchemeLexer(stx);
  const parser = new SchemeParser('', lexer.scanTokens());
  const ast: Extended.List[] = parser.parse() as Extended.List[];
  return ast;
}

export class Parser {
  public static parsePie(stx: string): S.Source {
    return Parser.parseElements(schemeParse(stx)[0]); 
  }

  public static parseElements(element: Element): S.Source {
    const parsee = getValue(element);
    if (parsee === 'U') {
      return Maker.makeU(locationToSyntax('U', element.location));
    } else if (parsee === 'the') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      return Maker.makeThe(
        locationToSyntax('the', loc),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'Nat') {
      return Maker.makeNat(locationToSyntax('Nat', element.location));
    } else if (parsee === 'zero') {
      return Maker.makeZero(locationToSyntax('zero', element.location));
    } else if (parsee === 'add1') {
      return Maker.makeAdd1(
        locationToSyntax('add1', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === '->' || parsee === '→') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      return Maker.makeArrow(
        locationToSyntax('->', loc),
        [
          this.parseElements(elements[1] as Element),
          this.parseElements(elements[2] as Element),
          elements.slice(3).map((x: Expression) => this.parseElements(x as Element))
        ]
      );
    } else if (parsee === 'lambda' || parsee === 'λ') {
      let elements = (element as Extended.List).elements;
      let loc = element.location;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;
      return Maker.makeLambda(
        locationToSyntax('λ', loc),
        args.elements.map(
          (x: Expression) =>
            syntaxToSiteBinder(
              elementToSyntax(x as Element, element.location)
            )
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Pi' || parsee === 'Π') {
      let elements = (element as Extended.List).elements;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;

      // Get first binding pair
      let firstPair = args.elements[0] as Extended.List;
      let x0 = firstPair.elements[0] as Element;
      let A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      let remainingPairs = args.elements.slice(1) as Extended.List[];
      let processedPairs = remainingPairs.map(pair => {
        let x = pair.elements[0] as Element;
        let A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makePi(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Sigma' || parsee === 'Σ') {
      let elements = (element as Extended.List).elements;
      let args = elements[1] as Extended.List;
      let body = elements[2] as Element;

      // Get first binding pair
      let firstPair = args.elements[0] as Extended.List;
      let x0 = firstPair.elements[0] as Element;
      let A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      let remainingPairs = args.elements.slice(1) as Extended.List[];
      let processedPairs = remainingPairs.map(pair => {
        let x = pair.elements[0] as Element;
        let A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makeSigma(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body));
    } else if (parsee === 'Pair') {
      let elements = (element as Extended.List).elements;
      return Maker.makePair(
        locationToSyntax('Pair', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'cons') {
      let elements = (element as Extended.List).elements;
      return Maker.makeCons(
        locationToSyntax('Cons', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'car') {
      return Maker.makeCar(
        locationToSyntax('car', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'cdr') {
      return Maker.makeCdr(
        locationToSyntax('cdr', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'which-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeWhichNat(
        locationToSyntax('which-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'iter-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIterNat(
        locationToSyntax('iter-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'rec-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeRecNat(
        locationToSyntax('rec-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-Nat') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndNat(
        locationToSyntax('ind-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Atom') {
      return Maker.makeAtom(locationToSyntax('Atom', element.location));
    } else if (parsee === 'quote') {
      return Maker.makeQuote(
        locationToSyntax('Quote', element.location),
        getValue((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'Trivial') {
      return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
    } else if (parsee === 'sole') {
      return Maker.makeSole(locationToSyntax('sole', element.location));
    } else if (parsee === 'List') {
      return Maker.makeList(
        locationToSyntax('List', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'nil') {
      return Maker.makeNil(locationToSyntax('nil', element.location));
    } else if (parsee === '::') {
      let elements = (element as Extended.List).elements;
      return Maker.makeListCons(
        locationToSyntax('::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'rec-List') {
      let elements = (element as Extended.List).elements;
      return Maker.makeRecList(
        locationToSyntax('rec-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-List') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndList(
        locationToSyntax('ind-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === '=') {
      let elements = (element as Extended.List).elements;
      return Maker.makeEqual(
        locationToSyntax('=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'same') {
      return Maker.makeSame(
        locationToSyntax('same', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'replace') {
      let elements = (element as Extended.List).elements;
      return Maker.makeReplace(
        locationToSyntax('replace', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'trans') {
      let elements = (element as Extended.List).elements;
      return Maker.makeTrans(
        locationToSyntax('trans', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'cong') {
      let elements = (element as Extended.List).elements;
      return Maker.makeCong(
        locationToSyntax('cong', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'ind-=') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndEqual(
        locationToSyntax('ind-=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'symm') {
      return Maker.makeSymm(
        locationToSyntax('symm', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'Vec') {
      let elements = (element as Extended.List).elements;
      return Maker.makeVec(
        locationToSyntax('Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'vecnil') {
      return Maker.makeVecNil(
        locationToSyntax('vecnil', element.location),
      );
    } else if (parsee === 'vec::') {
      let elements = (element as Extended.List).elements;
      return Maker.makeVecCons(
        locationToSyntax('vec::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'head') {
      return Maker.makeHead(
        locationToSyntax('head', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'tail') {
      return Maker.makeTail(
        locationToSyntax('tail', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Vec') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndVec(
        locationToSyntax('ind-Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
        this.parseElements(elements[5] as Element),
      );
    } else if (parsee === 'Either') {
      let elements = (element as Extended.List).elements;
      return Maker.makeEither(
        locationToSyntax('Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'left') {
      return Maker.makeLeft(
        locationToSyntax('left', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    }
    else if (parsee === 'right') {
      return Maker.makeRight(
        locationToSyntax('right', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Either') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndEither(
        locationToSyntax('ind-Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Absurd') {
      return Maker.makeAbsurd(
        locationToSyntax('Absurd', element.location),
      );
    } else if (parsee === 'ind-Absurd') {
      let elements = (element as Extended.List).elements;
      return Maker.makeIndAbsurd(
        locationToSyntax('ind-Absurd', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'TODO') {
      return Maker.makeTODO(locationToSyntax('TODO', element.location));
    } else if (parsee.startsWith('type-')) {
      // General type constructor application: (type-TypeName (params...) (indices...))
      const typeName = parsee.substring(5); // Remove 'type-' prefix
      const elements = (element as Extended.List).elements;

      if (elements.length < 3) {
        throw new Error(`Type constructor ${parsee} requires parameters and indices lists`);
      }

      // Parse parameters: (Nat) or (E) or (Nat Atom) or ()
      const paramsElem = elements[1];
      let params: S.Source[] = [];
      if (paramsElem instanceof Extended.List) {
        params = (paramsElem.elements || []).map(p => this.parseElements(p as Element));
      } else if (paramsElem instanceof Atomic.Nil) {
        params = []; // Empty list
      }

      // Parse indices: (zero) or (j k) or ()
      const indicesElem = elements[2];
      let indices: S.Source[] = [];
      if (indicesElem instanceof Extended.List) {
        indices = (indicesElem.elements || []).map(idx => this.parseElements(idx as Element));
      } else if (indicesElem instanceof Atomic.Nil) {
        indices = []; // Empty list
      }

      return Maker.makeGeneralTypeConstructor(
        locationToSyntax(typeName, element.location),
        typeName,
        params,
        indices
      );
    } else if (parsee.startsWith('data-')) {
      // Constructor application: (data-constructor-name arg1 arg2...)
      const constructorName = parsee.substring(5); // Remove 'data-' prefix
      const elements = (element as Extended.List).elements;
      const args = elements.slice(1).map(x => this.parseElements(x as Element));
      return Maker.makeConstructorApplication(
        locationToSyntax(constructorName, element.location),
        constructorName,
        args
      );
    } else if (parsee.startsWith('elim-')) {
      // Eliminator application: (elim-TypeName target motive methods...)
      const typeName = parsee.substring(5); // Remove 'elim-' prefix
      const elements = (element as Extended.List).elements;

      if (elements.length < 3) {
        throw new Error(`Eliminator ${parsee} requires at least target and motive`);
      }

      const target = this.parseElements(elements[1] as Element);
      const motive = this.parseElements(elements[2] as Element);
      const methods = elements.slice(3).map(x => this.parseElements(x as Element));

      return Maker.makeEliminatorApplication(
        locationToSyntax(parsee, element.location),
        typeName,
        target,
        motive,
        methods
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length >= 3) {
      let elements = (element as Extended.List).elements;
      const firstElem = elements[0];

      // Check if this is a GeneralTypeConstructor without type- prefix
      // (used in constructor return types): (TypeName (params) (indices))
      if (firstElem instanceof Atomic.Symbol) {
        const name = firstElem.value;
        // If starts with capital letter and has 3 elements, might be type constructor
        if (name && name[0] === name[0].toUpperCase() && name[0] !== name[0].toLowerCase() && elements.length === 3) {
          const secondElem = elements[1];
          const thirdElem = elements[2];

          // Check if second and third are lists or nils (param/index lists)
          if ((secondElem instanceof Extended.List || secondElem instanceof Atomic.Nil) &&
              (thirdElem instanceof Extended.List || thirdElem instanceof Atomic.Nil)) {
            // Parse as GeneralTypeConstructor
            let params: S.Source[] = [];
            if (secondElem instanceof Extended.List) {
              params = (secondElem.elements || []).map(p => this.parseElements(p as Element));
            }

            let indices: S.Source[] = [];
            if (thirdElem instanceof Extended.List) {
              indices = (thirdElem.elements || []).map(idx => this.parseElements(idx as Element));
            }

            return Maker.makeGeneralTypeConstructor(
              locationToSyntax(name, element.location),
              name,
              params,
              indices
            );
          }
        }
      }

      // Otherwise, parse as application
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length > 1) {
      // Application with 2 elements
      let elements = (element as Extended.List).elements;
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (isVarName(parsee)) {
      return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
    } else if (!isNaN(Number(parsee))) { // numeric literal
      return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
    }
    throw new Error('Unexpected element: ' + element);
  }

  public static parseToTactics(element: Element): Tactic {
    const parsee = getValue(element);
    if (parsee === 'exact') {
      return Maker.makeExact(
        locationToSyntax('exact', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'intro') {
      return Maker.makeIntro(
        locationToSyntax('intro', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'exists') {
      return Maker.makeExists(
        locationToSyntax('exists', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
        ((element as Extended.List).elements[2] as Atomic.Symbol).value
      );
    } else if (parsee === 'elimNat') {
      return Maker.makeElimNat(
        locationToSyntax('elimNat', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'elimList') {
      const listElem = element as Extended.List;
      return Maker.makeElimList(
        locationToSyntax('elimList', element.location),
        (listElem.elements[1] as Atomic.Symbol).value,
        listElem.elements[2] ? this.parseElements(listElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'elimVec') {
      return Maker.makeElimVec(
        locationToSyntax('elimVec', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element),
        this.parseElements((element as Extended.List).elements[3] as Element))
    } else if (parsee === 'elimEqual') {
      const equalElem = element as Extended.List;
      return Maker.makeElimEqual(
        locationToSyntax('elimEqual', element.location),
        (equalElem.elements[1] as Atomic.Symbol).value,
        equalElem.elements[2] ? this.parseElements(equalElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'left') {
      return Maker.makeLeftTactic(
        locationToSyntax('left', element.location)
      );
    } else if (parsee === 'right') {
      return Maker.makeRightTactic(
        locationToSyntax('right', element.location)
      );
    } else if (parsee === 'elimEither') {
      const eitherElem = element as Extended.List;
      return Maker.makeElimEither(
        locationToSyntax('elimEither', element.location),
        (eitherElem.elements[1] as Atomic.Symbol).value,
        eitherElem.elements[2] ? this.parseElements(eitherElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'split') {
      return Maker.makeSplit(
        locationToSyntax('split', element.location)
      );
    } else if (parsee === 'elimAbsurd') {
      const absurdElem = element as Extended.List;
      return Maker.makeElimAbsurd(
        locationToSyntax('elimAbsurd', element.location),
        (absurdElem.elements[1] as Atomic.Symbol).value,
        absurdElem.elements[2] ? this.parseElements(absurdElem.elements[2] as Element) : undefined
      );
    } 
    throw new Error('Unexpected tactic: ' + element);
}
}



// ### Helper functions for parsing the AST

export class Claim {
  constructor (
    public location: Location,
    public name: string,
    public type: S.Source
  ) {}
}

export class Definition {
  constructor (
    public location: Location,
    public name: string,
    public expr: S.Source
  ) {}
}

export class SamenessCheck {
  constructor (
    public location: Location,
    public type: S.Source,
    public left: S.Source,
    public right: S.Source
  ) {}
}

export class DefineTactically {
  constructor (
    public location: Location,
    public name: string,
    public tactics: Tactic[]
  ) {}
}



export type Declaration = Claim | Definition | SamenessCheck | DefineTactically | DefineDatatypeSource | S.Source;


export class pieDeclarationParser {
  public static parseDeclaration(ast: Extended.List): Declaration {
    const parsee = getValue(ast);
    if (parsee === 'claim') {
      let elements = (ast as Extended.List).elements;
      return new Claim(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'define') {
      let elements = (ast as Extended.List).elements;
      return new Definition(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'check-same') {
      let elements = (ast as Extended.List).elements;
      return new SamenessCheck(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        Parser.parseElements(elements[1] as Element),
        Parser.parseElements(elements[2] as Element),
        Parser.parseElements(elements[3] as Element)
      );
    } else if (parsee === 'define-tactically') {
      let elements = (ast as Extended.List).elements;
      return new DefineTactically(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        (elements[2] as Extended.List).elements.map((x: Expression) => Parser.parseToTactics(x as Element))
      );
    } else if (parsee === 'data') {
      let elements = (ast as Extended.List).elements;
      let loc = ast.location;

      // elements[0] = 'data' (keyword)
      // elements[1] = type name (e.g., 'Less-Than')
      // elements[2] = parameters list (e.g., () or ((E U)))
      // elements[3] = indices list (e.g., ((j Nat) (k Nat)))
      // elements[4...n-1] = constructor definitions
      // elements[n] = eliminator name (optional, e.g., 'ind-Less-Than')

      const typeName = getValue(elements[1] as Element);
      const paramsRaw = (elements[2] as Extended.List).elements || [];
      const indicesRaw = (elements[3] as Extended.List).elements || [];

      // Parse parameters: ((E U)) -> [TypedBinder(E, U)]
      const parameters = paramsRaw.map(p => {
        const pair = p as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Parse indices: ((j Nat) (k Nat)) -> [TypedBinder(j, Nat), TypedBinder(k, Nat)]
      const indices = indicesRaw.map(idx => {
        const pair = idx as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Find where constructors end (last element might be eliminator name)
      const lastElement = elements[elements.length - 1];
      const hasEliminator = lastElement instanceof Atomic.Symbol;
      const constructorEndIdx = hasEliminator ? elements.length - 1 : elements.length;
      const eliminatorName = hasEliminator ? getValue(lastElement as Element) : undefined;

      // Parse constructors: (constructor-name ((args...)) (ReturnType ...))
      const constructors = [];
      for (let i = 4; i < constructorEndIdx; i++) {
        const ctorElement = elements[i] as Extended.List;
        const ctorName = getValue(ctorElement.elements[0] as Element);
        const ctorArgsRaw = (ctorElement.elements[1] as Extended.List).elements || [];
        const ctorReturnType = ctorElement.elements[2] as Element;

        // Parse constructor arguments: ((n Nat)) or ((j Nat) (k Nat) (j<k (type-Less-Than () (j k))))
        const ctorArgs = ctorArgsRaw.map(arg => {
          const pair = arg as Extended.List;
          const argType = pair.elements[1] as Element;

          // Parse the argument type using standard parsing
          const parsedArgType: S.Source = Parser.parseElements(argType);

          return new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
            parsedArgType
          );
        });

        // Parse return type: (TypeName (params...) (indices...))
        // Note: Constructor return types do NOT use type- prefix
        const returnTypeList = ctorReturnType as Extended.List;
        const returnTypeName = getValue(returnTypeList.elements[0] as Element);

        if (returnTypeList.elements.length < 3) {
          throw new Error(`Constructor return type must specify parameters and indices: (${returnTypeName} (params...) (indices...))`);
        }

        // Parse parameters list
        const returnParamsElem = returnTypeList.elements[1];
        let returnParams: S.Source[] = [];
        if (returnParamsElem instanceof Extended.List) {
          returnParams = (returnParamsElem.elements || []).map(p => Parser.parseElements(p as Element));
        } else if (returnParamsElem instanceof Atomic.Nil) {
          returnParams = []; // Empty list
        }

        // Parse indices list
        const returnIndicesElem = returnTypeList.elements[2];
        let returnIndices: S.Source[] = [];
        if (returnIndicesElem instanceof Extended.List) {
          returnIndices = (returnIndicesElem.elements || []).map(idx => Parser.parseElements(idx as Element));
        } else if (returnIndicesElem instanceof Atomic.Nil) {
          returnIndices = []; // Empty list
        }

        const returnType = Maker.makeGeneralTypeConstructor(
          elementToSyntax(returnTypeList.elements[0] as Element, returnTypeList.location),
          returnTypeName,
          returnParams,
          returnIndices
        );

        constructors.push(
          new GeneralConstructor(
            syntaxToLocation(elementToSyntax(ctorElement.elements[0] as Element, ctorElement.location)),
            ctorName,
            ctorArgs,
            returnType
          )
        );
      }

      return new DefineDatatypeSource(
        syntaxToLocation(elementToSyntax(elements[0] as Element, loc)),
        typeName,
        parameters,
        indices,
        constructors,
        eliminatorName
      );
    } else {
      return Parser.parseElements(ast);
    }
  }
}