import * as S from "../types/source";

import { SchemeLexer } from "../../scheme-parser/transpiler/lexer/scheme-lexer";
import { SchemeParser } from "../../scheme-parser/transpiler/parser/scheme-parser";

import {
  Extended, Atomic, Expression
} from '../../scheme-parser/transpiler/types/nodes/scheme-node-types';
import { Location, Syntax } from "../utils/locations";
import { Location as Loc } from '../../scheme-parser/transpiler/types/location';
import { isVarName, SiteBinder, TypedBinder } from "../types/utils";
import { Tactic } from "../tactics/tactics";
import { TypeDefinition, GeneralConstructor } from "../typechecker/type-definition";
import * as Maker from "./makers"

type Element = Extended.List | Atomic.Symbol | Atomic.NumericLiteral | Atomic.Nil;

// ### Helper functions

export function syntaxToLocation(syntax: Syntax): Location {
  return new Location(
    syntax,
    true,
  );
}

function syntaxToSiteBinder(syntax: Syntax): SiteBinder {
  return new SiteBinder(
    syntaxToLocation(syntax),
    syntax.source
  )
}

function getValue(element: Element): string {
  if (element instanceof Atomic.Symbol) {
    return element.value;
  } else if (element instanceof Atomic.NumericLiteral) {
    return element.value;
  } else if (element instanceof Extended.List) {
    return getValue(element.elements[0] as Element);
  } else if (element instanceof Atomic.Nil) {
    // Empty list - return empty string or some placeholder
    return "()";
  } else {
    const _exaustiveCheck: never = element;
    throw new Error('Unexpected element type in getValue: ' + _exaustiveCheck);
  }
}

function locationToSyntax(source: string, location: Loc): Syntax {
  return new Syntax(
    location.start,
    location.end,
    source,
  );
}

function elementToSyntax(element: Element, location: Loc): Syntax {
  return locationToSyntax(getValue(element), location);
}

// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
export function schemeParse(stx: string): Extended.List[] {
  const lexer = new SchemeLexer(stx);
  const parser = new SchemeParser('', lexer.scanTokens());
  const ast: Extended.List[] = parser.parse() as Extended.List[];
  return ast;
}

export class Parser {
  public static parsePie(stx: string): S.Source {
    return Parser.parseElements(schemeParse(stx)[0]);
  }

  public static parseElements(element: Element): S.Source {
    const parsee = getValue(element);
    if (parsee === 'U') {
      return Maker.makeU(locationToSyntax('U', element.location));
    } else if (parsee === 'the') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      return Maker.makeThe(
        locationToSyntax('the', loc),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'Nat') {
      return Maker.makeNat(locationToSyntax('Nat', element.location));
    } else if (parsee === 'zero') {
      return Maker.makeZero(locationToSyntax('zero', element.location));
    } else if (parsee === 'add1') {
      return Maker.makeAdd1(
        locationToSyntax('add1', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === '->' || parsee === '→') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      return Maker.makeArrow(
        locationToSyntax('->', loc),
        [
          this.parseElements(elements[1] as Element),
          this.parseElements(elements[2] as Element),
          elements.slice(3).map((x: Expression) => this.parseElements(x as Element))
        ]
      );
    } else if (parsee === 'lambda' || parsee === 'λ') {
      const elements = (element as Extended.List).elements;
      const loc = element.location;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;
      return Maker.makeLambda(
        locationToSyntax('λ', loc),
        args.elements.map(
          (x: Expression) =>
            syntaxToSiteBinder(
              elementToSyntax(x as Element, element.location)
            )
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Pi' || parsee === 'Π') {
      const elements = (element as Extended.List).elements;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;

      // Get first binding pair
      const firstPair = args.elements[0] as Extended.List;
      const x0 = firstPair.elements[0] as Element;
      const A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      const remainingPairs = args.elements.slice(1) as Extended.List[];
      const processedPairs = remainingPairs.map(pair => {
        const x = pair.elements[0] as Element;
        const A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makePi(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body)
      );
    } else if (parsee === 'Sigma' || parsee === 'Σ') {
      const elements = (element as Extended.List).elements;
      const args = elements[1] as Extended.List;
      const body = elements[2] as Element;

      // Get first binding pair
      const firstPair = args.elements[0] as Extended.List;
      const x0 = firstPair.elements[0] as Element;
      const A0 = firstPair.elements[1] as Element;

      // Process remaining binding pairs
      const remainingPairs = args.elements.slice(1) as Extended.List[];
      const processedPairs = remainingPairs.map(pair => {
        const x = pair.elements[0] as Element;
        const A = pair.elements[1] as Element;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(x, pair.location)),
          this.parseElements(A)
        );
      });
      return Maker.makeSigma(
        locationToSyntax('Π', (element as Extended.List).location),
        Maker.makeTypedBinders(
          new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)),
            this.parseElements(A0)
          ),
          processedPairs
        ),
        this.parseElements(body));
    } else if (parsee === 'Pair') {
      const elements = (element as Extended.List).elements;
      return Maker.makePair(
        locationToSyntax('Pair', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'cons') {
      const elements = (element as Extended.List).elements;
      return Maker.makeCons(
        locationToSyntax('Cons', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'car') {
      return Maker.makeCar(
        locationToSyntax('car', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'cdr') {
      return Maker.makeCdr(
        locationToSyntax('cdr', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'which-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeWhichNat(
        locationToSyntax('which-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'iter-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIterNat(
        locationToSyntax('iter-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'rec-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeRecNat(
        locationToSyntax('rec-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-Nat') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndNat(
        locationToSyntax('ind-Nat', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Atom') {
      return Maker.makeAtom(locationToSyntax('Atom', element.location));
    } else if (parsee === 'quote') {
      return Maker.makeQuote(
        locationToSyntax('Quote', element.location),
        getValue((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'Trivial') {
      return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
    } else if (parsee === 'sole') {
      return Maker.makeSole(locationToSyntax('sole', element.location));
    } else if (parsee === 'List') {
      return Maker.makeList(
        locationToSyntax('List', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'nil') {
      return Maker.makeNil(locationToSyntax('nil', element.location));
    } else if (parsee === '::') {
      const elements = (element as Extended.List).elements;
      return Maker.makeListCons(
        locationToSyntax('::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'rec-List') {
      const elements = (element as Extended.List).elements;
      return Maker.makeRecList(
        locationToSyntax('rec-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'ind-List') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndList(
        locationToSyntax('ind-List', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === '=') {
      const elements = (element as Extended.List).elements;
      return Maker.makeEqual(
        locationToSyntax('=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'same') {
      return Maker.makeSame(
        locationToSyntax('same', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'replace') {
      const elements = (element as Extended.List).elements;
      return Maker.makeReplace(
        locationToSyntax('replace', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'trans') {
      const elements = (element as Extended.List).elements;
      return Maker.makeTrans(
        locationToSyntax('trans', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'cong') {
      const elements = (element as Extended.List).elements;
      return Maker.makeCong(
        locationToSyntax('cong', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'ind-=') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndEqual(
        locationToSyntax('ind-=', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
      );
    } else if (parsee === 'symm') {
      return Maker.makeSymm(
        locationToSyntax('symm', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'Vec') {
      const elements = (element as Extended.List).elements;
      return Maker.makeVec(
        locationToSyntax('Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'vecnil') {
      return Maker.makeVecNil(
        locationToSyntax('vecnil', element.location),
      );
    } else if (parsee === 'vec::') {
      const elements = (element as Extended.List).elements;
      return Maker.makeVecCons(
        locationToSyntax('vec::', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'head') {
      return Maker.makeHead(
        locationToSyntax('head', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'tail') {
      return Maker.makeTail(
        locationToSyntax('tail', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Vec') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndVec(
        locationToSyntax('ind-Vec', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
        this.parseElements(elements[5] as Element),
      );
    } else if (parsee === 'Either') {
      const elements = (element as Extended.List).elements;
      return Maker.makeEither(
        locationToSyntax('Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'left') {
      return Maker.makeLeft(
        locationToSyntax('left', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    }
    else if (parsee === 'right') {
      return Maker.makeRight(
        locationToSyntax('right', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
      );
    } else if (parsee === 'ind-Either') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndEither(
        locationToSyntax('ind-Either', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
        this.parseElements(elements[3] as Element),
        this.parseElements(elements[4] as Element),
      );
    } else if (parsee === 'Absurd') {
      return Maker.makeAbsurd(
        locationToSyntax('Absurd', element.location),
      );
    } else if (parsee === 'ind-Absurd') {
      const elements = (element as Extended.List).elements;
      return Maker.makeIndAbsurd(
        locationToSyntax('ind-Absurd', element.location),
        this.parseElements(elements[1] as Element),
        this.parseElements(elements[2] as Element),
      );
    } else if (parsee === 'TODO') {
      return Maker.makeTODO(locationToSyntax('TODO', element.location));
    } else if (parsee.startsWith('ind-') && element instanceof Extended.List && element.elements[0] instanceof Atomic.Symbol) {
      // Eliminator application: (ind-TypeName target motive methods...)
      // Only match if first element is directly a symbol (not a nested list)
      const typeName = parsee.substring(4); // Remove 'ind-' prefix
      const elements = (element as Extended.List).elements;

      if (elements.length < 3) {
        throw new Error(`Eliminator ${parsee} requires at least target and motive`);
      }

      const target = this.parseElements(elements[1] as Element);
      const motive = this.parseElements(elements[2] as Element);
      const methods = elements.slice(3).map(x => this.parseElements(x as Element));

      return Maker.makeEliminatorApplication(
        locationToSyntax(parsee, element.location),
        typeName,
        target,
        motive,
        methods
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length >= 3) {
      const elements = (element as Extended.List).elements;
      const firstElem = elements[0];

      // Check if this is a GeneralTypeConstructor without prefix
      // (used in constructor return types OR in user code): (TypeName (params) (indices))
      // We require type names to start with a capital letter
      if (firstElem instanceof Atomic.Symbol) {
        const name = firstElem.value;
        // If starts with capital letter and has exactly 3 elements, might be type constructor
        if (name && name[0] === name[0].toUpperCase() && name[0] !== name[0].toLowerCase() && elements.length === 3) {
          const secondElem = elements[1];
          const thirdElem = elements[2];

          // Check if second and third are lists or nils (param/index lists)
          if ((secondElem instanceof Extended.List || secondElem instanceof Atomic.Nil) &&
              (thirdElem instanceof Extended.List || thirdElem instanceof Atomic.Nil)) {
            // Parse as GeneralTypeConstructor
            let params: S.Source[] = [];
            if (secondElem instanceof Extended.List) {
              params = (secondElem.elements || []).map(p => this.parseElements(p as Element));
            }

            let indices: S.Source[] = [];
            if (thirdElem instanceof Extended.List) {
              indices = (thirdElem.elements || []).map(idx => this.parseElements(idx as Element));
            }

            return Maker.makeGeneralTypeConstructor(
              locationToSyntax(name, element.location),
              name,
              params,
              indices
            );
          }
        }
      }

      // Otherwise, parse as application
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length > 1) {
      // For lists with 2+ elements, parse as Application by default
      // The typechecker will disambiguate between function application and constructor application
      const elements = (element as Extended.List).elements;
      return Maker.makeApp(
        locationToSyntax('App', element.location),
        this.parseElements(elements[0] as Element),
        this.parseElements(elements[1] as Element),
        elements.slice(2).map((x: Expression) => this.parseElements(x as Element)
        )
      );
    } else if (element instanceof Extended.List && (element as Extended.List).elements.length === 1) {
      // Single-element lists like (zero-even) - could be zero-argument constructor
      // Parse as ConstructorApplication with empty args
      // The typechecker will validate if it's actually a constructor
      const elements = (element as Extended.List).elements;
      const name = getValue(elements[0] as Element);
      return Maker.makeConstructorApplication(
        locationToSyntax(name, element.location),
        name,
        []
      );
    } else if (isVarName(parsee)) {
      return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
    } else if (!isNaN(Number(parsee))) { // numeric literal
      return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
    }
    throw new Error('Unexpected element: ' + element);
  }

  public static parseToTactics(element: Element): Tactic {
    const parsee = getValue(element);
    if (parsee === 'exact') {
      return Maker.makeExact(
        locationToSyntax('exact', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    } else if (parsee === 'intro') {
      return Maker.makeIntro(
        locationToSyntax('intro', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'exists') {
      return Maker.makeExists(
        locationToSyntax('exists', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element),
        ((element as Extended.List).elements[2] as Atomic.Symbol).value
      );
    } else if (parsee === 'elim-Nat') {
      return Maker.makeElimNat(
        locationToSyntax('elim-Nat', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value
      );
    } else if (parsee === 'elim-List') {
      const listElem = element as Extended.List;
      return Maker.makeElimList(
        locationToSyntax('elim-List', element.location),
        (listElem.elements[1] as Atomic.Symbol).value,
        listElem.elements[2] ? this.parseElements(listElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'elim-Vec') {
      return Maker.makeElimVec(
        locationToSyntax('elim-Vec', element.location),
        ((element as Extended.List).elements[1] as Atomic.Symbol).value,
        this.parseElements((element as Extended.List).elements[2] as Element),
        this.parseElements((element as Extended.List).elements[3] as Element))
    } else if (parsee === 'elim-Equal') {
      const equalElem = element as Extended.List;
      return Maker.makeElimEqual(
        locationToSyntax('elim-Equal', element.location),
        (equalElem.elements[1] as Atomic.Symbol).value,
        equalElem.elements[2] ? this.parseElements(equalElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'go-Left') {
      return Maker.makeLeftTactic(
        locationToSyntax('go-Left', element.location)
      );
    } else if (parsee === 'go-Right') {
      return Maker.makeRightTactic(
        locationToSyntax('go-Right', element.location)
      );
    } else if (parsee === 'elim-Either') {
      const eitherElem = element as Extended.List;
      return Maker.makeElimEither(
        locationToSyntax('elim-Either', element.location),
        (eitherElem.elements[1] as Atomic.Symbol).value,
        eitherElem.elements[2] ? this.parseElements(eitherElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'split-Pair') {
      return Maker.makeSplit(
        locationToSyntax('split-Pair', element.location)
      );
    } else if (parsee === 'elim-Absurd') {
      const absurdElem = element as Extended.List;
      return Maker.makeElimAbsurd(
        locationToSyntax('elim-Absurd', element.location),
        (absurdElem.elements[1] as Atomic.Symbol).value,
        absurdElem.elements[2] ? this.parseElements(absurdElem.elements[2] as Element) : undefined
      );
    } else if (parsee === 'then') {
      const thenElem = element as Extended.List;
      // Parse all tactics inside the then block (elements[1], elements[2], ...)
      const innerTactics = thenElem.elements.slice(1).map((x: Expression) => this.parseToTactics(x as Element));
      return Maker.makeThenTactic(
        locationToSyntax('then', element.location),
        innerTactics
      );
    } else if (parsee === 'apply') {
      return Maker.makeApplyTactic(
        locationToSyntax('apply', element.location),
        this.parseElements((element as Extended.List).elements[1] as Element)
      );
    }
    throw new Error('Unexpected tactic: ' + element);
  }
}



// ### Helper functions for parsing the AST

export class Claim {
  constructor(
    public location: Location,
    public name: string,
    public type: S.Source
  ) { }
}

export class Definition {
  constructor(
    public location: Location,
    public name: string,
    public expr: S.Source
  ) { }
}

export class SamenessCheck {
  constructor(
    public location: Location,
    public type: S.Source,
    public left: S.Source,
    public right: S.Source
  ) { }
}

export class DefineTactically {
  constructor(
    public location: Location,
    public name: string,
    public tactics: Tactic[]
  ) { }
}



export type Declaration = Claim | Definition | SamenessCheck | DefineTactically | TypeDefinition | S.Source;


export class pieDeclarationParser {
  public static parseDeclaration(ast: Extended.List): Declaration {
    const parsee = getValue(ast);
    if (parsee === 'claim') {
      const elements = (ast as Extended.List).elements;
      return new Claim(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'define') {
      const elements = (ast as Extended.List).elements;
      return new Definition(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        Parser.parseElements(elements[2] as Element)
      );
    } else if (parsee === 'check-same') {
      const elements = (ast as Extended.List).elements;
      return new SamenessCheck(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        Parser.parseElements(elements[1] as Element),
        Parser.parseElements(elements[2] as Element),
        Parser.parseElements(elements[3] as Element)
      );
    } else if (parsee === 'define-tactically') {
      const elements = (ast as Extended.List).elements;
      return new DefineTactically(
        syntaxToLocation(elementToSyntax(elements[0] as Element, ast.location)),
        getValue(elements[1] as Element),
        (elements[2] as Extended.List).elements.map((x: Expression) => Parser.parseToTactics(x as Element))
      );
    } else if (parsee === 'data') {
      const elements = (ast as Extended.List).elements;
      const loc = ast.location;

      // elements[0] = 'data' (keyword)
      // elements[1] = type name (e.g., 'Less-Than')
      // elements[2] = parameters list (e.g., () or ((E U)))
      // elements[3] = indices list (e.g., ((j Nat) (k Nat)))
      // elements[4...n-1] = constructor definitions
      // elements[n] = eliminator name (optional, e.g., 'ind-Less-Than')

      const typeName = getValue(elements[1] as Element);
      const paramsRaw = (elements[2] as Extended.List).elements || [];
      const indicesRaw = (elements[3] as Extended.List).elements || [];

      // Parse parameters: ((E U)) -> [TypedBinder(E, U)]
      const parameters = paramsRaw.map(p => {
        const pair = p as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Parse indices: ((j Nat) (k Nat)) -> [TypedBinder(j, Nat), TypedBinder(k, Nat)]
      const indices = indicesRaw.map(idx => {
        const pair = idx as Extended.List;
        return new TypedBinder(
          syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
          Parser.parseElements(pair.elements[1] as Element)
        );
      });

      // Find where constructors end (last element might be eliminator name)
      const lastElement = elements[elements.length - 1];
      const hasEliminator = lastElement instanceof Atomic.Symbol;
      const constructorEndIdx = hasEliminator ? elements.length - 1 : elements.length;
      const eliminatorName = hasEliminator ? getValue(lastElement as Element) : undefined;

      // Parse constructors: (constructor-name ((args...)) (ReturnType ...))
      const constructors: GeneralConstructor[] = [];
      for (let i = 4; i < constructorEndIdx; i++) {
        const ctorElement = elements[i] as Extended.List;
        const ctorName = getValue(ctorElement.elements[0] as Element);
        
        // Handle constructor arguments - could be () (Nil) or ((arg1) (arg2)...) (List)
        const ctorArgsElem = ctorElement.elements[1];
        let ctorArgsRaw: Expression[] = [];
        if (ctorArgsElem instanceof Extended.List) {
          ctorArgsRaw = ctorArgsElem.elements || [];
        } else if (ctorArgsElem instanceof Atomic.Nil) {
          ctorArgsRaw = []; // Empty arguments
        }
        
        const ctorReturnType = ctorElement.elements[2] as Element;

        // Parse constructor arguments: ((n Nat)) or ((j Nat) (k Nat) (j<k (Less-Than () (j k))))
        const ctorArgs = ctorArgsRaw.map(arg => {
          const pair = arg as Extended.List;
          const argType = pair.elements[1] as Element;

          // Parse the argument type using standard parsing
          const parsedArgType: S.Source = Parser.parseElements(argType);

          return new TypedBinder(
            syntaxToSiteBinder(elementToSyntax(pair.elements[0] as Element, pair.location)),
            parsedArgType
          );
        });

        // Parse return type: (TypeName (params...) (indices...))
        // Note: Constructor return types do NOT use  prefix
        const returnTypeList = ctorReturnType as Extended.List;
        const returnTypeName = getValue(returnTypeList.elements[0] as Element);

        if (returnTypeList.elements.length < 3) {
          throw new Error(`Constructor return type must specify parameters and indices: (${returnTypeName} (params...) (indices...))`);
        }

        // Parse parameters list
        const returnParamsElem = returnTypeList.elements[1];
        let returnParams: S.Source[] = [];
        if (returnParamsElem instanceof Extended.List) {
          returnParams = (returnParamsElem.elements || []).map(p => Parser.parseElements(p as Element));
        } else if (returnParamsElem instanceof Atomic.Nil) {
          returnParams = []; // Empty list
        }

        // Parse indices list
        const returnIndicesElem = returnTypeList.elements[2];
        let returnIndices: S.Source[] = [];
        if (returnIndicesElem instanceof Extended.List) {
          returnIndices = (returnIndicesElem.elements || []).map(idx => Parser.parseElements(idx as Element));
        } else if (returnIndicesElem instanceof Atomic.Nil) {
          returnIndices = []; // Empty list
        }

        const returnType = Maker.makeGeneralTypeConstructor(
          elementToSyntax(returnTypeList.elements[0] as Element, returnTypeList.location),
          returnTypeName,
          returnParams,
          returnIndices
        );

        constructors.push(
          new GeneralConstructor(
            syntaxToLocation(elementToSyntax(ctorElement.elements[0] as Element, ctorElement.location)),
            ctorName,
            ctorArgs,
            returnType
          )
        );
      }

      return new TypeDefinition(
        syntaxToLocation(elementToSyntax(elements[0] as Element, loc)),
        typeName,
        parameters,
        indices,
        constructors,
        eliminatorName
      );
    } else {
      return Parser.parseElements(ast);
    }
  }
}
