"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.pieDeclarationParser = exports.DefineTactically = exports.SamenessCheck = exports.Definition = exports.Claim = exports.Parser = void 0;
exports.syntaxToLocation = syntaxToLocation;
exports.schemeParse = schemeParse;
const scheme_lexer_1 = require("../../scheme_parser/transpiler/lexer/scheme-lexer");
const scheme_parser_1 = require("../../scheme_parser/transpiler/parser/scheme-parser");
const scheme_node_types_1 = require("../../scheme_parser/transpiler/types/nodes/scheme-node-types");
const locations_1 = require("../utils/locations");
const utils_1 = require("../types/utils");
const Maker = __importStar(require("./makers"));
// ### Helper functions
function syntaxToLocation(syntax) {
    return new locations_1.Location(syntax, true);
}
function syntaxToSiteBinder(syntax) {
    return new utils_1.SiteBinder(syntaxToLocation(syntax), syntax.source);
}
function getValue(element) {
    if (element instanceof scheme_node_types_1.Atomic.Symbol) {
        return element.value;
    }
    else if (element instanceof scheme_node_types_1.Atomic.NumericLiteral) {
        return element.value;
    }
    else if (element instanceof scheme_node_types_1.Extended.List) {
        return getValue(element.elements[0]);
    }
    else {
        throw new Error('Expected a Element, but got: ' + element);
    }
}
function locationToSyntax(source, location) {
    return new locations_1.Syntax(location.start, location.end, source);
}
function elementToSyntax(element, location) {
    return locationToSyntax(getValue(element), location);
}
// ### Parser
// The parser class is responsible for parsing the AST generated by the SchemeParser
function schemeParse(stx) {
    const lexer = new scheme_lexer_1.SchemeLexer(stx);
    const parser = new scheme_parser_1.SchemeParser('', lexer.scanTokens());
    const ast = parser.parse();
    return ast;
}
class Parser {
    static parsePie(stx) {
        return Parser.parseElements(schemeParse(stx)[0]);
    }
    static parseElements(element) {
        const parsee = getValue(element);
        if (parsee === 'U') {
            return Maker.makeU(locationToSyntax('U', element.location));
        }
        else if (parsee === 'the') {
            let elements = element.elements;
            let loc = element.location;
            return Maker.makeThe(locationToSyntax('the', loc), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'Nat') {
            return Maker.makeNat(locationToSyntax('Nat', element.location));
        }
        else if (parsee === 'zero') {
            return Maker.makeZero(locationToSyntax('zero', element.location));
        }
        else if (parsee === 'add1') {
            return Maker.makeAdd1(locationToSyntax('add1', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === '->' || parsee === '→') {
            let elements = element.elements;
            let loc = element.location;
            return Maker.makeArrow(locationToSyntax('->', loc), [
                this.parseElements(elements[1]),
                this.parseElements(elements[2]),
                elements.slice(3).map((x) => this.parseElements(x))
            ]);
        }
        else if (parsee === 'lambda' || parsee === 'λ') {
            let elements = element.elements;
            let loc = element.location;
            let args = elements[1];
            let body = elements[2];
            return Maker.makeLambda(locationToSyntax('λ', loc), args.elements.map((x) => syntaxToSiteBinder(elementToSyntax(x, element.location))), this.parseElements(body));
        }
        else if (parsee === 'Pi' || parsee === 'Π') {
            let elements = element.elements;
            let args = elements[1];
            let body = elements[2];
            // Get first binding pair
            let firstPair = args.elements[0];
            let x0 = firstPair.elements[0];
            let A0 = firstPair.elements[1];
            // Process remaining binding pairs
            let remainingPairs = args.elements.slice(1);
            let processedPairs = remainingPairs.map(pair => {
                let x = pair.elements[0];
                let A = pair.elements[1];
                return new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x, pair.location)), this.parseElements(A));
            });
            return Maker.makePi(locationToSyntax('Π', element.location), Maker.makeTypedBinders(new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)), this.parseElements(A0)), processedPairs), this.parseElements(body));
        }
        else if (parsee === 'Sigma' || parsee === 'Σ') {
            let elements = element.elements;
            let args = elements[1];
            let body = elements[2];
            // Get first binding pair
            let firstPair = args.elements[0];
            let x0 = firstPair.elements[0];
            let A0 = firstPair.elements[1];
            // Process remaining binding pairs
            let remainingPairs = args.elements.slice(1);
            let processedPairs = remainingPairs.map(pair => {
                let x = pair.elements[0];
                let A = pair.elements[1];
                return new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x, pair.location)), this.parseElements(A));
            });
            return Maker.makeSigma(locationToSyntax('Π', element.location), Maker.makeTypedBinders(new utils_1.TypedBinder(syntaxToSiteBinder(elementToSyntax(x0, firstPair.location)), this.parseElements(A0)), processedPairs), this.parseElements(body));
        }
        else if (parsee === 'Pair') {
            let elements = element.elements;
            return Maker.makePair(locationToSyntax('Pair', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'cons') {
            let elements = element.elements;
            return Maker.makeCons(locationToSyntax('Cons', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'car') {
            return Maker.makeCar(locationToSyntax('car', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'cdr') {
            return Maker.makeCdr(locationToSyntax('cdr', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'which-Nat') {
            let elements = element.elements;
            return Maker.makeWhichNat(locationToSyntax('which-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'iter-Nat') {
            let elements = element.elements;
            return Maker.makeIterNat(locationToSyntax('iter-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'rec-Nat') {
            let elements = element.elements;
            return Maker.makeRecNat(locationToSyntax('rec-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'ind-Nat') {
            let elements = element.elements;
            return Maker.makeIndNat(locationToSyntax('ind-Nat', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === 'Atom') {
            return Maker.makeAtom(locationToSyntax('Atom', element.location));
        }
        else if (parsee === 'quote') {
            return Maker.makeQuote(locationToSyntax('Quote', element.location), getValue(element.elements[1]));
        }
        else if (parsee === 'Trivial') {
            return Maker.makeTrivial(locationToSyntax('Trivial', element.location));
        }
        else if (parsee === 'sole') {
            return Maker.makeSole(locationToSyntax('sole', element.location));
        }
        else if (parsee === 'List') {
            return Maker.makeList(locationToSyntax('List', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'nil') {
            return Maker.makeNil(locationToSyntax('nil', element.location));
        }
        else if (parsee === '::') {
            let elements = element.elements;
            return Maker.makeListCons(locationToSyntax('::', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'rec-List') {
            let elements = element.elements;
            return Maker.makeRecList(locationToSyntax('rec-List', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'ind-List') {
            let elements = element.elements;
            return Maker.makeIndList(locationToSyntax('ind-List', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === '=') {
            let elements = element.elements;
            return Maker.makeEqual(locationToSyntax('=', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'same') {
            return Maker.makeSame(locationToSyntax('same', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'replace') {
            let elements = element.elements;
            return Maker.makeReplace(locationToSyntax('replace', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'trans') {
            let elements = element.elements;
            return Maker.makeTrans(locationToSyntax('trans', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'cong') {
            let elements = element.elements;
            return Maker.makeCong(locationToSyntax('cong', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'ind-=') {
            let elements = element.elements;
            return Maker.makeIndEqual(locationToSyntax('ind-=', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]));
        }
        else if (parsee === 'symm') {
            return Maker.makeSymm(locationToSyntax('symm', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'Vec') {
            let elements = element.elements;
            return Maker.makeVec(locationToSyntax('Vec', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'vecnil') {
            return Maker.makeVecNil(locationToSyntax('vecnil', element.location));
        }
        else if (parsee === 'vec::') {
            let elements = element.elements;
            return Maker.makeVecCons(locationToSyntax('vec::', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'head') {
            return Maker.makeHead(locationToSyntax('head', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'tail') {
            return Maker.makeTail(locationToSyntax('tail', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'ind-Vec') {
            let elements = element.elements;
            return Maker.makeIndVec(locationToSyntax('ind-Vec', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]), this.parseElements(elements[5]));
        }
        else if (parsee === 'Either') {
            let elements = element.elements;
            return Maker.makeEither(locationToSyntax('Either', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'left') {
            return Maker.makeLeft(locationToSyntax('left', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'right') {
            return Maker.makeRight(locationToSyntax('right', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'ind-Either') {
            let elements = element.elements;
            return Maker.makeIndEither(locationToSyntax('ind-Either', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]), this.parseElements(elements[3]), this.parseElements(elements[4]));
        }
        else if (parsee === 'Absurd') {
            return Maker.makeAbsurd(locationToSyntax('Absurd', element.location));
        }
        else if (parsee === 'ind-Absurd') {
            let elements = element.elements;
            return Maker.makeIndAbsurd(locationToSyntax('ind-Absurd', element.location), this.parseElements(elements[1]), this.parseElements(elements[2]));
        }
        else if (parsee === 'TODO') {
            return Maker.makeTODO(locationToSyntax('TODO', element.location));
        }
        else if (element instanceof scheme_node_types_1.Extended.List && element.elements.length > 1) {
            let elements = element.elements;
            return Maker.makeApp(locationToSyntax('App', element.location), this.parseElements(elements[0]), this.parseElements(elements[1]), elements.slice(2).map((x) => this.parseElements(x)));
        }
        else if ((0, utils_1.isVarName)(parsee)) {
            return Maker.makeVarRef(locationToSyntax(parsee, element.location), parsee);
        }
        else if (!isNaN(Number(parsee))) { // numeric literal
            return Maker.makeNatLiteral(locationToSyntax(parsee, element.location), parsee);
        }
        throw new Error('Unexpected element: ' + element);
    }
    static parseToTactics(element) {
        const parsee = getValue(element);
        if (parsee === 'exact') {
            return Maker.makeExact(locationToSyntax('exact', element.location), this.parseElements(element.elements[1]));
        }
        else if (parsee === 'intro') {
            return Maker.makeIntro(locationToSyntax('intro', element.location), element.elements[1].value);
        }
        else if (parsee === 'exists') {
            return Maker.makeExists(locationToSyntax('exists', element.location), this.parseElements(element.elements[1]), element.elements[2].value);
        }
        else if (parsee === 'elimNat') {
            return Maker.makeElimNat(locationToSyntax('elimNat', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'elimList') {
            return Maker.makeElimList(locationToSyntax('elimList', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'elimVec') {
            return Maker.makeElimVec(locationToSyntax('elimVec', element.location), element.elements[1].value, this.parseElements(element.elements[2]), this.parseElements(element.elements[3]));
        }
        else if (parsee === 'elimEqual') {
            return Maker.makeElimEqual(locationToSyntax('elimEqual', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'left') {
            return Maker.makeLeftTactic(locationToSyntax('left', element.location));
        }
        else if (parsee === 'right') {
            return Maker.makeRightTactic(locationToSyntax('right', element.location));
        }
        else if (parsee === 'elimEither') {
            return Maker.makeElimEither(locationToSyntax('elimEither', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        else if (parsee === 'split') {
            return Maker.makeSplit(locationToSyntax('split', element.location));
        }
        else if (parsee === 'elimAbsurd') {
            return Maker.makeElimAbsurd(locationToSyntax('elimAbsurd', element.location), element.elements[1].value, this.parseElements(element.elements[2]));
        }
        throw new Error('Unexpected tactic: ' + element);
    }
}
exports.Parser = Parser;
// ### Helper functions for parsing the AST
class Claim {
    constructor(location, name, type) {
        this.location = location;
        this.name = name;
        this.type = type;
    }
}
exports.Claim = Claim;
class Definition {
    constructor(location, name, expr) {
        this.location = location;
        this.name = name;
        this.expr = expr;
    }
}
exports.Definition = Definition;
class SamenessCheck {
    constructor(location, type, left, right) {
        this.location = location;
        this.type = type;
        this.left = left;
        this.right = right;
    }
}
exports.SamenessCheck = SamenessCheck;
class DefineTactically {
    constructor(location, name, tactics) {
        this.location = location;
        this.name = name;
        this.tactics = tactics;
    }
}
exports.DefineTactically = DefineTactically;
class pieDeclarationParser {
    static parseDeclaration(ast) {
        const parsee = getValue(ast);
        if (parsee === 'claim') {
            let elements = ast.elements;
            return new Claim(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), Parser.parseElements(elements[2]));
        }
        else if (parsee === 'define') {
            let elements = ast.elements;
            return new Definition(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), Parser.parseElements(elements[2]));
        }
        else if (parsee === 'check-same') {
            let elements = ast.elements;
            return new SamenessCheck(syntaxToLocation(elementToSyntax(elements[0], ast.location)), Parser.parseElements(elements[1]), Parser.parseElements(elements[2]), Parser.parseElements(elements[3]));
        }
        else if (parsee === 'define-tactically') {
            let elements = ast.elements;
            return new DefineTactically(syntaxToLocation(elementToSyntax(elements[0], ast.location)), getValue(elements[1]), elements[2].elements.map((x) => Parser.parseToTactics(x)));
        }
        else {
            return Parser.parseElements(ast);
        }
    }
}
exports.pieDeclarationParser = pieDeclarationParser;
//# sourceMappingURL=parser.js.map